<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C#杂记之伍：数组与集合</title>
    <url>/2020/04/15/C-%E6%9D%82%E8%AE%B0%E4%B9%8B%E4%BC%8D%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>数组可以说是在任何语言中都非常基本的数据结构了。这篇笔记以C#中的数组为引，再延伸到C#的几种集合类(Collections)以及一些相关的基本概念。</p>
<h1 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>数组存储相同种类的元素，其大小固定，且是顺序存储的，即在内存中占据一段连续的地址。</p>
<p>数组作为一种引用类型(其基类是System.Array)，需要用<code>new</code>来创建实例。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化时指定大小</span></span><br><span class="line"><span class="keyword">double</span>[] balance = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以直接赋值来初始化</span></span><br><span class="line"><span class="keyword">int</span>[] marks = &#123;<span class="number">99</span>, <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>初始化而尚未赋值的数组，编译器会根据其类型隐式地将所有元素设置为默认值。</p>
<p>数组最大的特点还是能够用下标索引来随机访问其中的元素：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> salary = balance[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是C# 8.0引入的好东西！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//末尾运算符 ^ </span></span><br><span class="line"><span class="comment">//[^n]表示[length-n]，类似Python用负数索引[-n]表示[length-n]</span></span><br><span class="line"><span class="keyword">double</span> salary = balance[^<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//范围运算符 ..</span></span><br><span class="line"><span class="comment">//[a..b]表示从[a]到[b]的范围，类似Python的切片[a:b]，a、b均可省略以表示首尾</span></span><br><span class="line"><span class="keyword">double</span>[] salaries = balance[..^<span class="number">3</span>];</span><br><span class="line"><span class="comment">//如果a比b还大，会抛出异常(Python中则是返回空列表)</span></span><br><span class="line"><span class="keyword">double</span>[] salaries = balance[<span class="number">3.</span><span class="number">.2</span>];     <span class="comment">//ArgumentOutOfRangeException</span></span><br></pre></td></tr></table></figure>

<p>由于实现了<code>IEnumerable</code>接口，数组可以使用<code>foreach...in...</code>的方式进行迭代访问，还可以使用LINQ，这样就无需获取数组长度再用for循环迭代了。关于这个接口及其相关的内容，我在本文稍后的部分记述。</p>
<a id="more"></a>

<h2 id="索引器-Indexer"><a href="#索引器-Indexer" class="headerlink" title="索引器 Indexer"></a>索引器 Indexer</h2><p>索引器（Indexer）可以让各种类、结构、接口实现数组的这种能够用下标索引来访问的功能。</p>
<p>索引器就像一个名为<code>this</code>的属性，可以用访问器进行定义。</p>
<blockquote>
<p>访问器是可在属性上定义的两个方法。其中get方法在读属性时执行；set方法隐含一个传入的<code>value</code>参数，在写属性时执行。一个常见的用途是用公开属性的访问器来对私有属性进行读/写。另外也可以在set访问器里对传入值进行范围检查等操作。</p>
</blockquote>
<p>索引器的一般定义示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">element-type <span class="keyword">this</span>[<span class="keyword">int</span> index]</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// get 访问器</span></span><br><span class="line">   <span class="keyword">get</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 返回 index 指定的值</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// set 访问器</span></span><br><span class="line">   <span class="keyword">set</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 设置 index 指定的值</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比较神奇的是，索引器的索引下标并不是只能使用int，还可以用string。同时索引器又像是一个方法，甚至可以重载，这意味着你可以同时定义以int和string作为索引下标的索引器。</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>C#的多维数组在定义时，维度之间用逗号隔开。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三维数组</span></span><br><span class="line"><span class="keyword">int</span>[, ,] array3Da = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>] &#123; &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125; &#125;, </span><br><span class="line">                                        &#123; &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;, &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125; &#125; &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="交错数组"><a href="#交错数组" class="headerlink" title="交错数组"></a>交错数组</h2><p>交错数组是<strong>数组的数组</strong>。当我们说“数组”的时候，说的是一个引用类型。因此交错数组与多维数组的不同之处在于，它本质上是个一维数组，其元素为引用类型，且被初始化为null。</p>
<p>也正因此，交错数组中的元素只需要是规定的数组类型即可，不需要具有一致的长度：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包含大小不同的三个二维数组元素的一维交错数组：</span></span><br><span class="line"><span class="keyword">int</span>[][,] jaggedArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][,] </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[,] &#123; &#123;<span class="number">1</span>,<span class="number">3</span>&#125;, &#123;<span class="number">5</span>,<span class="number">7</span>&#125; &#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[,] &#123; &#123;<span class="number">0</span>,<span class="number">2</span>&#125; &#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="keyword">int</span>[,] &#123; &#123;<span class="number">11</span>,<span class="number">22</span>&#125;, &#123;<span class="number">99</span>,<span class="number">88</span>&#125;, &#123;<span class="number">0</span>,<span class="number">9</span>&#125; &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">System.Console.Write(<span class="string">"&#123;0&#125;"</span>, jaggedArray4[<span class="number">0</span>][<span class="number">1</span>, <span class="number">0</span>]);   <span class="comment">//输出：5</span></span><br></pre></td></tr></table></figure>

<h1 id="集合-Collections"><a href="#集合-Collections" class="headerlink" title="集合 Collections"></a>集合 Collections</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>集合类是定义在<code>System.Collection</code>命名空间里的几种类。比起数组，它们实现了几个接口，能更方便用于存储和检索数据。</p>
<p>为了支持无数种类型，非泛型集合把所有的元素都装箱成<code>object</code>类的对象来存储。元素的读写总要涉及到装箱与拆箱，在性能上有一定损失；而且也因为装箱，你可以把任意不同类型的元素装进同一个集合，这是危险的，相当不妙。</p>
<p>因此，在引入对泛型的支持后，更好的选择是使用命名空间<code>System.Collection.Genreric</code>里的泛型集合来存储数据。以下是几种非泛型和泛型集合：</p>
<table>
<thead>
<tr>
<th align="left">非泛型集合类</th>
<th align="left">泛型集合类</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">动态数组 ArrayList</td>
<td align="left">列表 List&lt;T&gt;</td>
<td align="left">具有动态大小的数组</td>
</tr>
<tr>
<td align="left">哈希表 Hashtable</td>
<td align="left">字典 Dictionary&lt;Tkey,Tvalue&gt;</td>
<td align="left">由键-值对组成的集合</td>
</tr>
<tr>
<td align="left">排序列表 SortedList</td>
<td align="left">排序列表 SortedList&lt;Tkey,Tvalue&gt;</td>
<td align="left">和字典相似但有排序功能</td>
</tr>
<tr>
<td align="left">队列 Queue</td>
<td align="left">队列 Queue&lt;T&gt;</td>
<td align="left">先进先出（FIFO）队列</td>
</tr>
<tr>
<td align="left">堆栈 Stack</td>
<td align="left">堆栈Stack&lt;T&gt;</td>
<td align="left">后进先出（LIFO）队列</td>
</tr>
</tbody></table>
<p>而泛型集合中，最常用的是List&lt;T&gt;和Dictionary&lt;Tkey,Tvalue&gt;，其它的集合基本都建立在其基础上。</p>
<h2 id="列表-List-lt-T-gt"><a href="#列表-List-lt-T-gt" class="headerlink" title="列表 List&lt;T&gt;"></a>列表 List&lt;T&gt;</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>上面的表格里写到，List&lt;T&gt;是泛型版本的ArrayList，是具有动态大小的<strong>数组</strong>。也就是说，其原理依然是<strong>顺序存储</strong>的数组，具有随机访问快但插入删除较慢的特点。</p>
<p>C#里有没有用双向链表实现的链式存储数据结构呢？也是有的，它就是LinkedList&lt;T&gt;，只不过很少有人会用到，毕竟随机访问速度在大多数场景下更加重要。</p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>要创建一种类型的列表，依然需要用new：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">List&lt;Animal&gt; animalCollection = <span class="keyword">new</span> List&lt;Animal&gt;();</span><br></pre></td></tr></table></figure>

<h3 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h3><p>List中有两个int属性：Count和Capacity。</p>
<p>Count代表List中现有的元素数量，而Capacity代表List的容量。当Count达到Capacity的值，再试图加入元素时，Capacity就会自动进行调整。下面是在一个List&lt;int&gt;中加入600个元素的结果，其中白色数字代表现有元素数量Count，绿色数字代表List容量Capacity：</p>
<p><img src="https://i.loli.net/2020/04/13/iIOaP5s24YgMCpX.png" alt="动态调整Capacity"></p>
<p>可以看出，加入第一个元素时，Capacity从0被调整到4。之后每次Count要超过Capacity时，Capacity就会翻倍，以容纳更多元素。这个容量调整算法不是固定的，比如对于Dictionary&lt;Tkey,Tvalue&gt;来说，每次调整增加的容量都是质数。虽然不知道为什么要这样设计，但奇怪的知识增加了！</p>
<p>除了让其自动增长之外，还可以直接访问Capacity，手动设置为不小于当前Count的值；也可以调用List的<code>TrimExcess()</code>方法，将Capacity直接削至Count的值。不过考虑到开销，如果未使用的容量小于总容量的10%，则不会对容量进行调整。下面是在加入了300个元素后，调用<code>TrimExcess()</code>（用黄色字体表示），再加入300个元素的效果：</p>
<p><img src="https://i.loli.net/2020/04/13/iOIcSNkACBZKDPa.png" alt="TrimExcess"></p>
<p>手动设置Capacity有什么用呢？毕竟就算设置了，由于Capacity的自动调整机制，还是能不受限制地往里添加元素。而且在调整Capacity时，还会有复杂度为O(n)的计算，这是因为List&lt;T&gt;仍然基于顺序存储，调整Capacity必须在内存中重新划分一块区域，再把元素复制进去。关于手动调整Capacity的意义我依然存疑，如果你知道，请告诉我！</p>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ul>
<li>Add() 在末尾动态加入元素</li>
<li>AddRange() 在末尾添加一个集合中的元素</li>
<li>Insert() 在指定索引处插入元素</li>
<li>InsertRange() 在指定索引处插入一个集合的元素</li>
</ul>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ul>
<li>Remove() 删除第一个内容匹配的元素</li>
<li>RemoveAt() 删除指定索引处的元素</li>
<li>RemoveRange() 删除一定范围内的元素</li>
<li>RemoveAll() 删除所有条件匹配的元素</li>
<li>Clear() 直接清空</li>
</ul>
<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p>依然可以直接用下标索引访问：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">animalCollection[<span class="number">0</span>] = cat;</span><br></pre></td></tr></table></figure>

<p>其原理是List类用Item()方法作索引器。</p>
<p>但要注意，List的长度是其Count属性的值。对于新建的List，没有任何元素，Count为0，甚至不能用0号索引来访问并赋值。应该先用一些方法让索引对应的位置可用。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">List&lt;Animal&gt; animalCollection = <span class="keyword">new</span> List&lt;Animal&gt;();</span><br><span class="line">animalCollection[<span class="number">0</span>] = cat;    <span class="comment">//这是错误的，0号元素还不存在</span></span><br><span class="line"></span><br><span class="line">List&lt;Animal&gt; animalCollection = <span class="keyword">new</span> List&lt;Animal&gt;(<span class="keyword">new</span> Animal[<span class="number">10</span>]);</span><br><span class="line">animalCollection[<span class="number">0</span>] = cat;    <span class="comment">//这是可以的，创建List时填入了10个null</span></span><br></pre></td></tr></table></figure>

<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ul>
<li>Contains() 判断List内是否有内容匹配的元素</li>
<li>Exists() 判断List内是否有条件匹配的元素</li>
<li>Find() 查找并返回第一个条件匹配元素</li>
<li>FindAll() 查找并以List的形式返回所有条件匹配元素</li>
<li>IndexOf() 查找第一个内容匹配的元素，返回其索引(可以用重载指定搜索范围)</li>
<li>LastIndexOf() 查找倒数第一个内容匹配的元素，返回其索引(可以用重载指定搜索范围)</li>
<li>BinarySearch() 用指定的比较器在一定范围内二分查找元素，返回其索引</li>
</ul>
<h2 id="字典-Dictionary-lt-Tkey-Tvalue-gt"><a href="#字典-Dictionary-lt-Tkey-Tvalue-gt" class="headerlink" title="字典 Dictionary&lt;Tkey,Tvalue&gt;"></a>字典 Dictionary&lt;Tkey,Tvalue&gt;</h2><p>C#中的字典是泛型的哈希表（HashTable），存储的是键值对<code>KeyValuePair&lt;TKey, TValue&gt;</code>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt; mydict = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;();</span><br><span class="line"><span class="comment">//仍然是Add()添加元素</span></span><br><span class="line">mydict.Add(<span class="string">"lang1"</span>, <span class="string">"C++"</span>);</span><br><span class="line">mydict.Add(<span class="string">"lang2"</span>, <span class="string">"C#"</span>);</span><br><span class="line">mydict.Add(<span class="string">"lang3"</span>, <span class="string">"Python"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//CotainsKey()判断是否有该键，也有ContainsValue()判断是否有值</span></span><br><span class="line"><span class="keyword">if</span>(mydict.ContainsKey(<span class="string">"lang3"</span>))</span><br><span class="line">      mydict.Remove(<span class="string">"lang3"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据TKey使用索引器，但访问前不检查可能会爆炸(KeyNotFoundException)</span></span><br><span class="line"><span class="comment">//WriteLine(mydict["lang3"]);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//TryGetValue()尝试用key获取value，没获取到的话传出null，本身返回False</span></span><br><span class="line">WriteLine(mydict.TryGetValue(<span class="string">"lang4"</span>, <span class="keyword">out</span> <span class="keyword">string</span> test));</span><br><span class="line">WriteLine(test);</span><br></pre></td></tr></table></figure>

<h2 id="队列-Queue-lt-T-gt-和堆栈-Stack-lt-T-gt"><a href="#队列-Queue-lt-T-gt-和堆栈-Stack-lt-T-gt" class="headerlink" title="队列 Queue&lt;T&gt;和堆栈 Stack&lt;T&gt;"></a>队列 Queue&lt;T&gt;和堆栈 Stack&lt;T&gt;</h2><p>这两个就更没什么值得说的了，基本上是List&lt;T&gt;的“阉割”版。</p>
<p>对于它们而言，添加、删除元素并不是用Add()方法和Remove()方法。队列Queue&lt;T&gt;中，使用入队Enqueue()和出队Dequeue()；队列Stack&lt;T&gt;中，使用压入Push()和弹出Pop()。</p>
<p>你也无法再使用索引随机访问Queue和Stack中的元素，必须遵守这两种数据结构的规则。能进行的操作非常有限，比如用Peek()访问队首/栈顶元素。</p>
<h1 id="枚举器"><a href="#枚举器" class="headerlink" title="枚举器"></a>枚举器</h1><p>说到枚举器，必须了解的是两个接口：<code>IEnumerator</code>和<code>IEnumerable</code>。</p>
<h2 id="IEnumerable"><a href="#IEnumerable" class="headerlink" title="IEnumerable"></a>IEnumerable</h2><p>所有的数组和集合都实现了这个接口，它们被称为可枚举类型。这也是数组和集合能进行各种操作，乃至使用LINQ的基础。这个接口里只有一个方法：</p>
<p><code>GetEnumerator()</code>。</p>
<p>方法名很易懂，获取枚举器。C#中的“枚举器”，指的就是实现了接口<code>IEnumerator</code>的类型。</p>
<p>LINQ为IEnumerable接口添加了许多扩展方法，这一点在第C#杂记的壹和叁中我都有提到。其实由于LINQ用查询表达式写可读性更强，这些扩展方法里我觉得最有用的是<code>ToList()</code>方法，它可以把各种数组和集合都转换为万能的List&lt;T&gt;。特别地，对Stack&lt;T&gt;来说，调用<code>ToList()</code>后得到的列表是根据“后进先出”的出栈顺序排列的。</p>
<h2 id="IEnumerator"><a href="#IEnumerator" class="headerlink" title="IEnumerator"></a>IEnumerator</h2><p>如上所说，实现了这个接口的类型被称为枚举器。</p>
<p>枚举器的工作就是把元素一个个地吐出来（枚举）。这个接口用三个成员共同实现了类似链表的数据结构：</p>
<ul>
<li>Current：序列中当前位置项的属性，以<code>object?</code>可空类型表示，故可以为任何类型。原始状态下这个属性不可用，访问时会抛出异常：<blockquote>
<p>System.InvalidOperationException:“Enumeration has not started. Call MoveNext.”</p>
</blockquote>
</li>
<li>MoveNext()：将枚举器位置指向下一项，如果下一项是无效的，则返回False，表示枚举已经完成。</li>
<li>Reset()：把位置重置为原始状态。</li>
</ul>
<p>实现了<code>IEnumerable</code>的可枚举类型，其能够使用foreach语句进行迭代的原理就是运用了枚举器：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span>[] myArray = &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span> &#125;;		<span class="comment">// 创建数组</span></span><br><span class="line">        <span class="keyword">var</span> ie = myArray.GetEnumerator();	<span class="comment">// 获取枚举器</span></span><br><span class="line">        <span class="keyword">while</span> (ie.MoveNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = (<span class="keyword">int</span>)ie.Current;	<span class="comment">// 获取当前项</span></span><br><span class="line">            Console.WriteLine(<span class="string">"&#123;0&#125;"</span>, i);	<span class="comment">// 输出</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用foreach进行同样的迭代</span></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> i <span class="keyword">in</span> myArray)</span><br><span class="line">            Console.WriteLine(<span class="string">"&#123;0&#125;"</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="比较与排序"><a href="#比较与排序" class="headerlink" title="比较与排序"></a>比较与排序</h1><p>众所周知，一切排序算法的基础都是<strong>比较</strong>。不同排序算法的复杂度之差异，就在于它们比较元素的次数。</p>
<p>C#中有两个接口用于实现比较：<code>IComparable</code>和<code>IComparer</code>。</p>
<p>看这两个接口的名字，就可以会猜测它们和上面在枚举器里说到的两个接口的关系一样。事实上它们之间有很大不同，但也有相似之处。</p>
<h2 id="IComparable"><a href="#IComparable" class="headerlink" title="IComparable"></a>IComparable</h2><p>实现了这个接口的类型是可比较类型，由它们组成的数组、集合是可以进行排序的。C#中有很多内置类型已经实现了这个接口，比如各种值类型、字符串、时间日期等等。</p>
<p>这个接口也只有一个方法：<code>CompareTo()</code>。</p>
<p>CompareTo()接收一个用于和<code>this</code>比较的参数，并返回一个<code>int</code>作为比较的结果。举个例子，如果定义了<code>Person</code>类，且为其实现IComparable接口：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">IComparable</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="keyword">string</span> name, <span class="keyword">int</span> age</span>) </span></span><br><span class="line"><span class="function"></span>   &#123; </span><br><span class="line">      <span class="keyword">this</span>.Name = name; </span><br><span class="line">      <span class="keyword">this</span>.Age = age; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//实现IComparable接口</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">CompareTo</span>(<span class="params"><span class="keyword">object</span> obj</span>)</span></span><br><span class="line"><span class="function"></span>   &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.Age == obj.Age)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.Age &gt; obj.Age)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在此基础上，比较两个Person：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(person1.CompareTo(person2) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   WriteLine(<span class="string">"Same Age."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(person1.CompareTo(person2) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   WriteLine(<span class="string">"Person 1 is older."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(person1.CompareTo(person2) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   WriteLine(<span class="string">"Person 1 is younger."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IComparer-lt-T-gt"><a href="#IComparer-lt-T-gt" class="headerlink" title="IComparer&lt;T&gt;"></a>IComparer&lt;T&gt;</h2><p>Comparer是“比较器”，对于那些没有实现IComparable接口的类，可以为其单独定义一个实现IComparer&lt;T&gt;的类。</p>
<p>接口中包含一个方法<code>Compare()</code>。它对两个<code>T</code>类型的对象进行比较，返回<code>int</code>作为比较的结果。这个接口也有非泛型版本，它能支持不同类型的对象之间的比较，这很神秘，可能一般不会用到。</p>
<p>用实现了IComparer&lt;Person&gt;的比较器对两个Person进行比较：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Person person1 = <span class="keyword">new</span> Person(<span class="string">"张三"</span>, <span class="number">24</span>);</span><br><span class="line">   Person person2 = <span class="keyword">new</span> Person(<span class="string">"罗翔"</span>, <span class="number">42</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">int</span> n = <span class="keyword">new</span> PersonComparer().Compare(person1, person2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Sort-方法"><a href="#Sort-方法" class="headerlink" title="Sort()方法"></a>Sort()方法</h2><p>Sort()方法运用集合中元素所属类型的默认比较方法，或指定的某种比较方法进行<strong>升序排序</strong>。</p>
<p>这个方法有四种重载：</p>
<ul>
<li>Sort()<br>无参形式，在元素对象实现了IComparable接口时可以使用。</li>
<li>Sort(IComparer&lt;T&gt;)<br>以比较器为参数，需要定义比较器，并<code>new</code>一个传入。</li>
<li>Sort(Int32, Int32, IComparer<T>)<br>在指定范围用比较器排序。</li>
<li>Sort(Comparison<T>)<br>用委托进行排序，其中委托Comparison&lt;T&gt;接受两个同类型参数，返回int。原型： <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">int</span> Comparison&lt;<span class="keyword">in</span> T&gt;(T x, T y);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这看起来并不够优雅，直接用LINQ的<code>OrderBy()</code>配合Lambda表达式来排序它不香吗？</p>
<p>据说OrderBy没法在Unity构建的iOS游戏上运行，所以必须得用Sort()。不过去它妹的，等真的踩了这个坑再说吧，现在先记在这里（笑）。</p>
<blockquote>
<p>原本以为数组和集合是极为简单的东西，计划着能在一天内写完，结果坑越挖越多，中途也写了不少代码进行测试和验证，竟然也花了快一个星期。至此，C#入门级别最大的几块拼图几乎完成了。后面的坑还有装箱拆箱、特性、堆区与栈区内存、对象的构造与析构过程、垃圾回收机制、异步流式处理等等，慢慢填吧。</p>
</blockquote>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>C#杂记之肆：异步</title>
    <url>/2020/04/08/C-%E6%9D%82%E8%AE%B0%E4%B9%8B%E8%82%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note warning">
            <p><strong>前方高能！</strong><br>这篇笔记断断续续花了近10天，思路、结构较为混沌，如果没有充分做好心理准备，建议立刻关闭窗口。<br>（其实就是我写完实在不愿审阅）</p>
          </div>

<p>首先说明，异步是<strong>极为高深</strong>的高级编程技术，这篇文章只是才疏学浅的我阅读文档之后的一些思考与理解，可能有极多描述不准确乃至完全错误之处，还望批评指导。顺便吐槽，C#文档翻译得实在是太烂了，很多地方一看就是机翻的，却没有机翻警告。很多地方百思不得其解的词，切换到英语就发现其实很简单，翻译的用词完全错误，难受啊！</p>
<h1 id="何为异步"><a href="#何为异步" class="headerlink" title="何为异步"></a>何为异步</h1><p>与异步相对的是“同步”，代表着一句代码的执行结束是其后一句代码的执行开始，整个流程是按照固定的顺序进行的，这是一般程序的逻辑。然而，某些语句可能需要花较长时间才能得到结果——比如网络通信和文件读写——这些语句的执行并不怎么占用CPU，但会阻塞整个线程，后续的语句需要等待这些语句执行完成，造成大量的浪费。特别是如果网络环境很不好、读取的文件好几个G，那可是尤其要命，可能整个程序都会出现肉眼可见的卡顿甚至崩溃。</p>
<p>为了解决这种飞快的CPU与龟爬的IO之间的不平衡，传统的方案是单独开个线程让它去执行耗时的操作，让主线程继续运行与耗时操作的结果无关的代码。但是线程操作很麻烦、开销很高，线程数量也有限，不是能随便使用的，所以依然不是个完美的方法。</p>
<p>异步就是为了解决这个问题而存在的。当代码需要执行一个耗时的操作时，它只发出指令，并不等待结果，然后就去执行其他代码了。一段时间后，当耗时操作返回结果时，再通知CPU进行处理。</p>
<a id="more"></a>

<h1 id="怎么使用"><a href="#怎么使用" class="headerlink" title="怎么使用"></a>怎么使用</h1><p>从C# 5开始，编写异步程序变得比较容易。</p>
<p>C#的异步编程模型主要通过两个关键字来使用：<code>async</code>和<code>await</code>。</p>
<h2 id="用早餐毁掉美好的一天"><a href="#用早餐毁掉美好的一天" class="headerlink" title="用早餐毁掉美好的一天"></a>用早餐毁掉美好的一天</h2><p>先来一段同步的憨憨代码，这描述了一个“做早餐”的流程：</p>
<ol>
<li>倒一杯咖啡。</li>
<li>加热平底锅，然后煎两个鸡蛋。</li>
<li>煎三片培根。</li>
<li>烤两片面包。</li>
<li>在烤面包上加黄油和果酱。</li>
<li>倒一杯橙汁。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Coffee cup = PourCoffee();          <span class="comment">//倒咖啡</span></span><br><span class="line">    Console.WriteLine(<span class="string">"coffee is ready"</span>);</span><br><span class="line">    Egg eggs = FryEggs(<span class="number">2</span>);              <span class="comment">//煎蛋</span></span><br><span class="line">    Console.WriteLine(<span class="string">"eggs are ready"</span>);</span><br><span class="line">    Bacon bacon = FryBacon(<span class="number">3</span>);          <span class="comment">//煎培根</span></span><br><span class="line">    Console.WriteLine(<span class="string">"bacon is ready"</span>);</span><br><span class="line">    Toast toast = ToastBread(<span class="number">2</span>);        <span class="comment">//烤面包</span></span><br><span class="line">    ApplyButter(toast);                 <span class="comment">//涂黄油</span></span><br><span class="line">    ApplyJam(toast);                    <span class="comment">//涂果酱</span></span><br><span class="line">    Console.WriteLine(<span class="string">"toast is ready"</span>);</span><br><span class="line">    Juice oj = PourOJ();                <span class="comment">//倒橙汁</span></span><br><span class="line">    Console.WriteLine(<span class="string">"oj is ready"</span>);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">"Breakfast is ready!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线性的逻辑很简单，但有大问题。煎蛋、煎培根和烤面包都要花很长时间，其实完全可以在做煎蛋和培根的同时，让面包自己在面包机里烤。不然还没等面包烤完，别的东西早凉透了，吃了可能还会引起肠胃不适。煎蛋和煎培根甚至也没必要一前一后——谁家还没有两个锅呢？或者找个大点的锅来一起煎也行啊。</p>
<h2 id="异步做早餐"><a href="#异步做早餐" class="headerlink" title="异步做早餐"></a>异步做早餐</h2><p>来看看一个近乎完美的“做早餐解决方案”是怎样的。下面是C#文档里的示范异步代码，我擅自添加了些方便理解的沙雕注释：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Coffee cup = PourCoffee();          <span class="comment">//倒杯咖啡</span></span><br><span class="line">    Console.WriteLine(<span class="string">"coffee is ready"</span>);</span><br><span class="line">    <span class="keyword">var</span> eggsTask = FryEggsAsync(<span class="number">2</span>);     <span class="comment">//得煎俩鸡蛋，开整！</span></span><br><span class="line">    <span class="keyword">var</span> baconTask = FryBaconAsync(<span class="number">3</span>);   <span class="comment">//得煎仨培根，开整！</span></span><br><span class="line">    <span class="keyword">var</span> toastTask = MakeToastWithButterAndJamAsync(<span class="number">2</span>);  <span class="comment">//得搞两片涂黄油和果酱的面包，开整！</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> allTasks = <span class="keyword">new</span> List&lt;Task&gt;&#123;eggsTask, baconTask, toastTask&#125;;  <span class="comment">//列个任务清单吧</span></span><br><span class="line">    <span class="keyword">while</span> (allTasks.Any())  <span class="comment">//看来清单里还有任务没搞完</span></span><br><span class="line">    &#123;</span><br><span class="line">        Task finished = <span class="keyword">await</span> Task.WhenAny(allTasks);   <span class="comment">//下一个完成的任务是啥？</span></span><br><span class="line">        <span class="keyword">if</span> (finished == eggsTask)   <span class="comment">//噢，是鸡蛋煎好了！</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"eggs are ready"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (finished == baconTask)     <span class="comment">//噢，是培根煎好了！</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"bacon is ready"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (finished == toastTask)     <span class="comment">//噢，是面包做完了！</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"toast is ready"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        allTasks.Remove(finished);      <span class="comment">//行，把完成的任务从清单里划了</span></span><br><span class="line">    &#125;</span><br><span class="line">    Juice oj = PourOJ();    <span class="comment">//最后再来杯橙汁，完事</span></span><br><span class="line">    Console.WriteLine(<span class="string">"oj is ready"</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">"Breakfast is ready!"</span>);   <span class="comment">//爽到</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">async</span> Task&lt;Toast&gt; <span class="title">MakeToastWithButterAndJamAsync</span>(<span class="params"><span class="keyword">int</span> number</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> toast = <span class="keyword">await</span> ToastBreadAsync(number);      <span class="comment">//要处理面包得先等面包烤好</span></span><br><span class="line">        ApplyButter(toast);     <span class="comment">//涂点黄油</span></span><br><span class="line">        ApplyJam(toast);        <span class="comment">//涂点果酱</span></span><br><span class="line">        <span class="keyword">return</span> toast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>粗略一看，握草，感觉魔改成异步之后复杂了好多。其实不然，我慢慢来分析。</p>
<h3 id="定义异步方法"><a href="#定义异步方法" class="headerlink" title="定义异步方法"></a>定义异步方法</h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> eggsTask = FryEggsAsync(<span class="number">2</span>);     <span class="comment">//得煎俩鸡蛋，开整！</span></span><br><span class="line"><span class="keyword">var</span> baconTask = FryBaconAsync(<span class="number">3</span>);   <span class="comment">//得煎仨培根，开整！</span></span><br><span class="line"><span class="keyword">var</span> toastTask = MakeToastWithButterAndJamAsync(<span class="number">2</span>);  <span class="comment">//得搞两片涂黄油和果酱的面包，开整！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> allTasks = <span class="keyword">new</span> List&lt;Task&gt;&#123;eggsTask, baconTask, toastTask&#125;;  <span class="comment">//列个任务清单吧</span></span><br></pre></td></tr></table></figure>

<p>可以注意到，这一段使用的几个方法，其名称都在后面加了个“Async”，这是异步方法的命名规范。调用三个异步方法，就是设置了三个任务（Task）。那谁谁，照这个任务去执行吧！我要接着跑后面的代码了。</p>
<p>那么，怎么定义一个异步方法呢？来看上面示例中的这个方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task&lt;Toast&gt; <span class="title">MakeToastWithButterAndJamAsync</span>(<span class="params"><span class="keyword">int</span> number</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> toast = <span class="keyword">await</span> ToastBreadAsync(number);      <span class="comment">//要处理面包得先等面包烤好</span></span><br><span class="line">    ApplyButter(toast);     <span class="comment">//涂点黄油</span></span><br><span class="line">    ApplyJam(toast);        <span class="comment">//涂点果酱</span></span><br><span class="line">    <span class="keyword">return</span> toast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，方法定义的前面有<code>async</code>修饰符，这直接说明了此方法是异步（<strong>async</strong>hronous）的。</p>
<p>异步方法返回的是<code>Task&lt;TResult&gt;</code>类型，代表着这个任务（Task）的结果是<code>TResult</code>所代表的类型。比如一个返回类型为<code>Toast</code>的同步方法，其异步版本的返回类型就应该是<code>Task&lt;Toast&gt;</code>，代表着一个“烤面包（Toast）”的任务（Task）。</p>
<p><strong><code>async</code>异步方法的存在，要依靠包含<code>await</code>运算符的表达式或语句。反过来说，异步方法里必须得有<code>await</code>的存在。</strong> 上面的代码里，<code>Main</code>方法本身也是被<code>async</code>修饰的，就是因为Main方法里也用到了<code>await</code>语句。</p>
<h3 id="设置前置条件"><a href="#设置前置条件" class="headerlink" title="设置前置条件"></a>设置前置条件</h3><p><code>async</code>是用来定义异步方法的，那<code>await</code>是干什么的呢？按照字面意思来理解就好，“等待”。异步方法运行到这里就开始等待，直到<code>await</code>的操作数所表示的异步操作（一个<code>Task&lt;TResult&gt;</code>）执行完毕。<strong>一旦异步操作完成，<code>await</code>运算符就从<code>Task&lt;TResult&gt;</code>的任务里，获取任务的最终结果，以<code>TResult</code>类型返回，然后再继续运行后续代码。</strong> 这说明<code>await</code>所等待的任务的结果是后续操作的前置条件。上面这个异步方法第一句就在<code>await</code>，这是因为后面抹黄油和果酱的流程都必须建立在“烤完面包”的前置条件上。</p>
<p>然而，我们希望优化的耗时操作往往本身不是异步的。<code>await</code>只能接异步操作，怎么和非异步的耗时操作结合呢？比如说有这样一个“根正苗红”的同步函数：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">string</span> <span class="title">Foo</span>(<span class="params"><span class="keyword">int</span> bar</span>)</span>&#123;</span><br><span class="line">    Wtf();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要让它的执行完成作为前置条件，就得把它改造成一个返回<code>Task&lt;string&gt;</code>的函数。但是如果原函数是不允许修改的呢？依然有办法，只要用<code>Task.Run(() =&gt; Foo(bar))</code>来调用就好了。</p>
<p><code>Task.Run()</code>可以把以下四种委托包装成任务，其中常用的是前两种：</p>
<ol>
<li><code>Action</code></li>
<li><code>Func&lt;TResult&gt;</code></li>
<li><code>Func&lt;Task&gt;</code></li>
<li><code>Func&lt;Task&lt;TResult&gt;&gt;</code></li>
</ol>
<p>由于Lambda表达式也是委托，完全可以构造一个符合上述种类的Lambda表达式。<code>() =&gt; Foo(bar)</code>没有参数，返回类型为<code>string</code>，是一个受到支持的<code>Func&lt;string&gt;</code>委托。因此在被<code>Task.Run()</code>包装之后，它就能成为一个<code>Task&lt;string&gt;</code>，作为异步过程中的前置条件。</p>
<h3 id="使用连接符"><a href="#使用连接符" class="headerlink" title="使用连接符"></a>使用连接符</h3><p>再来看中间的这一段。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (allTasks.Any())</span><br><span class="line">&#123;</span><br><span class="line">    Task finished = <span class="keyword">await</span> Task.WhenAny(allTasks);</span><br><span class="line">    <span class="keyword">if</span> (finished == eggsTask)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"eggs are ready"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (finished == baconTask)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"bacon is ready"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (finished == toastTask)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"toast is ready"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    allTasks.Remove(finished);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>allTasks.Any()</code>使用<code>List&lt;T&gt;</code>的<code>Any()</code>方法检查列表里是否还有剩余的元素，即当还有未完成的任务时，令程序一直在此循环，这实际上类似于一个消息循环机制。</p>
<p><code>Task.WhenAny(allTasks)</code>有点儿特殊，它是一个<code>Task&lt;Task&gt;</code>，即“结果是任务”的任务——在<code>allTasks</code>里的某一个任务完成时，它把这个刚刚完成的任务作为自己的结果。这样，<code>await</code>运算符就提取出了那个刚刚完成的任务，将它赋给<code>finished</code>，接下来就可以作出相应的反应了。别忘了在任务处理完之后，把这个完成了的任务从任务列表里删去。</p>
<p>另有一个类似的方法是<code>Task.WhenAll()</code>，它所创建的任务在参数所表示的一系列任务都完成时才完成。命名空间<code>System.Threading.Tasks</code>里的这类辅助处理多个任务的方法被称为“连接符”。</p>
<p>以上就是一种基于任务的异步模式（TAP）：把多个任务一齐启动，记录在任务列表里，然后用<code>await</code>、循环和连接符来等待所有任务的完成。对于每个任务本身，如果具有一些前置条件，就依然用<code>await</code>来等待其前置条件的完成。</p>
<h1 id="扩展：线程池"><a href="#扩展：线程池" class="headerlink" title="扩展：线程池"></a>扩展：线程池</h1><p>至此，虽然我们知道了怎么把同步代码改造成异步的，但其中的原理是什么呢？</p>
<p>异步的关键是定义<code>async</code>异步方法和用<code>await</code>进行必要的流程控制，而这两个关键字都是围绕<code>Task&lt;TResult&gt;</code>展开的。因此要更深入地理解异步，就要了解<code>Task&lt;TResult&gt;</code>的工作机制。</p>
<p>Task工作的基础是线程池，C#中的线程池是命名空间<code>System.Threading</code>中的<code>ThreadPool</code>静态类。关于线程池和多线程又可以事无巨细地写一篇长文，这里先作简要的记录。</p>
<p>每一个进程都可以拥有一个线程池，里面有预先创建好的一大堆空闲线程。当一个任务需要用线程处理的时候，就无需临时单独创建一个线程，可以直接从线程池里找一个空闲的来跑。跑完也不用费劲将线程销毁，它会被线程池回收，等待其它任务来利用。假如要处理的任务太多，导致线程池里所有的线程都在忙碌，线程池可能会创建新线程，也可能让任务等待空闲线程的出现。</p>
<p>线程池也有缺点。由于池里线程的一切工作都是由CLR托管的（这又是一个天坑），虽然用起来是简单了，但你无法对这些线程进行具体的操作，一旦把任务加进队列里也没法取消（不要停下来啊！）。不过都要用上线程池了，那不是一把梭跑就完事了嘛，谁还希望让任务停下来呢？</p>
<p>使用线程池的方法是利用<code>QueueUserWorkItem()</code>方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadPool.QueueUserWorkItem 方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">QueueUserWorkItem</span> (<span class="params">System.Threading.WaitCallback callBack</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">QueueUserWorkItem</span> (<span class="params">System.Threading.WaitCallback callBack, <span class="keyword">object</span> state</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这个方法把一项工作添加到线程池的工作队列中，一旦线程池有空闲线程，就会从队列里取出工作来执行。</p>
<p>其中，<code>WaitCallback</code>是一个委托，它接收<code>object</code>作为参数，并返回<code>void</code>，类似<code>Action&lt;object&gt;</code>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">System.Runtime.InteropServices.ComVisible(true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">WaitCallback</span>(<span class="params"><span class="keyword">object</span> state</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>注意，由于委托参数的<a href="https://hakurei.red/2020/03/02/C-%E6%9D%82%E8%AE%B0%E4%B9%8B%E8%B4%B0/">逆变性</a>（我靠，居然在这里用上了前面学的逆变），这里仅能使用<code>object</code>或派生程度更低的类型的参数。由于<code>object</code>已经是最终基类，故只能用它。</p>
<p>但<code>object</code>可是啥都没有啊？如果要安排一个带有任务信息的委托作为任务，怎么把信息封在里面？</p>
<p>为了解答这个问题，我们可以先看<code>QueueUserWorkItem</code>的后一个重载。参数除了<code>WaitCallback</code>类型的委托<code>callBack</code>之外，还有一个<code>object state</code>，它就是委托调用时使用的参数。由于协变性，你可以把任何类型视作<code>object</code>，也就可以在调用委托时传入任意类型的参数。而前一个重载的参数列表中没有<code>object state</code>，是给无需在调用时传入参数的委托使用的，类似<code>Action</code>。</p>
<p><strong>如此一来就很明白了，支持添加到线程池工作队列里的工作是这样的函数：返回类型为<code>void</code>，参数列表中有0或1个任意类型的参数。</strong></p>
<h1 id="未竟之旅"><a href="#未竟之旅" class="headerlink" title="未竟之旅"></a>未竟之旅</h1><p>原本这里应该有更多关于Task和await工作原理的内容，但当我在C#文档的迷宫中走得愈发深入时，我发现我的理解被不断推翻，比如说用async和await实现的异步实际上是单线程的，但它们所围绕的Task又和用线程池实现的多线程密不可分。</p>
<p>我试图理清这一切到底是如何工作的，这时回调函数、消息循环、线程调度、编译原理这几只怪物都跑了出来，甚至将一切都指向了JavaScript，告诉我是时候敬而远之了。</p>
<p>因此，目前这篇笔记是十分没有深度的一篇，它有太多可以写也需要写的内容了。C#我还有更多的东西一知半解，目前在此考据技术细节是不明智的。但过段时间我还会继续刨根究底，现在将非常具有参考价值的一篇StackOverflow问题链接贴在这里：</p>
<p><a href="https://stackoverflow.com/questions/37419572/if-async-await-doesnt-create-any-additional-threads-then-how-does-it-make-appl" target="_blank" rel="noopener">If async-await doesn’t create any additional threads, then how does it make applications responsive?</a></p>
<p>以及之前我画的<strong>理解错误</strong>的示意图：</p>
<p><img src="https://i.loli.net/2020/04/08/7TIPufG6oAm2cOd.png" alt="BreakfastAsync.png"></p>
<blockquote>
<p>下一步，应该是回过头去搞清楚集合、列表、数组，还有相关的接口和索引器啥的。</p>
</blockquote>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>CSharp</tag>
      </tags>
  </entry>
  <entry>
    <title>200404：清明追思</title>
    <url>/2020/04/04/200404/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>到了清明节，很奇怪的，今年并没有下雨。印象中每年的清明正应那句“清明时节雨纷纷”，这几天就该是细雨连绵，气温恰好舒适得让人头脑清晰。气象数据统计上也反映了这一点。杏花村所在的安徽池州，历年来清明前后的降雨概率高达85%。湖北离得不远，这印象是有基础的。</p>
<p>下不下雨倒是无关紧要，今天有其更大的意义。</p>
<blockquote>
<p>新华社北京4月3日电 为表达全国各族人民对抗击新冠肺炎疫情斗争牺牲烈士和逝世同胞的深切哀悼，国务院今天发布公告，决定2020年4月4日举行全国性哀悼活动。在此期间，全国和驻外使领馆下半旗志哀，全国停止公共娱乐活动。4月4日10时起，全国人民默哀3分钟，汽车、火车、舰船鸣笛，防空警报鸣响。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/04/04/LS6WIcNkAsH4VeJ.jpg" alt="清明追思"></p>
<a id="more"></a>

<p>“躲进小楼成一统”的这两个多月，我的情绪依然常常通过社交平台与外界牵连着，随着疫情通报和人间冷暖而波动。从武汉F4的操作秀到“全境封锁”再到李文亮医生的逝世，整个中国天翻地覆。但那之后似乎一切都终于走上正轨，那两天很是发了一番牢骚之后，我也就不再那么关注了。记得中途的某一天，我爸问我：你们计算机专业可以为抗击疫情做什么呢？是啊，我做得了什么呢？</p>
<p>我做不了什么。我不是阿里P7，也没发过顶会Paper，与医学的关联也仅仅是去年帮同济医学院搬过几次砖——贡献大的总只可能是攀登到顶峰上的数人。我能做到的最好的事，也就是“配合”：老实一点，不要给别人添麻烦。</p>
<p>所以九点五十九分，我放下“钓到彩蛋了！用来做什么好呢……？”的手柄，走上阳台等待警笛。十点整，汽车的汽笛随着防空警报一起响起。我沉默着望向窗外，世界静止在此刻，秒针转得飞快。后来令我想痛骂自己的是，默哀时我没有多么悲伤——相对于2009年5月12日的自己来说。</p>
<p>那是中国的第一个“防灾减灾日”。届时我小学尚未毕业，没有如今学来的阴阳怪气的“理客中”，看什么都很朴素，像是如今不少人追寻的“痛则大哭，喜则大笑”的境界。教室里我低着头，却又将眼睛略微睁开一点，模糊的视野里只能看到红漆斑驳的木制旧书桌。手中攥着稍微漏墨的英雄钢笔，2008年的种种往事涌上心头：联众游戏大厅，鲜虾鱼板面，纸飞机，绿蓝带，滑板车……手机中未能送达的短信，独臂少年喝到的冰可乐，粉笔写下的“多难兴邦”。</p>
<p>光荣与受难并存，我写在2008的末尾。</p>
<blockquote>
<p><strong>别了，2008</strong></p>
<p>在这2008年的最后一天的深夜，我正坐在电脑前向即将过去的2008年，以我的文字告别。2008年，这真是一个难以告别的年份啊。    </p>
<p>在这2008年，我们经历了太多，太多……在开年时,我们就受到了重重一击:中国受到了百年难遇的大雪灾,可在雪灾之中,却有众多好心人来帮助那些受灾的群众，使这原本寒冷的雪灾变得温暖起来。 </p>
<p>而在接下来的5月里，中国历史上最大的地震：5.12汶川大地震降临了。在天地动摇中，我们却看到了温暖的一幕：消防队员们尽力地援救受难的人们。     </p>
<p>接着就好了，奥运会开幕了，我们的运动员为我国夺得了100枚金牌，这是我们中国人的骄傲。 </p>
<p>重大的事件发生了：三鹿“毒奶粉”事件。我国竟然多家乳业公司的奶粉都含有三聚氰胺，里面竟然还有伊利和蒙牛、光明，这三家公司一直都是人们信任的品牌，却被查出了有三聚氰胺，令人为之汗颜。   </p>
<p>接着，是神舟七号飞天。神舟七号的飞行员首次出舱活动，这是中国人的光荣。    </p>
<p>然后，就是现在，我在电脑前，向这难舍的2008告别。  </p>
<p>别了，2008……</p>
</blockquote>
<p>在这样的日子里，我出了一趟门。</p>
<p>出门是在昨天。封城以来，除了偶有几次的取快递，我基本没有离开过这个“Cell”。种种迹象表明，我在自我封闭——更简单地说，就是自闭。到了近日，我也不知道连“绿码”都不用扫了，戴上口罩就可以在这个曾经最严重的疫区之一随意穿行。</p>
<p>这样下来，我持续地沉溺在递归里，乃至每周都要逛三次Google Earth，每天都要有三回从窗台飞身而出的欲望。但当今天得知现在甚至还能乘上火车自由地前往全国各地时，我心里的世界地图又一瞬间缩小到了这一方居民楼。虽然不准确，但就像柏拉图的地穴寓言，从地穴里出来的囚犯想要直视太阳还需要好几个阶段的过渡。</p>
<p><img src="https://i.loli.net/2020/04/04/y4Kbm9ZWDV8Fxd2.jpg" alt="壕塘西巷"></p>
<p>熟悉的街巷虽然还稍显冷清，但还是旧时风味。灰头土脸的老建筑和郁郁葱葱的行道树屹立在大地上，骄傲地宣示着这座十八线小城绝不枯竭的生命力。</p>
<blockquote>
<p>庚子清明。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>C#杂记之叁：LINQ</title>
    <url>/2020/03/27/C-%E6%9D%82%E8%AE%B0%E4%B9%8B%E5%8F%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>准备完了开题答辩，弄完了笔试，又咸鱼了数天、玩了数天《动物森友会》，一下子离上一篇C#杂记过了三个星期。</p>
<p><img src="https://i.loli.net/2020/03/27/CPuc8SVgWGXTkEA.jpg" alt="朔月"></p>
<p>所以接下来要填的坑是LINQ和异步。弄完了这个，C#最大的几块拼图才得以完整，大抵能够叫是入了门。</p>
<h1 id="查询表达式"><a href="#查询表达式" class="headerlink" title="查询表达式"></a>查询表达式</h1><p>所谓的LINQ，是语言集成查询<strong>L</strong>anguage <strong>IN</strong>tegrated <strong>Q</strong>uery的缩写。通过引用命名空间<code>System.Linq</code>，可以用可读性极强的、类似SQL查询语句形式的代码对一些数据结构，甚至直接对数据库进行便捷的操作，如查询、排序、分组等，而不必编写大量逻辑复杂的循环代码。<!--尤其是在与异步流式处理相结合时，可以优雅地将C#的性能发挥到极致。(存疑)-->LINQ的操作十分高深，这里我仅学习一些基础、常用的LINQ功能。</p>
<p>以下是一个典型的LINQ查询示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//数据源</span></span><br><span class="line">    <span class="keyword">string</span>[] name = &#123;<span class="string">"Alonso"</span>, <span class="string">"Zheng"</span>, <span class="string">"Smith"</span>, <span class="string">"Jones"</span>, <span class="string">"Smythe"</span>, <span class="string">"Small"</span>, <span class="string">"Ruiz"</span>, <span class="string">"Hsieh"</span>, <span class="string">"Jorgenson"</span>, <span class="string">"Ilyich"</span>, <span class="string">"Singh"</span>, <span class="string">"Samba"</span>, <span class="string">"Fatimah"</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询表达式</span></span><br><span class="line">    <span class="keyword">var</span> queryResults = </span><br><span class="line">        <span class="keyword">from</span> n <span class="keyword">in</span> names</span><br><span class="line">        <span class="keyword">where</span> n.StartWith(<span class="string">"S"</span>)</span><br><span class="line">        <span class="keyword">select</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代查询结果</span></span><br><span class="line">    WriteLine(<span class="string">"Name beginning with S:"</span>);</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> queryResults)&#123;</span><br><span class="line">        WriteLine(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Write(<span class="string">"Program finished. Press Enter/Return to continue:"</span>);</span><br><span class="line">    ReadLine();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>这段代码查询字符串数组<code>name</code>中以<code>S</code>开头的元素，收入<code>queryResults</code>中，并将它们输出。其中类似SQL语句，包含“from…in…where…select”的部分被称为“查询表达式”。</p>
<p><code>from...in...</code>子句指定了要查询的数据，这里例子中是数组<code>names</code>中的每一个元素<code>n</code>。数据是指数据源中的元素，而LINQ支持的数据源必须支持<code>IEnumerable&lt;T&gt;</code>接口，这是C#中所有的数据、集合都支持的。</p>
<p><code>where</code>子句不是必需的，它用表达式（<strong>也包括Lambda表达式</strong>）作为查询条件，针对每个<code>n</code>，查询条件能返回一个bool值，以此限定查询结果的范围。</p>
<p><code>select</code>子句指定查询结果集中包含怎样的元素。对于这个例子，<code>select</code>子句是其最简单的形式，即直接包含元素<code>n</code>本身。更复杂的情况，比如可以用<code>n.Length</code>来采集字符串的长度。</p>
<p>采集到的查询结果与数据源一样是实现了<code>IEnumerable&lt;T&gt;</code>的集合，用<code>foreach</code>语句就可以进行迭代。当然，也可以用<code>IEnumerable&lt;T&gt;</code>接口的<code>ToList&lt;T&gt;</code>方法将其创建成列表再做进一步处理。</p>
<p>实际上，直到访问查询结果之前，LINQ查询都并没有真的进行。查询结果变量只是保存了“执行查询的计划”，这被叫做查询的“延迟执行”。</p>
<p>除了上述的构造查询表达式之外，还可以用LINQ支持的一系列扩展方法实现类似的功能。比如在<a href="https://hakurei.red/2020/02/27/C-%E6%9D%82%E8%AE%B0%E4%B9%8B%E5%A3%B9/">C#杂记之壹：委托与事件</a>里我曾写到的，当引用<code>System.Linq</code>命名空间后，<code>IEnumerable&lt;T&gt;</code>接口中就会多出一些扩展方法，比如其中的<code>Where()</code>方法，它接受一个<code>Func&lt;TSource, bool&gt;</code>委托作为参数，用于筛选数据源中的元素，类似于查询表达式中的查询条件。这行代码里，用到两个Lambda表达式作为委托：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> queryResults = numList.Where(i =&gt; i &lt; <span class="number">5</span>).Select(i =&gt; i * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的方法语法等同于以下的查询表达式：</span></span><br><span class="line"><span class="keyword">var</span> queryResults = </span><br><span class="line">    <span class="keyword">from</span> i <span class="keyword">in</span> numList</span><br><span class="line">    <span class="keyword">where</span> i &lt; <span class="number">5</span></span><br><span class="line">    <span class="keyword">select</span> i * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>在查询表达式中使用<code>orderby</code>子句，可以对查询结果进行排序。该子句默认按照排序依据升序，如果在子句末尾使用<code>descending</code>关键字就可改为降序。下面的例子里，<code>orderby</code>子句依据字符串元素的最后一个字符，对查询结果进行降序排序：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> queryResults = </span><br><span class="line">    <span class="keyword">from</span> n <span class="keyword">in</span> names</span><br><span class="line">    <span class="keyword">where</span> n.StartWith(<span class="string">"S"</span>)</span><br><span class="line">    <span class="keyword">orderby</span> n.Substring(n.length<span class="number">-1</span>) <span class="keyword">descending</span></span><br><span class="line">    <span class="keyword">select</span> n ;</span><br></pre></td></tr></table></figure>

<p>至于多级排序，形式也十分简单：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三级排序，最后是构造匿名类型，迭代访问时用var即可</span></span><br><span class="line"><span class="keyword">var</span> queryResults = </span><br><span class="line">    <span class="keyword">from</span> c <span class="keyword">in</span> cunstomers</span><br><span class="line">    <span class="keyword">orderby</span> c.Region, c.Country <span class="keyword">descending</span>, c.City</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span> &#123;c.ID, c.Region, c.Country, c.City&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h1><p>有时我们并不关注每一条查询结果的细节，所要的只是关于查询结果的一个统计值，这就是所谓的聚合运算。既然学过SQL，这几个基本聚合运算符也是“老朋友”了：</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Count()</td>
<td align="left">结果的个数</td>
</tr>
<tr>
<td align="left">Min()</td>
<td align="left">结果中的最小值</td>
</tr>
<tr>
<td align="left">Max()</td>
<td align="left">结果中的最大值</td>
</tr>
<tr>
<td align="left">Average()</td>
<td align="left">数字结果的平均值</td>
</tr>
<tr>
<td align="left">Sum()</td>
<td align="left">数字结果的总和</td>
</tr>
<tr>
<td align="left">Distinct()</td>
<td align="left">结果去重（其实不是聚合）</td>
</tr>
</tbody></table>
<p><strong>不过，LINQ与SQL仍有所不同，聚合运算符不是像SQL里一样写在select子句里，而是结果集所支持的方法。</strong></p>
<p>SQL的形式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>

<p>LINQ的形式，聚合运算时可以可选地传入委托作为元素的转换函数，然后对转换后的结果进行聚合：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">WriteLine(queryReusults.Max(i =&gt; i * <span class="number">5</span> + <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<h1 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h1><p>LINQ的分组查询类似于SQL的<code>GROUP BY</code>，配合聚合函数使用得到分组聚合值，用<code>group...by...into...</code>子句实现。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> queryResults = </span><br><span class="line">    <span class="keyword">from</span> c <span class="keyword">in</span> customers</span><br><span class="line">    <span class="keyword">group</span> c <span class="keyword">by</span> c.Region <span class="keyword">into</span> cg</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span> &#123; TotalSales = cg.Sum(c =&gt; c.sales), Region = cg.Key &#125;;</span><br></pre></td></tr></table></figure>

<p>上面这个例子，首先用group by into对数据源<code>customers</code>进行分组，得到新的结果集<code>cg</code>。通过分组查询得到的这个临时结果集实现了<code>IGrouping</code>接口，它包含<code>Key</code>属性，表示分组所依据的值，也就是<code>by</code>后面所接的表达式（本例中是表示客户地区的<code>c.Region</code>）之值。</p>
<p>最后的<code>select</code>子句依然是构造匿名类型，这在需要投影多个属性时是很有用的。</p>
<h1 id="join查询"><a href="#join查询" class="headerlink" title="join查询"></a>join查询</h1><p>和SQL中一样，join查询是用在需要用另外的数据源作为参考来进行查询，或者需要从多个数据源中汇集信息时的。SQL中实现多表查询至少有两种方法，一是使用JOIN，二是引用多个表然后把连接条件写在where子句中。但由于LINQ的<code>from...in...</code>子句只能引用一个数据源，所以第二种方案是行不通的，需要使用<code>join...in...on...</code>子句来实现。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> queryResults = </span><br><span class="line">    <span class="keyword">from</span> c <span class="keyword">in</span> customers</span><br><span class="line">    <span class="keyword">join</span> o <span class="keyword">in</span> orders <span class="keyword">on</span> c.ID <span class="keyword">equals</span> o.ID</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span> &#123; </span><br><span class="line">        c.ID, </span><br><span class="line">        c.City, </span><br><span class="line">        SalesBefore = c.Sales, </span><br><span class="line">        NewOrder = o.Amount, </span><br><span class="line">        SalesAfter = c.Sales + o.Amount</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>上面的例子是一个简单的内连接（Inner Join），其实<a href="https://www.c-sharpcorner.com/UploadFile/ff2f08/sql-join-in-linq-linq-to-entity-linq-to-sql/" target="_blank" rel="noopener">LINQ也能实现外连接</a>，只是不算那么优雅（而且好像也没多大卯月）。</p>
<h1 id="交并差"><a href="#交并差" class="headerlink" title="交并差"></a>交并差</h1><p>这是LINQ为IEnumerable带来的非常贴心的功能，仅三个简单的扩展方法。</p>
<p>取并集：Union()</p>
<p>取交集：Intersect()</p>
<p>取差集：Except()</p>
<p>不过，由于数学上的“集合”是无重复的，上面的Union()方法返回的也是去重的结果。如果想保留重复的结果，可以使用Concat()。</p>
<p>这几个方法返回的类型都是IEnumerable，需要在调用之后再使用ToList()或者ToArray()之类的方法。</p>
<p>你甚至可以用这玩意一行代码秒掉<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">LeetCode 349 两个数组的交集</a>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="title">Intersection</span>(<span class="params"><span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums1.Intersect(nums2).ToArray();        <span class="comment">//LINQ完事，别想算法了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基础形式：<strong>from…in…where…select…</strong></p>
<p>其中：</p>
<p>from…in…指定数据源是什么；</p>
<p>可选的where指定按照什么条件筛选；</p>
<p>select指定要获取怎样的结果；</p>
<p>排序：orderby… (descending)</p>
<p>聚合：Count(), Max(), Min(), Average(), Sum(), Distinct()</p>
<p>分组：group…by…into…</p>
<p>join：join…in…on…</p>
<blockquote>
<p>明天真该async await了！（动森真好玩）</p>
</blockquote>
<p><img src="https://i.loli.net/2020/03/27/OCPcmBo3hr4zkt5.jpg" alt="博物馆庆典"></p>
]]></content>
      <tags>
        <tag>C Sharp</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>试分析苇名弦一郎的BOSS设计</title>
    <url>/2020/03/16/%E8%AF%95%E5%88%86%E6%9E%90%E8%8B%87%E5%90%8D%E5%BC%A6%E4%B8%80%E9%83%8E%E7%9A%84BOSS%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对BOSS战的分析，可以从战斗机制的设计和对玩家能力的考验两个方向进行。</p>
<h1 id="战斗机制"><a href="#战斗机制" class="headerlink" title="战斗机制"></a>战斗机制</h1><p>何谓战斗机制？</p>
<p>“机制”这个词实在太宽泛。几个月前我曾在<a href="https://hakurei.red/2019/11/20/%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A3%B9/">这篇笔记</a>里总结过一次。</p>
<p>根据MDA框架，机制是“数据层面上的组件与算法”；形式、戏剧和动态元素框架中，“机制”基本等同于“形式”元素，即交互模式、目标、规则、过程、资源、边界、结局等等。四元法有一元是机制，指的是“玩家与游戏互动的规则”，也是游戏与其他非互动性媒体的区别所在。</p>
<p>不过，我们仍然可以把“机制”换个词，用“规则”来代替。更进一步的，战斗机制即是指，在战斗时，玩家能做什么？</p>
<p>那么《只狼》的战斗中，玩家能做什么？</p>
<p>最大的特色就是“打铁”，即弹反与架势槽。这个机制把传统动作游戏里高难度、高回报、低频率的“弹反”完全逆转成为难度相对偏低、回报不算明显，但使用频率极高的一种主要操作。《只狼》的战斗目标不再是单纯的削血，而主要是以进攻和弹反使敌人的架势槽涨满，此时即可一击必杀（忍杀）。同时架势槽的自然回落速度随剩余血量的减少而变慢，架势槽和血槽成为了相辅相成的两个机制。</p>
<p>第二点是处理敌人的“危”攻击。敌人偶尔发动无法格挡的技能，玩家头顶会浮现出红色的“危”字，这时就需要玩家根据敌人的起手动作，紧急判断下一步的应对措施。所谓的“危”其实也蕴含着“机”，如果处理得当，可以对敌方架势槽造成较大的上升。</p>
<p>主要的“危”攻击有两种类别，一是突刺，无法格挡，可以精准弹反，但正确的处理是在突刺的瞬间向敌人脸上垫步发动“识破”，造成较大的架势条上涨；二是横扫，最佳的处理方法是跳到敌人头上踩踏，亦可以造成较大的架势条上涨。一些BOSS战中能用“雷电奉还”反弹雷电攻击，而少数敌人能使出的擒抱攻击只能靠闪避处理。</p>
<a id="more"></a>

<h1 id="玩家能力"><a href="#玩家能力" class="headerlink" title="玩家能力"></a>玩家能力</h1><p>何谓玩家能力？</p>
<p>这里我找到两种说法。</p>
<p>第一种说法：</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/60192653" target="_blank" rel="noopener">五石. 设计方法论001-确定游戏类型与玩家能力</a>： </p>
<p>这个时候我们会引入一个东西叫做玩家能力（也叫玩家技巧）。我们会设立几个维度，如策略/操作/游戏知识等，然后在这个品类下为我们要考察的玩家能力划分等级。依然举例子来说明：    </p>
<ul>
<li>黑魂系列：大量的操作和游戏知识技巧，极少的策略技巧。    </li>
<li>文明系列：大量的策略，中等的游戏知识，少量的操作。  </li>
<li>刀塔自走棋：中等的策略，中等的游戏知识，少量的操作。    </li>
<li>守望先锋：中等的策略，少量的游戏知识，大量的操作。  </li>
</ul>
</blockquote>
<p>策略指的是较长期的规划，操作指的是短期的反应能力，游戏知识则是对游戏机制的全面了解。既然是动作游戏，策略显然是不怎么需要考虑的，主要考验的就是操作和游戏知识。</p>
<p>第二种说法：</p>
<blockquote>
<p><a href="https://www.gameres.com/459042.html" target="_blank" rel="noopener">小篱. 让新手成为核心玩家——从玩家能力分析开始</a>：</p>
<p>玩家的能力大致可以归纳为两大类八小类：</p>
<p>第一大类，集中力和肌肉的协调能力</p>
<ul>
<li>时机：考验玩家是否在正确的时间按键。比如跳舞类游戏，音乐游戏，对打游戏中出连招的时机，或者掐着时间跳平台。  </li>
<li>估量：考验玩家是否估量准确通过挑战的幅度。比如赛车类游戏，玩家在拐弯时要把握好转弯的速度和幅度。    </li>
<li>精确：考验玩家是否在一个精确的位置输入操作。比如射击类游戏，玩家需要精确的瞄准敌人。    </li>
<li>反应：考验玩家对于一个不能预测的突发情况是否在正确的时刻输入操作。比如对打游戏，街头霸王的玩家需要很快的躲避，挡格。赛车游戏中高速行驶的车需要躲开迎面而来的车辆或者障碍。    </li>
</ul>
<p>第二大类，分析力、逻辑思维和记忆力</p>
<ul>
<li>战术：分析当前观察到的信息很快的做出决定，这个决定具有短期影响。比如反恐精英CS中，玩家需要根据对方的攻击重点，来调整自己队伍的攻防重点。比如RPG回合制游戏中，玩家需要分析怪物的血量，技能，抗性，判断出怪物的弱点，安排好自己的技能顺序。     </li>
<li>策略：分析当前观察到的信息用了很长时间做出决定，这个决定具有长期影响。比如WOW中，玩家有很多天赋树的选择，不同的天赋的选择往往会导致玩家的攻击或者治疗效果的不一样。比如足球游戏中，玩家对于阵形和球员的调整。     </li>
<li>管理：分配自己有限的资源。比如生化危机中玩家只有固定的少量的背包空格，需要安排好弹药和补给的数量。比如管理游戏，铁路大亨，虚拟人生。      </li>
<li>机智：收集信息和线索去解决问题。比如古墓丽影中玩家需要思考机关的破解方式，生化危机中玩家需要收集很多道具去打开一个机关，比如手机上的很多益智游戏。        </li>
</ul>
</blockquote>
<p>第二种解释较为详细，更加适合用来分析。第一大类基本可以归为“操作”，第二大类中，除了“策略”之外的的战术、管理、机智则可以归为“游戏知识”。</p>
<h1 id="为什么是弦一郎？"><a href="#为什么是弦一郎？" class="headerlink" title="为什么是弦一郎？"></a>为什么是弦一郎？</h1><p>这是因为我至今还没彻底通关《只狼》，而是停留在了源之宫，甚至还没有找樱龙“拜泪”，更别说剑圣苇名一心了。这主要是我个人很不擅长源之宫这种低矮却错综复杂，可能还有很多水的地图，打平家宅邸以及魂3的法兰要塞都让我花了很长时间。</p>
<p>不主要说义父，则是因为他的设计简直是为了恶心玩家。</p>
<p>首先出手极狠，完美弹刀也要涨可观的架势条。打起来让人畏手畏脚，莽也不是守也不是，比起一般的敌人找到打铁节奏就能有惊无险地通过，面对义父就算是“太鼓达人”不时也要退避三舍恢复元气。</p>
<p>第二是禁药。虽然触发范围不算大，奈何义父总是在拼刀正酣之际贴脸来上一下，即使是较为熟练的玩家也不免中招。一旦中了禁药，极长的持续时间会相应地给玩家造成极大的心理压力，甚至此时义父的进攻还会变得更为积极，在狂风暴雨的攻势下玩家的操作很容易出现误差，就此落命。</p>
<p>第三是撒毒。不大的天守阁场地里有时甚至能散布四片毒区，占去约1/3的场地，大大缩小玩家的生存空间，这下不只是攻与守的抉择，连位移都要慎重考量了。</p>
<p>第四是烟雾弹。烟雾弹的存在也是为了打断节奏，在跳出烟雾重新定位的时候，义父的架势条已经回落了一大截，前面几十秒的苦心拼刀可能就付诸东流。</p>
<p>且不论什么正义的鞭炮，不得不说，巨型忍者枭这个BOSS确实诠释了“忍者”的身份，道具花样百出，招招阴险毒辣。但这些设计堆叠起来——它实在是太令人痛苦了。</p>
<p>而苇名弦一郎，作为《只狼》前期最为重要的BOSS，与他堂堂正正的对决可以说是整部游戏的“期中测验”，值得用来分析。</p>
<h1 id="与弦一郎对决之前"><a href="#与弦一郎对决之前" class="headerlink" title="与弦一郎对决之前"></a>与弦一郎对决之前</h1><p>和弦一郎的战斗在《只狼》中出现了三次，一次是在游戏刚开始不久时，基本上属于“剧情杀”；第二次是作为前期转入中期的BOSS；第三次是作为游戏最终决战的引子。“起承转合”之中，弦一郎就占了起、转、合三点，不得不说是《只狼》里形象非常饱满、令人印象深刻，也极为重要的BOSS。</p>
<p>游戏进入主线时玩家来到破旧寺院，遥望远方见到的最显眼的目标就是苇名城天守阁，而玩家的第一个长期目标亦是登上天守阁，向弦一郎复仇。在去往天守阁的旅途中，玩家逐步掌握《只狼》的游戏机制，包括弹反、架势、“危”攻击的处理、义手忍具，乃至于在苇名流道场知道了“雷电奉还”。而抵达天守阁顶端时，与弦一郎的对决将前面的一切汇聚起来，是考验玩家对游戏机制理解的一次“期中考试”。</p>
<h1 id="弦一郎"><a href="#弦一郎" class="headerlink" title="弦一郎"></a>弦一郎</h1><p>《只狼》中面对敌人的攻击，处理方式除了一般的动作游戏中所具有的打断、闪避、格挡、弹反之外，还添加了识破、踩头、忍具等机制，并且具有相比以前的“魂”系列更短的反馈时间。机制宽度上的增加与反馈时间的缩短，很好的弥补了因没有复杂的装备系统在深度上带来的不足。在这样的游戏机制下，最能考验玩家对弹反的掌握程度的，也令我印象尤为深刻的，是弦一郎的标志性技能“飞渡浮舟”：先是常规的两刀，略停顿后接两次上挑，立刻跃起极快地乱砍四下，最后在较长的停顿后以转身强力上挑收尾。这一套下来总共9刀，时长仅4秒左右，处理得当的话可以造成约1/4的架势槽上涨，而处理不当玩家就会当场落命，可以说是攻略中的一个难点。虽然这里说起来很轻松，但实际上这一套连招往往出现在激烈的、包含大量变招的拼刀之中，光是记住弦一郎总共出刀几次都不是件易事。</p>
<p>另一个值得注意的是弦一郎的跳劈，劈砍结束后会产生小范围的烟尘，让玩家无法看清对方的动作。此时弦一郎会接突刺或者横扫的“危”攻击，玩家需要根据烟尘中一闪而过的刀光来判断到底是哪一种，是应该起跳，还是应该“识破”。</p>
<p>完美弹反飞渡浮舟的严苛判定和用烟尘营造的障眼法，考验的是玩家的反应力、观察力和对时机的掌控力。而为了达到用这些攻击手段考验玩家能力的目的，弦一郎的BOSS战也经过了一番设计。一方面是在战斗场地的设置上。前面玩家打过鬼庭形部雅孝的战场、蝴蝶夫人的佛堂、乃至“居合哥”佐濑甚助的道场，而天守阁的空间相较它们更小，也没有设置任何掩体。这无疑是让玩家没有盘旋的余地，不鼓励像《黑暗之魂》里一样摸几刀就远远躲开，把BOSS战玩成实质上的“回合制游戏”，而是要正面迎战。另一方面弦一郎自身也有很多远程攻击和拉近距离的技能，比如空中射箭四连、射箭后翻滚近身以及跳劈，几乎是不让玩家有喘息机会的。这些设计，完全是在引导玩家和弦一郎贴身近战，并且不得不处理那些麻烦的技能，这就是弦一郎前两个阶段的主旋律。</p>
<p>当玩家好不容易磨掉两条血，可能已经“弹尽粮绝”的时候，弦一郎却觉醒意外的力量，进入隐藏的第三阶段，成为“巴流 苇名弦一郎”。第三阶段很有意思，场景的环境由细雪和风骤变成快雪惊雷，这正是“巴之雷”力量的反映，立刻就让玩家回想起在苇名流道场所见的“雷电奉还”卷轴，提示了正确的应对措施。而真正施展出华丽的雷电奉还之后，产生的“打雷”麻痹效果以及极大的架势槽上涨，堪称是这场战斗中最令人爽快的一刻，使得第三阶段没有看上去的那么难，也构成了良好难度曲线的最后一环。良好的难度曲线，即是难度逐渐上升到顶峰，而后又逐渐降低的。</p>
<h1 id="纯粹"><a href="#纯粹" class="headerlink" title="纯粹"></a>纯粹</h1><p>其实《只狼》是一部过于纯粹的游戏，以至于我不知道该怎么光就一个BOSS的设计进行进一步分析。像那篇由国产游戏策划所写的著名差评里所表达的那样，这个游戏几乎只剩下了“节奏大师音乐游戏”……但这并不是《只狼》的缺点，反而可以说是一种“返璞归真”。作为动作游戏，它既不是《荣耀战魂》那样的过于硬核，也不是《鬼泣》那样的炫瞎狗眼：它纯粹、朴实、“大巧不工”，强化少量核心机制的地位。而能够做到这个的游戏，总是不会差的。</p>
]]></content>
      <tags>
        <tag>游戏</tag>
        <tag>游戏学</tag>
      </tags>
  </entry>
  <entry>
    <title>200305：写在开题答辩之前</title>
    <url>/2020/03/05/200305/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这一篇虽记于3月4日，但一看日历，明日惊蛰，四舍五入等我写完便也是依照惯例的特殊日随笔了，那就把时间改为明天的第一帧吧。</p>
<p>写这篇的主要目的是作毕业设计工作进度的报告，因为昨天接到10号便要开题答辩的通知，依照要求我应在两天之内联系导师汇报工作进度。回过神来已是晚上八点，再不总结一下就要来不及了。</p>
<h1 id="干了些什么？"><a href="#干了些什么？" class="headerlink" title="干了些什么？"></a>干了些什么？</h1><p>太长不看，上列表：</p>
<ul>
<li>决定转向游戏制作</li>
<li>学习C#和游戏学基础</li>
<li>学习Aseprite和Photoshop</li>
<li>TextMesh Pro和UGUI</li>
<li>DanmakU类库，弹幕的生成</li>
<li>Pixel Perfect效果</li>
<li>实现基本的游戏逻辑</li>
</ul>
<a id="more"></a>

<h2 id="决定转向游戏制作"><a href="#决定转向游戏制作" class="headerlink" title="决定转向游戏制作"></a>决定转向游戏制作</h2><p>从<a href="https://hakurei.red/2019/11/02/191102/">191102</a>起，我由于开始接触C#这门与大数据开发关系不太深的语言，更由于自己一直以来的一些爱好与愿望，决定转向游戏制作。</p>
<p>那时的计划是先系统性学习C#，然后逐步了解Unity引擎，尝试在实验室工作之外制作一个东方同人游戏，既贴合毕业所需，也可作为日后求职的材料。</p>
<h2 id="学习C-和游戏学基础"><a href="#学习C-和游戏学基础" class="headerlink" title="学习C#和游戏学基础"></a>学习C#和游戏学基础</h2><p>计划刚一开始，接下来的半个月就在实验室的忙碌中度过，常常是晚上回家还需要继续研究到深夜，系统性的学习就暂且推迟了。期间我也听从一些建议，购入了《C#入门经典》和《游戏设计、原型与开发》。这两本书的确值得一读，明晰的思路和通俗的语言往往能让我从文档的苦海中挣脱，也能纠正我许多先入为主的错误思想。</p>
<p>于是11月17日，在去向导师报到之前，我花了几天学习Unity官方发布的脚本开发视频教程，对C#这门语言的总体有了一定的认识。</p>
<p>既然在此之前学习过C++、Java和Python，按理说对面向对象程序设计已经轻车熟路，但C++和Java我实在是面向考试学习，所剩下来的只有那些马光志老师所曰“静态成员指针，析构过程，虚基类……”云云的诘屈聱牙，还有Eclipse那丑陋不堪、摇摇欲坠的界面。至于OOP的思想么，是一点也没学到，更没能掌握其全貌。</p>
<p>Python亦是门乱七八糟的语言，从GitHub上弄下来的代码十页里有两页能跑就该念安拉至大了。我仅仅是囫囵吞枣，了解到了一门编程语言的语法可以这么精简，性能也可以这么低下。切实的好处也是有的：我仰仗着Python胡写一气考完了CSP，而如果当时用的是C++，那分数恐怕得打对折。</p>
<p>C#则不同。也不知道是不是因为学习的是英文课程，老外讲这些东西尤其有天分，许多一团乱麻的地方变得直观了起来。除了C#的基础之外，还讲解了一些Unity的重要概念，这下我稍微有了一点信心，也产生了自己很快就能上手的“错觉”。</p>
<p>从导师那里回来之后，我要做的事只剩下了一件：基本完全独立的游戏开发。想到自己即将开始做和ZUN当年相同的事，不觉有些热血上涌。第一步当然是策划，不过既然只有我一个人，我当时认为可能没必要弄得这么“正式”。当然这是错误的，比如现在我就深受没有早些写策划案之害，需要从零开始与开题报告的Deadline斗争了。</p>
<p>不过我还是开始读那本《游戏设计、原型与开发》，看了些游戏分析框架与“涌现”概念、设计思路的内容。在这个过程中，我虽没有完整的策划案，总算是从零碎的思绪中揪出了个大致方向——庚子之灾。《東方珀露澗 ~ Aurora of Dragon Lore.》的名字就是在这时取的。</p>
<p>这段时间也是我2019年学习最为狂热的几天，博客完全是日更，以至于某位少女都为此表示了认可。</p>
<h2 id="学习Aseprite和Photoshop"><a href="#学习Aseprite和Photoshop" class="headerlink" title="学习Aseprite和Photoshop"></a>学习Aseprite和Photoshop</h2><p>十二月初，我意识到自己必须得做一些中等意思的美术工作。由于《东方月神夜》和《幻想乡萃夜祭》给我带来的极大冲击和传统美术风格的较高门槛，我选择尝试创作像素艺术风格的美术素材。</p>
<p>因此，开始接触专用于像素艺术的Aseprite和美工万能的Photoshop。Photoshop是被我用得不如PowerPoint，Aseprite倒是掌握了些。最初的像素作品显然是不忍直视，尽管花去了一整天：</p>
<p><img src="https://i.loli.net/2020/01/12/rWmnCw9V1uBeDH6.gif" alt="第一幅妖梦"></p>
<p>寒假回家之后，我又花了一段时间学习Aseprite的使用以及创作像素艺术的技巧，对于明暗和比例有了基本的概念。这是2月15日，作为测试用敌机而绘制的鬼人正邪，比起上面有了明显的进步：</p>
<p><img src="https://i.loli.net/2020/03/04/kd1UyB28NIfcCtl.png" alt="正邪"></p>
<p>之后，关注已久的国行Switch发布了，看完发布会失望的我当即去买了日版Switch，度过了一段没日没夜的日子——终于是成为了“高贵的主机玩家”。</p>
<h2 id="消失的两个月"><a href="#消失的两个月" class="headerlink" title="消失的两个月"></a>消失的两个月</h2><p>最初的开发工作进行后不久，综合能力培养课程设计就开始了，我也久违地参与到有一定复杂度和体量的工程中去。这段时间长达一个月，很忙，也很迷茫，有种“刚起跑就跌倒”的感觉。中途也仅仅是探求了Unity异步场景加载这一个问题。</p>
<p>不过十二月的某个下午，恭听了一位资深.NET巨佬对C#的演示讲解，许多之前没有深入接触的概念涌现出来——静态、异步、接口、转型、委托、事件、集合、LINQ……堪称“一日看尽长安花”。这些内容，我直到现在都在试着慢慢消化理解，最近一周写的C#杂记也正是为了这一点。</p>
<p>一月初，课设和大四上学期一起结束，其中留下的一些坑让我后来又进行了两次考据。放假之后，家里大小杂事，加上我好不容易有了前往海拉鲁大陆的机会，就此一直忙到快过年。</p>
<p>接下来的事大家都明白，一月底，新冠肺炎来了。瘟疫撞上新年，这下又有了可忙的事。一直到2月11日，我才时隔两个月再次打开Unity。</p>
<h2 id="TextMesh-Pro和UGUI"><a href="#TextMesh-Pro和UGUI" class="headerlink" title="TextMesh Pro和UGUI"></a>TextMesh Pro和UGUI</h2><p>接续开发进度的第一件事是完善之前只有背景图片的主菜单。</p>
<p>这里用到了Unity的UGUI工具集，主要是用Event控制的一系列GameObject：Canvas，Image，Button，Text等等。为了实现不同分辨率下的有层次的布局，又接触了多摄像机和锚点等UI设计的知识。</p>
<p>为了更加接近东方正作主菜单的逻辑，完全用键盘控制菜单、实现按钮的动画和音效，中间也进行了许多折腾。</p>
<p>不得不吐槽的是UGUI中的Text组件，渲染效果十分感人：</p>
<p><img src="https://i.loli.net/2020/02/17/AgXQhHJ9CUlykEs.jpg" alt="模糊的Text"></p>
<p>公认的对策是“曲线救国”：先把字号调得巨大，再把缩放调得极小，强行让显示效果变得清晰。这里我得将缩放调整为0.2，字号调到159才有了较为锐利的效果：</p>
<p><img src="https://i.loli.net/2020/02/17/5hdfeoBDHNJvjUI.jpg" alt="曲线救国"></p>
<p>为此，完美的解决方案是使用TextMesh Pro，其实Unity已经收编了这个第三方工具，放在了新版本Unity的Package Manager里。</p>
<p>这个基本成型的主界面虽简陋得很，背景也是<a href="https://www.pixiv.net/artworks/42856952" target="_blank" rel="noopener">从Pixiv上拉来的</a>，但勉强能用，看得过去。</p>
<p><img src="https://i.loli.net/2020/03/04/kjJHdAK6FUepgv7.jpg" alt="主菜单"></p>
<p>即使是320*240的极低分辨率，也能较好（？）地显示。</p>
<p><img src="https://i.loli.net/2020/03/04/a9u57DCd2oLTxAV.jpg" alt="低分辨率主菜单"></p>
<p>读取文档界面：</p>
<p><img src="https://i.loli.net/2020/03/04/UeLpRQ9yuvdW4YT.jpg" alt="文档界面"></p>
<h2 id="DanmakU类库，弹幕的生成"><a href="#DanmakU类库，弹幕的生成" class="headerlink" title="DanmakU类库，弹幕的生成"></a>DanmakU类库，弹幕的生成</h2><p>（糟，要写不完了，省着点，详细的还是报告里补充吧）</p>
<p>制作弹幕是既困难又简单的部分，这个部分的设计在后面的工作中可能会花去我的主要时间。纯粹的的“Bullet Hell”实现起来可能相对简单，而要制作包含一定意蕴的“符卡”，其复杂度就需要为之慎重考量了。</p>
<p>以前玩过用东方弹幕风和LuaSTG制作的弹幕射击游戏，Unity引擎里有没有能辅助制作弹幕的工具呢？无论如何，至少在Unity上实现极复杂的符卡是可以的，SlimeSmile团队的作品就是很好的例子。</p>
<p>GitHub上一找还真的有，是Google的工程师开发的开源类库<a href="https://github.com/james7132/DanmakU" target="_blank" rel="noopener">DanmakU</a>，想来这个大写的U所代表的应当是Unity。这个库容量不大，开发时间跨度却已长达5年，还有着天坑遍地、语焉不详的要命文档，但它确实是个不错的选择——大不了我Fork过来自己改就是了。</p>
<p><img src="https://i.loli.net/2020/03/04/KnzCNdg9b5TVWZB.png" alt="DanmakU"></p>
<p>DanmakU的思想是重点处理那些占绝大部分的“fire and forget”的子弹，将1023个子弹一同进行GPU绘制请求，而不是将每个子弹视作独立的个体，同时使用尽量多的线程处理。这可以极大地降低垃圾回收的开销，保持CPU低占用，充分使用GPU加速。</p>
<p>以下是一个使用DanmakU绘制的，简单的单发射点弹幕示例：</p>
<p><img src="https://i.loli.net/2020/03/04/I1pSQHZWwL7FbEh.png" alt="DanmakU绘制弹幕"></p>
<h2 id="Pixel-Perfect效果"><a href="#Pixel-Perfect效果" class="headerlink" title="Pixel Perfect效果"></a>Pixel Perfect效果</h2><p>Unity起初是个面向3D游戏的引擎，对2D的支持也是近年来才逐步完善。对于像素游戏而言，如果希望做到尽善尽美，Unity就存在一些不足。可能出现的问题在这篇文章里有很好的分析：<a href="https://zhuanlan.zhihu.com/p/55367765" target="_blank" rel="noopener">制作传统风格像素游戏时的几个陷阱 - Aya Magician</a></p>
<p>其中较为重要的问题就是像素对齐。</p>
<p><img src="https://i.loli.net/2020/03/04/V9dc4qHm1AoKt6D.jpg" alt="像素对齐"></p>
<p>另外就是Unity中可能出现的像素大小不均，不知道是否有相应的专业术语：</p>
<p><img src="https://i.loli.net/2020/03/04/vYGFLB15dmbolKJ.jpg" alt="像素大小不均"></p>
<p>这些问题被Pixel Perfect Camera部分解决了。这是使用之后的效果，像素大小均匀统一，边缘非常清晰锐利，且完美对齐。</p>
<p><img src="https://i.loli.net/2020/03/04/mYIKiA8jLSJnlhv.jpg" alt="Pixel_Perfect_Camera.jpg"></p>
<p>但实际上，完全对齐的像素会降低游戏在观感上的帧率，移动过程中还会有锯齿感，不适合对帧率要求高的弹幕游戏，故我在游戏设置中提供了像素对齐的开关选项。</p>
<h2 id="实现基本的游戏逻辑"><a href="#实现基本的游戏逻辑" class="headerlink" title="实现基本的游戏逻辑"></a>实现基本的游戏逻辑</h2><p>这里主要涉及到的是用户操作和碰撞检测。</p>
<p>用户操作大体上无需赘述，但有一个细节是需要注意的：</p>
<p>对于斜方向的移动，如果只是简单地将水平速度和垂直速度叠加，会造成沿对角线1.414倍速的移动，导致不连续的操作手感，增大失误的可能性。因此，当检测到同时存在Horizontal和Vertical的输入时，应当将横纵速度均削减为0.707倍，这样对角线上的合速度就能与横纵方向上的速度保持一致。</p>
<p>Unity引擎的碰撞由Rigidbody（刚体）和Collider（碰撞体）引发，但DanmakU由于其原理上的特殊性，处理起来稍显麻烦。更要命的是，文档里涉及到碰撞处理的部分居然是一片空白！</p>
<p><img src="https://i.loli.net/2020/03/04/okdhyMnRmuNcFzw.png" alt="空白的DanmakU文档"></p>
<p>于是我只好在读了半天源码，并且在Visual Studio里调试之后，才初步明白碰撞检测和处理的方法。</p>
<h1 id="最后……“随笔”的部分"><a href="#最后……“随笔”的部分" class="headerlink" title="最后……“随笔”的部分"></a>最后……“随笔”的部分</h1><p>在写这篇文章前不久，接到了米哈游的策划笔试题。</p>
<p>原本想着我大概不能算是一个合格的开发，便打消了投开发岗的念头，且看到各公司关于策划的说明好像与我十分符合，竟“一时兴起”地改了改简历投了策划。学开发出身的策划——也许还是有其价值的吧？</p>
<p>看到题目的时候，我就惊了。虽不能透露，总之是在我的知识范围之外，也明白那些要求是实打实的有用。两周的期限，我还得先用一个星期准备开题答辩，真有点悬。</p>
<p>不过所谓“努力”，就是克服困难去做想做的事。无论旁人看来的结果如何，对于自己来说，只要为之付出过，就永远是成功的。</p>
<blockquote>
<p>庚子惊蛰。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Unity</tag>
        <tag>C Sharp</tag>
        <tag>随笔</tag>
        <tag>游戏</tag>
        <tag>东方Project</tag>
      </tags>
  </entry>
  <entry>
    <title>C#杂记之贰：协变与逆变</title>
    <url>/2020/03/02/C-%E6%9D%82%E8%AE%B0%E4%B9%8B%E8%B4%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>昨天费力把上一篇中的“事件”章节给写完了，弄明白的确实不少（发现弄不明白的更多了）。</p>
<p>由于沉迷《饥荒》，并且也因为有点抗拒没听说过的概念，这一篇鸽到了现在。今天还是开始看吧。</p>
<p><strong>协变</strong>（Covariance）和<strong>逆变</strong>（Contravariance）统称为变体（Variance）。</p>
<h1 id="协变"><a href="#协变" class="headerlink" title="协变"></a>协变</h1><p>协变是指，对派生程度更大的类型的支持。也就是说，对于某处要求的类型，传入它的派生类也是没关系的。这是很容易理解的，因为子类可以隐式地转换为基类。协变体现的即是面向对象程序设计思想中，所谓的“<strong>里氏替换原则</strong>”（Liskov Substitution Principle）：任何基类可以出现的地方，子类一定可以出现。</p>
<h1 id="逆变"><a href="#逆变" class="headerlink" title="逆变"></a>逆变</h1><h2 id="神秘的问题"><a href="#神秘的问题" class="headerlink" title="神秘的问题"></a>神秘的问题</h2><p>比较难以理解的是逆变。与协变相反，这是对派生程度更小的类型的支持。比如在要求<code>string</code>的地方支持使用<code>object</code>。什么地方会出现这种看似违反里氏替换原则的“危险”操作呢？</p>
<p>在翻阅了许多文档之后，我反而是在<a href="https://github.com/jkchao/typescript-book-chinese/blob/master/docs/tips/covarianceAndContravariance.md" target="_blank" rel="noopener">《深入理解 TypeScript》</a>中找到了较为明白的解释，下面我试着用C#的方式叙述一下。</p>
<p>假设<code>Greyhound</code> （灰狗）是 <code>Dog</code> （狗）的子类，而 <code>Dog</code> 则是 <code>Animal</code> （动物）的子类。由于子类型通常是可传递的，因此我们也称 <code>Greyhound</code> 是 <code>Animal</code> 的子类。这是显然的。</p>
<p>那么，一个问题出现了：</p>
<p><strong>如果我们有一个委托<code>Func&lt;Dog, Dog&gt;</code>，是不是真的只能分配那些接受<code>Dog</code>为参数，并返回<code>Dog</code>的方法呢？</strong></p>
<a id="more"></a>

<p>根据里氏替换原则，既然灰狗是狗的子类，似乎我们完全可以用灰狗来代替狗：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Dog类的DogBark()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dog <span class="title">DogBark</span>(<span class="params">Dog dog</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WriteLine(<span class="string">"A Dog:"</span> + dog.dogMessage);</span><br><span class="line">    <span class="keyword">return</span> dog;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Greyhound类的GreyhoundBark()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Greyhound <span class="title">GreyhoundBark</span>(<span class="params">Greyhound greyhound</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WriteLine(<span class="string">"A Greyhound: "</span> + greyhound.greyhoundMessage);</span><br><span class="line">    <span class="keyword">return</span> greyhound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Func&lt;Dog, Dog&gt; LetDogBark = <span class="keyword">new</span> Func&lt;Dog, Dog&gt;(dog.DogBark);</span><br><span class="line"></span><br><span class="line"><span class="comment">//CS0123: "GreyhoundBark"没有与委托"Func&lt;Dog,Dog&gt;"匹配的重载</span></span><br><span class="line">LetDogBark += greyhound.GreyhoundBark;</span><br></pre></td></tr></table></figure>

<p><code>Greyhound</code>不是可以完全代替<code>Dog</code>吗？这里怎么会报错呢？这是因为当调用委托时，可能传入一个虽然是狗但不是灰狗的对象作为参数，比如德国牧羊犬<code>GermanShepherd</code>。德国牧羊犬当然没法执行灰狗的<code>GreyhoundBark()</code>方法。虽然子类可以代替基类，但子类之间是不一定能兼容的，这就是在委托里出现的特殊情况。</p>
<p>解决的方法就是逆变，即委托所指定的参数类型为<code>Dog</code>时，只能分配参数类型为<code>Dog</code>或派生程度更小的<code>Animal</code>的方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在Greyhound类另定义GreyhoundBarkAlter()，以Animal为参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Greyhound <span class="title">GreyhoundBarkAlter</span>(<span class="params">Animal animal</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WriteLine(<span class="string">"A Greyhound: "</span> + animal.animalMessage);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//这回不报错了</span></span><br><span class="line">Func&lt;Dog, Dog&gt; LetDogBark = <span class="keyword">new</span> Func&lt;Animal, Greyhound&gt;(greyhound.GreyhoundBarkAlter);</span><br></pre></td></tr></table></figure>

<h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>现在，我们可以回答上面提出的问题了。对于<code>Dog=&gt;Dog</code>的委托，哪些方法是可以分配的呢？</p>
<p><strong>不仅可以将具有匹配签名的方法分配给委托（即Dog=&gt;Dog的方法）；</strong></p>
<p><strong>还可以根据协变，分配与委托类型指定的派生类型相比，返回派生程度更大的类型的方法（即Dog=&gt;Greyhound的方法）；</strong></p>
<p><strong>或根据逆变，接受具有派生程度更小的类型的参数的方法（即Animal=&gt;Dog的方法）。</strong></p>
<p>这个规则初看起来很怪，让人感觉其中会存在漏洞，比如一个对象协变逆变几次之后可不可能被当成一个八竿子打不着的类的对象？举个例子，除了上述的<code>Animal</code>、<code>Dog</code>、<code>Greyhound</code>之外，我们再引入一个继承自<code>Animal</code>的<code>Fish</code>类。这样，这几个类的继承树就是如此：</p>
<p><img src="https://i.loli.net/2020/03/03/osIJ72AYHXaKv6O.png" alt="继承树"></p>
<p>如果我想捣点乱，比如试图把一只<code>Dog</code>传进去，经过一些变体操作后将它伪装成一条<code>Fish</code>，传进某个委托的参数里，引发崩溃。是否可能实现这一邪恶计划呢？</p>
<p>假如现在有一个<code>Fish=&gt;Fish</code>的委托，是我们要下手的目标。根据委托参数的逆变性，我们只能传入<code>Animal</code>或<code>Fish</code>。那么，我们就先把<code>Dog</code>伪装成<code>Animal</code>。这好像很简单，只要用一个<code>Dog=&gt;Dog</code>的方法返回自己，再依照协变性将这个方法分配给<code>Dog=&gt;Animal</code>的委托就能做到，甚至直接<code>as Animal</code>都可以。</p>
<p>但当我写下上面这一段之后，我意识到了我认知上的错误。</p>
<blockquote>
<p>根据委托参数的逆变性，我们只能传入<code>Animal</code>或<code>Fish</code>。</p>
</blockquote>
<p>这是不对的。必须强调，逆变性并不是指我们能实现“给<code>Fish=&gt;Fish</code>类型的委托传入<code>Animal</code>类型参数”这样的“基类代替子类”的操作，<strong>而是指我们能把<code>Animal=&gt;Fish</code>的方法封装进<code>Fish=&gt;Fish</code>类型的委托变量。</strong> 在这里<code>Animal</code>是<code>Fish</code>的父类，看起来就像是违反了里氏替换原则。但实际上，这恰恰是里氏替换原则的体现：</p>
<p>当我们调用要求传入<code>Fish</code>的委托时，根据里氏替换原则，只能传入派生程度一致或更高的参数，比如<code>Fish</code>类自己的对象。而这个<code>Fish</code>类型的参数，相比起被封装在<code>Fish=&gt;Fish</code>委托里面的<code>Animal=&gt;Fish</code>方法所要求的<code>Animal</code>类型参数而言，其派生程度是更高的。换句话说，<strong>对于被封装的<code>Animal=&gt;Fish</code>方法，逆变恰恰使得<code>Fish</code>这个子类代替了<code>Animal</code>这个基类，这是符合里氏替换原则的！</strong></p>
<blockquote>
<p>另外还有一个概念是不变体（Invariance），这限定了只能使用原始指定的类型，无论是其基类还是子类还是别的类都不被接受。</p>
</blockquote>
<h1 id="自定义泛型委托中的变体"><a href="#自定义泛型委托中的变体" class="headerlink" title="自定义泛型委托中的变体"></a>自定义泛型委托中的变体</h1><p>上面说的支持变体的委托，是指<code>Func&lt;&gt;</code>和<code>Action&lt;&gt;</code>这两种C#预定义的泛型委托，它默认参数类型逆变，而返回类型协变。如果是自定义的泛型委托，则需要手动指定参数和返回类型的变体（不过很少会有需要自定义泛型委托的场景）。</p>
<p>我们用<code>out</code>和<code>in</code>泛型修饰符来进行指定，<code>out</code>代表支持协变，<code>in</code>代表支持逆变：</p>
<p>协变：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 支持协变的委托，out修饰符修饰的是返回类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">delegate</span> R DCovariant&lt;<span class="keyword">out</span> R&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符合委托签名的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Control <span class="title">SampleControl</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Control(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Button <span class="title">SampleButton</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Button(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;            </span><br><span class="line">    <span class="comment">// 将委托实例化</span></span><br><span class="line">    DCovariant&lt;Control&gt; dControl = SampleControl;</span><br><span class="line">    DCovariant&lt;Button&gt; dButton = SampleButton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dButton可以赋给dControl</span></span><br><span class="line">    <span class="comment">// 因为DCovariant委托是支持协变的</span></span><br><span class="line">    dControl = dButton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用委托</span></span><br><span class="line">    dControl(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逆变：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 支持逆变的委托，in修饰符修饰的是参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> DContravariant&lt;<span class="keyword">in</span> A&gt;(A argument);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符合委托签名的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SampleControl</span>(<span class="params">Control control</span>)</span></span><br><span class="line"><span class="function"></span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SampleButton</span>(<span class="params">Button button</span>)</span></span><br><span class="line"><span class="function"></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将委托实例化</span></span><br><span class="line">    DContravariant&lt;Control&gt; dControl = SampleControl;</span><br><span class="line">    DContravariant&lt;Button&gt; dButton = SampleButton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dControl可以赋给dButton</span></span><br><span class="line">    <span class="comment">// 因为DContravariant委托是支持逆变的</span></span><br><span class="line">    dButton = dControl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用委托</span></span><br><span class="line">    dButton(<span class="keyword">new</span> Button()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="泛型接口中的变体"><a href="#泛型接口中的变体" class="headerlink" title="泛型接口中的变体"></a>泛型接口中的变体</h1><p>除了泛型委托之外，泛型接口里也会运用到变体。</p>
<p>非常常用的<code>IEnumerable&lt;T&gt;</code>、<code>IEnumerator&lt;T&gt;</code>、<code>IQueryable&lt;T&gt;</code> 和<code>IGrouping&lt;TKey,TElement&gt;</code>泛型接口，它们的所有类型参数都是协变类型参数，这些类型参数只用于成员的返回类型。</p>
<p>另外还有<code>IComparer&lt;T&gt;</code>、<code>IComparable&lt;T&gt;</code>和<code>IEqualityComparer&lt;T&gt;</code>等接口，它们的所有类型参数都是逆变类型参数，只用于接口成员中的参数。</p>
<p>关于接口我的理解还不够深入，这里就不展开讨论了。</p>
<blockquote>
<p>开题答辩即将开始，报告一笔未动，不知道最近还有没有机会写LINQ与异步，看情况吧。</p>
</blockquote>
]]></content>
      <tags>
        <tag>C Sharp</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C#杂记之壹：委托与事件</title>
    <url>/2020/02/27/C-%E6%9D%82%E8%AE%B0%E4%B9%8B%E5%A3%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>此前虽然接触过C#中的一些较为高级的操作，但基本是只知其有，不知在哪些场景下可以应用。这几天写着代码就顿觉冗杂不堪，虽然能跑但看起来十分难受，希望寻求一些函数式编程之类的魔法来简化流程。</p>
<p>那首先要理解的还是委托和事件。虽然学完了也不一定会用，但看懂一点总是好的。</p>
<h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如之前所说，委托类似于函数指针。或者说，委托是一种存储函数引用的<strong>类型</strong>。由于函数的参数须是变量/常量/表达式，只要把函数变成一种引用类型的变量，就可以让一个函数作为其它函数的参数了。同样，也可以通过直接调用委托变量来调用委托变量所引用的函数。</p>
<p>为什么要把<strong>类型</strong>加粗？因为声明一个委托类型并不是声明一个委托变量，而是一类委托的<strong>模板</strong>，说明了这类委托应具有的的返回值类型与参数列表。委托类型与具体的委托变量之关系，类似于“类”和“对象”的关系。</p>
<p>委托类型声明和函数类似，拥有返回值类型和参数列表，但没有函数体，并且在前面用<code>delegate</code>关键字声明这是一个委托类型，再声明这个委托类型的变量：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明委托类型和委托变量</span></span><br><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">double</span> <span class="title">ProcessDelegate</span>(<span class="params"><span class="keyword">double</span> param1, <span class="keyword">double</span> param2</span>)</span>;</span><br><span class="line">ProcessDelegate process;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将函数Multiply注册到ProcessDelegate类型的委托变量process</span></span><br><span class="line">process = <span class="keyword">new</span> ProcessDelegate(Multiply);</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以简写</span></span><br><span class="line">process = Multiply;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多播委托(虽然这里没什么用)</span></span><br><span class="line">process += Divide;</span><br><span class="line">process += Add;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用委托</span></span><br><span class="line">System.Console.WriteLine(<span class="string">$"Result:<span class="subst">&#123;process(<span class="number">12.1</span>, <span class="number">22.4</span>)&#125;</span>"</span>);</span><br></pre></td></tr></table></figure>

<p>实际上，委托确实是一种“类”。上面所展示的委托变量声明，其形式就和类的实例化完全一致。在委托变量后面打个点，你甚至能看到一堆委托类型包含的方法和属性：</p>
<p><img src="https://i.loli.net/2020/02/27/xVONQiE1hJIrWf2.jpg" alt="委托也是类"></p>
<a id="more"></a>

<h2 id="何时用委托？"><a href="#何时用委托？" class="headerlink" title="何时用委托？"></a>何时用委托？</h2><p><strong>委托的一个有趣且有用的属性是，它不知道也不关心所引用的方法的类；只关心引用的方法是否具有与委托相同的参数和返回类型。</strong> </p>
<p>这就像是当你饿了的时候，并不是非得去哪家特定的饭店吃饭，而是只要你给钱（参数）能得到食物（返回类型）就行了。这样，就无需先通过继承<code>建筑</code>类来构建一个<code>店铺</code>类，再实现一个<code>厨房</code>接口之类的东西，让其成为<code>饭店</code>——而是就算是大街上一个路人你能从TA那买到吃的，也算是能满足你的需求。</p>
<p>因此，委托的大用处在于<strong>解耦</strong>。一个典型的例子是用在<code>LINQ</code>中。下面的示例选取numbers中小于10的数：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> smallNumbers = numbers.Where(n =&gt; n &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>LINQ的详细介绍留至以后，这可以说是C#中最为变态的武器之一，这里只说说Where方法。</p>
<p>Where方法是接口<code>IEnumerable</code>和<code>IEnumerable&lt;T&gt;</code>中的方法，也只有实现了这两个接口之一或它们的派生接口（如<code>IQueryable&lt;T&gt;</code>）的类可以使用LINQ，这种类被称为<strong>可查询类型</strong>。Where方法的原型：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (<span class="keyword">this</span> IEnumerable&lt;TSource&gt; source, Func&lt;TSource, <span class="keyword">bool</span>&gt; predicate);</span><br></pre></td></tr></table></figure>

<p>分析一下。</p>
<p>首先，这个方法是一个<code>static</code>方法，并且参数列表的第一个参数被<code>this</code>修饰，这是<strong>扩展方法</strong>的特征。这是因为Where方法之类的LINQ操作并不是直接定义在<code>IEnumerable&lt;T&gt;</code>接口里，而是在<code>System.Linq</code>命名空间中定义的扩展方法。扩展方法的第一个，被<code>this</code>所修饰的参数指明了这个扩展方法扩展的是什么类型。</p>
<p><img src="https://i.loli.net/2020/02/27/yb6g3GTIoA1rB4R.jpg" alt="Where是扩展方法.jpg"></p>
<p>可以看到，如果注释掉<code>using System.Linq</code>，虽然<code>List&lt;int&gt;</code>实现了<code>IEnumerable&lt;T&gt;</code>接口，但其中是无法查找到Where方法的。因此，方法原型中的<code>this IEnumerable&lt;TSource&gt; source</code>，指的就是“Where方法所扩展的是<code>IEnumerable&lt;TSource&gt;</code>接口”。</p>
<p>而后面的<code>Func&lt;TSource, bool&gt; predicate</code>就是一个委托，并且是泛型委托。其中关系到“协变和逆变”之类的高深操作留待下次再说。</p>
<p>这个委托用于对每个元素进行测试，看它们是否满足条件。自然，如果满足条件，这个委托将返回bool型的<code>true</code>。泛型委托的泛型类型参数中，最后一个即为委托的返回类型，故而是bool型。而前面的<code>TSource</code>指示了所封装的方法的参数类型。</p>
<p>因此，这个<code>Func&lt;TSource, bool&gt; predicate</code>可以看作是：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">delegate</span> <span class="keyword">bool</span> <span class="title">FooDelegate</span>(<span class="params">TSource foo</span>)</span>;     <span class="comment">//这里的TSource是某个类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FooFunc</span>(<span class="params">TSource foo</span>)</span>&#123;      <span class="comment">//接收TSource，返回bool的函数</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FooDelegate predicate = <span class="keyword">new</span> FooDelegate(FooFunc);</span><br></pre></td></tr></table></figure>

<h2 id="泛型委托"><a href="#泛型委托" class="headerlink" title="泛型委托"></a>泛型委托</h2><p>除了用<code>delegate</code>关键字声明传统委托之外，还有两种泛型委托：即上面提到过的<code>Func&lt;&gt;</code>和另一种<code>Action&lt;&gt;</code>泛型委托。</p>
<p>使用泛型委托，可以避免传统委托在使用前必须定义委托类型才能用委托变量引用函数的麻烦。</p>
<h3 id="Func-lt-gt-泛型委托"><a href="#Func-lt-gt-泛型委托" class="headerlink" title="Func&lt;&gt;泛型委托"></a>Func&lt;&gt;泛型委托</h3><p><code>Func&lt;&gt;</code>泛型委托适用于引用那些返回类型非<code>void</code>的函数。其泛型类型参数的个数可从1-17个不等，其中最后的泛型类型参数代表返回类型，前面的0-16个泛型类型参数代表委托的参数列表。</p>
<p>以下示例用两个泛型委托分别输出List中大于5和小于10的数：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Console;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">PlayGround</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//定义两个函数</span></span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">Foo1</span>(<span class="params"><span class="keyword">int</span> num</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                <span class="keyword">return</span> num &gt; <span class="number">5</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">Foo2</span>(<span class="params"><span class="keyword">int</span> num</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                <span class="keyword">return</span> num &lt; <span class="number">10</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义两个泛型委托</span></span><br><span class="line">            Func&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; foo1 = Foo1;</span><br><span class="line">            Func&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; foo2 = Foo2;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] input = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">37</span>, <span class="number">256</span> &#125;;</span><br><span class="line">            List&lt;<span class="keyword">int</span>&gt; numsList = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;(input);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">int</span> num <span class="keyword">in</span> numsList.Where(foo1).ToList())  <span class="comment">//用委托调用函数Foo1</span></span><br><span class="line">                Write(<span class="string">$"<span class="subst">&#123;num&#125;</span> "</span>);   <span class="comment">//Print: 6 10 37 256</span></span><br><span class="line"></span><br><span class="line">            WriteLine();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">int</span> num <span class="keyword">in</span> numsList.Where(foo2).ToList())  <span class="comment">//用委托调用函数Foo2</span></span><br><span class="line">                Write(<span class="string">$"<span class="subst">&#123;num&#125;</span> "</span>);   <span class="comment">//Print: 1 2 4 5 6</span></span><br><span class="line"></span><br><span class="line">            ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用泛型委托之后，声明委托类型、声明委托变量、引用函数的步骤被结合到了一步：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; foo1 = Foo1;</span><br></pre></td></tr></table></figure>

<p>当然，上述这个例子用Lambda表达式作为委托还会简单得多：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">int</span> num <span class="keyword">in</span> numsList.Where(n =&gt; n &gt; <span class="number">5</span>).ToList())    <span class="comment">//用Lambda表达式表示大于5</span></span><br><span class="line">    Write(<span class="string">$"<span class="subst">&#123;num&#125;</span> "</span>);   <span class="comment">//Print: 6 10 37 256</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">int</span> num <span class="keyword">in</span> numsList.Where(n =&gt; n &lt; <span class="number">10</span>).ToList())   <span class="comment">//用Lambda表达式表示小于10</span></span><br><span class="line">    Write(<span class="string">$"<span class="subst">&#123;num&#125;</span> "</span>);   <span class="comment">//Print: 6 10 37 256</span></span><br></pre></td></tr></table></figure>

<p>实际上，Lambda表达式它完全就是一种委托，属于匿名委托的更简写法。</p>
<h3 id="Action-lt-gt-泛型委托"><a href="#Action-lt-gt-泛型委托" class="headerlink" title="Action&lt;&gt;泛型委托"></a>Action&lt;&gt;泛型委托</h3><p>和<code>Func&lt;&gt;</code>的区别在于，<code>Action&lt;&gt;</code>的返回类型是void。因此，泛型类型参数的个数从0~16个不等，全部代表委托的参数列表。这也非常“Action”：传统意义上的“函数”感觉就是得返回点什么（函数值），而什么也不返回的更像是一个“动作”。这个就不再举例了。</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>事件是在委托的基础上实现的，同样也是解耦利器。</p>
<p>在委托变量的声明前加<code>event</code>关键字就是声明了一个事件。<strong>需要注意，用于事件的委托其返回值一般是void</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个委托类型，接收string，返回void</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">BoilerLogHandler</span>(<span class="params"><span class="keyword">string</span> status</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基于上面的委托类型定义BoilerLogHandler类型的事件BoilerEventLog</span></span><br><span class="line"><span class="comment">//这要求事件处理函数接受string返回void</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> BoilerLogHandler BoilerEventLog;</span><br></pre></td></tr></table></figure>

<p>包含了事件声明定义的类被称为<strong>发布器（publisher）类</strong>；接收事件，并提供事件处理函数的类被称为<strong>订阅器（subscriber）类</strong>。所谓订阅事件的过程，就是将订阅器类的处理函数注册到发布器类那里，当发布器发现事件被引发时，就通知订阅器类去执行相应的处理函数。发布器类有可能同时也是订阅器类之一，而引发事件的类可能既不是发布器类也不是订阅器类。</p>
<p>上面的那段就是发布器类的一部分，定义了事件<code>BoilerEventLog</code>。接下来展示一个相符的订阅器类内容：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//满足BoilerEventLog事件对参数和返回类型要求的函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayMessage</span>(<span class="params"><span class="keyword">string</span> message</span>)</span> =&gt; Console.WriteLine(<span class="string">$"Message arrived: <span class="subst">&#123;message&#125;</span>"</span>);</span><br></pre></td></tr></table></figure>

<p>订阅事件和引发事件：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化发布器类和订阅器类</span></span><br><span class="line">Logger myLogger = <span class="keyword">new</span> Logger();</span><br><span class="line">Display myDisplay = <span class="keyword">new</span> Display();</span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅事件</span></span><br><span class="line">myLogger.BoilerEventLog += <span class="keyword">new</span> BoilerLogHandler(myDisplay.DispalyMessage);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者和委托一样，简化写法：</span></span><br><span class="line">myLogger.BoilerEventLog += myDisplay.DisplayMessage;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引发事件：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用?. 运算符可以轻松确保在事件没有订阅器时不引发事件</span></span><br><span class="line"><span class="comment">//当?. 左侧为null时返回null，非空才访问右侧。没有被订阅的事件就是空的。</span></span><br><span class="line">myLogger.BoilerEventLog?.Invoke(<span class="string">"This is a message."</span>);</span><br></pre></td></tr></table></figure>

<p>接下来，<code>myLogger</code>对象对<code>BoilerEventLog</code>事件中是否有被注册的事件处理函数进行检查，发现有来自<code>myDisplay</code>的处理函数<code>DisplayMessage()</code>，于是传入的参数<code>&quot;This is a message.&quot;</code>被送给处理函数进行处理。</p>
<h2 id="与多播委托的区别？"><a href="#与多播委托的区别？" class="headerlink" title="与多播委托的区别？"></a>与多播委托的区别？</h2><p>目前看来，区别就是没什么太大区别，以至于C#文档里都有这么一篇：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/distinguish-delegates-events" target="_blank" rel="noopener">区别委托和事件</a>。</p>
<p>如<a href="/2020/02/27/C-杂记之壹/委托/定义">委托/定义</a>所言，委托其实也是类，定义的每一种委托都继承自<code>Delegate</code>类。而<code>Delegate</code>类拥有一个静态的<code>Delegate.Combine()</code>方法，用于将同类型多个委托变量的调用列表进行连接合并。这个方法可以由C#编译器对运算符<code>+</code>转译而来（并不是运算符重载）。这和<code>String</code>类的字符串连接是一样的。</p>
<p>多播委托的执行顺序是固定的，按照<code>GetInvocationList()</code>方法所得数组的逆序执行；事件则是不可预测顺序的（据称）。</p>
<p>不过，接下来就有区别了，这个才是重点。</p>
<h2 id="EventHandler"><a href="#EventHandler" class="headerlink" title="EventHandler"></a>EventHandler</h2><p>C#预定义了委托<code>EventHandler</code>和泛型委托<code>EventHandler&lt;TEventArgs&gt;</code>用来写发布器。事实上，考虑到事件引发时通常需要传入不少各种各样的参数，相比前面与多播委托基本没区别的语法，使用这种预定义的事件要更多。</p>
<p>原型：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="keyword">object</span> sender, EventArgs e</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">delegate</span> <span class="keyword">void</span> EventHandler&lt;TEventArgs&gt;(<span class="keyword">object</span> sender, TEventArgs e);</span><br></pre></td></tr></table></figure>

<p>这两个参数，第一个是事件源，在引发事件时填写<code>this</code>即可；第二个参数的类型派生自<code>System.EventArgs</code>，包含任意个事件参数。派生自<code>System.EventArgs</code>的类有很多很多，其中都是C#预先定义的事件形参。</p>
<p>而泛型委托<code>EventHandler&lt;TEventArgs&gt;</code>的区别在于，第二项参数可以不派生自<code>System.EventArgs</code>，而是根据泛型类型参数<code>TEventArgs</code>决定。这意味着，如果希望在引发事件时传入10种参数，你需要根据<code>TEventArgs</code>写一个类，在里面定义10项属性。引发事件时，实例化这个类，把构造出的对象传到第二项参数里。</p>
<p>这个过程相当于是引发事件的类填了一张表格寄出去。表格的格式是预先设计好的，无论是派生自<code>System.EventArgs</code>的类，还是泛型委托里根据泛型类型参数自己写的那个类，其属性是在填写表格之前就确定了的。寄出去的除了填写完整的表格<code>e</code>之外，信封上还有你的联系方式<code>sender</code>。这样，收件人（发布器类）才能知道信是谁寄来的，也能够确定信里表格的格式是符合要求的。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个定义的例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">event</span> EventHandler&lt;MessageArrivedEventArgs&gt; MessageArrived;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件参数类的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MessageArrivedEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">string</span> message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">string</span> Message</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;<span class="keyword">return</span> message;&#125;    <span class="comment">//让message通过Message只读</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显式定义无参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageArrivedEventArgs</span>(<span class="params"></span>)</span>=&gt;</span><br><span class="line">        message = <span class="string">"No message sent."</span></span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageArrivedEventArgs</span>(<span class="params"><span class="keyword">string</span> newMessage</span>)</span>=&gt;</span><br><span class="line">        message = newMessage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引发事件，第一个参数是this，第二个实例化事件参数类</span></span><br><span class="line">MessageArrived(<span class="keyword">this</span>, <span class="keyword">new</span> MessageArrivedEventArgs(<span class="string">"Hello World!"</span>))；</span><br></pre></td></tr></table></figure>

<p>最后要注意的是，如果事件根本不需要传入参数，依然可以用<code>EventHandler</code>委托来定义，只要向第二项参数里传入<code>EventArgs.Empty</code>就行了。</p>
<blockquote>
<p>暂且到此为止，明天应当学习协变、逆变，以及LINQ。</p>
</blockquote>
]]></content>
      <tags>
        <tag>C Sharp</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>200223：890 Errors创立</title>
    <url>/2020/02/23/200223/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="https://i.loli.net/2020/02/23/VmI4h6RczwKMXfE.png" alt="890 Errors"></p>
<p>用一个小时画了这张图，作为同人社团<code>890 Errors</code>的Logo。现在，我也是社团主催了（</p>
<p>尚未发布作品的社团是不能创建THBWiki页面的，所以其实也说不上已经创立。不过饼总是要提前画的，至少现在已经<a href="https://github.com/890-Errors" target="_blank" rel="noopener">在GitHub上成立了Organization</a>……</p>
<p>使用的依然是<code>Aseprite</code>，在我有机会认真学习绘画之前大概要有很长一段时间使用它了。</p>
<p>设计的时候，首先想到的就是阴阳玉，把阴阳玉挂在未来要做的社团Logo上是长期以来的夙愿了。</p>
<p>然后受<a href="https://thwiki.cc/%E6%81%92%E8%90%83%E5%B7%A5%E5%9D%8A" target="_blank" rel="noopener">恆萃工坊</a>Logo的影响，也想把某个卦象用进去。看了看六十四卦有哪些之后，又无从挑起了。索性直接卜上一卦，得到的结果就是这个<code>风山渐 ䷴</code>。</p>
<blockquote>
<p>象曰：<br>俊鸟幸得出笼中，脱离灾难显威风。<br>一朝得意福力至，东西南北任意行。  </p>
</blockquote>
<p>是“稳步发展”的一卦，挺不错的，那就决定是它了（如果不好？那就再Roll一个）。但我岂能期盼什么“福力至”呢？</p>
<p>只用三种颜色未免有些过于单调，于是我把阴阳玉的右半和渐卦的阳爻用“混乱”工具处理了一下，变成了这种好像打上了马赛克的样子——而且这样的六爻不是有点扫描线内味了吗？加上边框和下面的banner之后，阴阳玉又像是陈列在带有“腰封”的盒子里了。<em>（妙啊，妙啊）</em></p>
<p>社团的名称来源于大家喜闻乐见的“0 Errors, 0 Warnings”，但由于我菜得真实，写出0 Error的东西怕是在梦里，就改成了与<code>博麗</code>谐音的<code>890</code>。</p>
<p><img src="https://i.loli.net/2020/02/23/8HGD52OgfMP9mzp.jpg" alt="0 errors"></p>
<p>我发现，自己对于设计实在没有什么储备，喜欢用的元素无非是五行八卦一类的玄学，更别说对红白蓝黑四色的过分偏执，这对我的限制太大了。</p>
<p>很长一段时间里我都没有所谓“偶像”，如今我可以肯定地说ZUN就是我的偶像。在一步一步做着这些的时候，我一方面感叹ZUN的天才，毕竟那是初入大学就全靠自学地开发了《东方灵异传》的人；另一方面痛恨自己的无能，如果我能在有念头的时候就作出行动，一切就不会显得像现在这样晚了。假如现在还是2018年那该多好——这么说着的时候，我应当为之“作出行动”的念头又快要被覆写掉了。</p>
<p>我必须永远与矛盾共生下去。</p>
<blockquote>
<p>庚子二月朔日。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>图像</tag>
        <tag>东方Project</tag>
      </tags>
  </entry>
  <entry>
    <title>从ANSI编码是啥说起</title>
    <url>/2020/02/09/%E4%BB%8EANSI%E7%BC%96%E7%A0%81%E6%98%AF%E5%95%A5%E8%AF%B4%E8%B5%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>在 Windows 记事本的语境中：<br>所谓的「ANSI」指的是对应当前系统 locale 的遗留（legacy）编码。<br><a href="https://www.zhihu.com/question/20650946/answer/15745831" target="_blank" rel="noopener">梁海的回答 - 知乎</a></p>
</blockquote>
<h1 id="所谓编码"><a href="#所谓编码" class="headerlink" title="所谓编码"></a>所谓编码</h1><p>也许你曾试着购买东方Project正作游戏，或别的什么非英语内容：</p>
<p><img src="https://i.loli.net/2020/02/09/SOd1FeGDNHx9iLt.jpg" alt="东方正作"></p>
<p>扔进光驱，兴冲冲安装之后，点开附带的<code>omake.txt</code>文档，你会发现和安装时就遇到的一样，大部分成了乱码：</p>
<p><img src="https://i.loli.net/2020/02/09/UV9Pzu8rQFtSHMj.jpg" alt="omake原文"></p>
<p>奇怪的是，英文、数字、以及一些符号部分并没有变成乱码，这时你就明白，该死的编码问题又出现了。一直到几年前，Windows记事本的默认编码都是写在右下角的<code>ANSI</code>（现在已经是UTF-8），这是什么编码呢？</p>
<a id="more"></a>

<p>当你在简体中文Windows环境下用记事本写一个ANSI编码的文件，再用VS Code这种对各种编码都支持良好的编辑器打开它，编辑器所识别的编码是中国的国标码<code>GB 2312</code>。</p>
<p><img src="https://i.loli.net/2020/02/09/swLx1GrgF7zpRJC.jpg" alt="动画观览记录GB2312.jpg"></p>
<p>而日本的“国标码”是<code>Shift JIS</code>编码，前面提到的<code>omake.txt</code>是不是用这个编码写成的呢？</p>
<p><img src="https://i.loli.net/2020/02/09/xIrod8ZvL7cnO1U.jpg" alt="omake Shift JIS"></p>
<p>答案是肯定的。</p>
<p><strong>为什么同样写着ANSI，实际上却是不同的编码？</strong></p>
<p>花了一上午搜集了些资料，发现这个问题背后的故事远比想象中复杂，接下来就整理整理。</p>
<h1 id="梦回1963"><a href="#梦回1963" class="headerlink" title="梦回1963"></a>梦回1963</h1><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>这段历史故事要从计算机的“蛮荒”年代1963年开始说起。</p>
<p>ANSI指的是美国国家标准学会。1963年时的ANSI还叫作ASA（美国标准协会），以电报码为基础制定了大名鼎鼎的ASCII（美国信息交换标准代码）编码。这套编码共有128个字符，由7位二进制进行编号。ASCII的0~31号，再加上最后的127号“Delete字符”是33个不被显示的“控制字符”，其余95个字符正好与标准键盘符合。</p>
<p>可以对着键盘计算一下：数字行有10个数字键和3个符号键，字母行有26个字母键和8个符号键。而每个键都可以用Shift表示两个字符：</p>
<blockquote>
<p>(10+3+8+26)*2 = 94</p>
</blockquote>
<p>怎么还少一个？因为010 0000的“空格”也是一个字符，与000 0000的“空字符”并不等同，所以一共就是ASCII中的95个可显示字符。</p>
<h2 id="EASCII"><a href="#EASCII" class="headerlink" title="EASCII"></a>EASCII</h2><p>ASCII虽短小精悍，符号可能足够美国的电报系统使用，但要在计算机世界推行开来就有两个问题（我口胡的）：</p>
<ul>
<li>计算机的存储需要“对齐”，编码位数如果是2的整数幂，如8位会更方便、效率更高。而ASCII只有7位；</li>
<li>ASCII没有法语德语等所包含的衍生拉丁字母，难以在欧洲实行，符号也不够全。</li>
</ul>
<p>因此在70、80年代，<code>EASCII</code>（延伸美国标准信息交换码）应运而生，通过把ASCII扩展到8位，就又可以加入128个字符。但EASCII没有形成统一的标准，而是有数种互不兼容的方案，这里讲两个影响力较大的：</p>
<h3 id="Code-page-437"><a href="#Code-page-437" class="headerlink" title="Code page 437"></a>Code page 437</h3><p>这是由IBM制定的标准，在1981年发布的原始IBM PC上采用。它扩展了衍生拉丁字母、希腊字母和一些表格符号等，还将ASCII中那些已被弃用却无法显示的控制字符做成了一些特殊符号，如很具有标志性的两个笑脸——0x01和0x02。设计思路基本来自于当时与IBM分庭抗礼的<a href="https://www.huxiu.com/article/292306.html" target="_blank" rel="noopener">王安电脑</a>。</p>
<p><img src="https://i.loli.net/2020/02/09/So1JBGPuDcv3ekX.png" alt="Code page 437"></p>
<p>由于后来IBM PC的巨大成功以及微软和IBM之间的渊源，这套标准在MS-DOS里流传下来，这也就是我们在使用DOSBox的汇编实验里，在Borland Turbo Debugger中所见到的：</p>
<p><img src="https://i.loli.net/2020/02/09/EoOatu1m9DdIgLB.png" alt=""></p>
<h3 id="ISO-IEC-8859"><a href="#ISO-IEC-8859" class="headerlink" title="ISO/IEC 8859"></a>ISO/IEC 8859</h3><p>这个8位字符集标准由ISO（国际标准化组织）及IEC（国际电工委员会）联合制定，其中包含<code>ISO/IEC 8859-1</code>到<code>ISO/IEC 8859-16</code>，但没有12号的15套扩展方案。而每一套方案就是扩展了一个地区的语言符号。这里贴出扩展了西里尔字母的<code>ISO/IEC 8859-5</code>：</p>
<p><img src="https://i.loli.net/2020/02/09/psfVuZoHL2ST1Oc.jpg" alt="ISO/IEC 8859-5"></p>
<p>这项工作最早并不是由ISO和IEC启动的，而是由ANSI和ECMA（欧洲计算机制造商协会）。他们于1985年公布<code>ECMA-94</code>，即后来的ISO/IEC 8859 parts 1, 2, 3, 4。</p>
<p>80年代雄霸西方，如今却只能在<a href="https://www.bilibili.com/video/av5953981" target="_blank" rel="noopener">敖厂长的视频</a>里见到的Commandore 64使用的就是ISO/IEC 8859，这也见证了那个IBM、苹果、Commandore、雅达利群雄并起的时代。</p>
<p>另外需要提及的是<code>Windows-1252</code>，即Code page 1252，这是西方文字版本Windows（而不是MS-DOS）中默认的字符集，是ISO/IEC 8859-1的超集。虽然并非是真正的ANSI标准或ISO标准，但却是最流行的。在微软投向国际标准化、Windows普及开来之后，Code page 437也就逐渐消失了。</p>
<h2 id="东方宽字符"><a href="#东方宽字符" class="headerlink" title="东方宽字符"></a>东方宽字符</h2><p>80年代计算机在汉字文化圈逐渐流行时，情况又不妙了起来：汉字数量太多，一个字节的8位也不够用了。那么就用两个甚至多个字节来表示一个字符吧，这就是所谓的“宽字符”。不过东方世界的剧情稍有变化，因为此时已有<code>ISO/IEC 2022</code>这一技术规范指导东方文字的编码。中国大陆由此制定了包含6763个汉字的国标码<code>GB 2312</code>，覆盖了绝大多数使用环境。许多生僻字没法处理，于是后来又制定了加入更多汉字的<code>GBK</code>，即国标扩展。但GB 2312留下来的坑一直遗留到最近几年，让名字里有生僻字的人乘飞机或办手续都麻烦不少。</p>
<p>日本产业标准调查会JISC也根据ISO/IEC 2022进行了一系列骚操作，最终形成了<code>Shift JIS</code>。通行于港澳台的<code>Big5</code>也于此时诞生。</p>
<p>微软要在系统里支持这么多种编码，只好使用<code>Windows code page</code>这个值（可以用<code>chcp</code>命令查看）来代表当前系统的编码标准。可能这些五花八门的编码基本都发源于ISO/IEC，往上再追溯一下就到了ANSI的ASCII，于是微软模糊地用<strong>ANSI</strong>来概括了这一切，即我们在Windows中所看到的ANSI并不是某种特定的编码，而是当前区域所使用的编码标准。Windows简体中文系统的Code page是936，早期对应的是GB 2312，在Windows 95之后成为了GBK。而前面所见的Code page 437和Code page 1252也都是这套玩意的一部分。</p>
<p>Code page代码页的机制也体现在Linux中，只是Linux没有“ANSI”这种不科学不严谨的Windows特色表述。而且Linux诞生于1991年的近代，许多历史包袱大可以免去，很快也就支持了Unicode。</p>
<p>啊，Unicode当然才是最重要的一页。</p>
<h1 id="Unicode拯救世界"><a href="#Unicode拯救世界" class="headerlink" title="Unicode拯救世界"></a>Unicode拯救世界</h1><p>这种乱七八糟的情况持续到80年代末，无论是ISO还是业界都看不下去了。ISO于1988年开始制定<code>ISO 10646</code>通用字符集；几乎与此同时，Apple和Xerox等软件制造商组成Unicode联盟，开始制定<code>Unicode</code>。但他们发现如果两边各自为政，世界又会再次分裂，就像已经对立了几十年的美苏冷战；于是他们开始合作，ISO 10646和Unicode最终基本成了同一样东西——所有的字符都在相同的位置并且有相同的名字。</p>
<p>Unicode编码点分为17个平面（plane），每个平面包含2^16（即65536）个码位（code point）。17个平面的码位可表示为从U+xx0000到U+xxFFFF，其中xx表示十六进制值从0x00到0x10，共计17个平面。</p>
<p>1991年，Unicode 1.0.0横空出世，几乎整合了所有西方字母文字；</p>
<p>1992年，中日韩统一表意文字（<strong>CJK</strong> Unified Ideographs）被定义并加入Unicode。</p>
<p>此后，开放合作、兼容并包成为天下大势，几乎所有能被形容为“现代”的计算机世界物体都支持了Unicode，Unicode本身也在不断发展，不再是一个单纯的“编码”，而是一种标准，包含了Unicode编码方式和多种实现方式，即所谓的Unicode转换格式UTF。你现在所看到的这个网页，使用的就是<code>UTF-8</code>编码实现方式。</p>
<p>关于Unicode的更多内容，这里有一篇讲的很清晰的文章：</p>
<p><a href="https://www.cnblogs.com/malecrab/p/5300503.html" target="_blank" rel="noopener">细说：Unicode, UTF-8, UTF-16, UTF-32, UCS-2, UCS-4</a></p>
<h1 id="“字符集”与“编码”"><a href="#“字符集”与“编码”" class="headerlink" title="“字符集”与“编码”"></a>“字符集”与“编码”</h1><p>前面说了这么多，表述中又有“字符集”（character set），又有“编码”（character encoding），它们到底区别在哪？</p>
<p><strong>“字符集”</strong> 当然是字符的“集”，是各种文字和符号的总称。这指明了有哪些字符是被需要的，以及它们长什么样（字形）。不少汉字在不同区域有不同的写法，字形不统一的情况下如何取舍，就属于字符集的范畴。</p>
<p><img src="https://i.loli.net/2020/02/09/SXHxidJQBRwMWqt.png" alt="次的五种写法：台陆朝越日"></p>
<p><strong>“字符编码”</strong> 是将字符集中的每一个字符都用一串二进制数表示的方法。当我们谈论GB 2312时，我们所说的其实是GB 2312字符集，以及用于对其进行编码的EUC-CN编码方案，这两个事物组合起来才是所谓的“GB 2312编码”。Unicode最“正统”的编码方案是UTF-32，但结合二八定律还是UTF-8更加实用，因此“Unicode编码”的说法是不准确的，所谓的Unicode更像是字符集。</p>
<h1 id="U-5F41-彁"><a href="#U-5F41-彁" class="headerlink" title="U+5F41 彁"></a>U+5F41 <strong>彁</strong></h1><p>最后，又要首尾呼应地回到东方Project。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1414037312&auto=0&height=66"></iframe>

<p><strong>彁</strong>，这是前面所说的Shift JIS形成的早期，被1978年通商产业省制定的<code>JIS C 6226</code>错误收录的29个不存在的“幽灵汉字”之一。这些汉字一时不知读音、含义也不知具体出典，令人迷惑。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">幽灵汉字</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">垉（52区21点）</td>
<td align="center">垈（52区18点）</td>
<td align="center">墸（52区55点）</td>
</tr>
<tr>
<td align="center">壥（52区63点）</td>
<td align="center">妛（54区12点）</td>
<td align="center">岾（54区19点）</td>
</tr>
<tr>
<td align="center">彁（55区27点）</td>
<td align="center">恷（55区78点）</td>
<td align="center">挧（57区43点）</td>
</tr>
<tr>
<td align="center">暃（58区83点）</td>
<td align="center">椦（59区91点）</td>
<td align="center">橸（60区81点）</td>
</tr>
<tr>
<td align="center">汢（61区73点）</td>
<td align="center">熕（63区80点）</td>
<td align="center">碵（66区83点）</td>
</tr>
<tr>
<td align="center">穃（67区46点）</td>
<td align="center">粐（68区68点）</td>
<td align="center">粭（68区70点）</td>
</tr>
<tr>
<td align="center">粫（68区72点）</td>
<td align="center">糘（68区84点）</td>
<td align="center">膤（71区19点）</td>
</tr>
<tr>
<td align="center">蟐（74区12点）</td>
<td align="center">袮（74区57点）</td>
<td align="center">軅（77区32点）</td>
</tr>
<tr>
<td align="center">鍄（78区93点）</td>
<td align="center">閠（79区64点）</td>
<td align="center">靹（80区56点）</td>
</tr>
<tr>
<td align="center">駲（81区50点）</td>
<td align="center">鵈（82区94点）</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>1997年，日本对这29个字进行了深入的调查。他们发现其中一些字来自名字极生僻的地名，如静冈县的石橸（いしだる），另一些是被误写、误认的错别字，如“𡚴”被记成了“妛”……最终，29个幽灵汉字中有28个成功找到了来源，“成佛得脱”。</p>
<p>唯独<strong>彁</strong>字，跨越不知多少年，仍然是个谜。</p>
<p>但它就此被保留下来，从JIS C 6226到Shift JIS，到CJK，最后成为Unicode中的“U+5F41”，成为全世界计算机中不可分割的一部分。</p>
<p>也许这个字确实存在其出处，但在这数十年间终于连其最后的出典也散佚。如今留下的只有这永存的痕迹，作为描绘“现实”的字符集中唯一的“幻想”，与相信着车库中有喷火龙的人类一起迈向宇宙的终焉。</p>
]]></content>
      <tags>
        <tag>东方Project</tag>
        <tag>考古</tag>
        <tag>标准</tag>
      </tags>
  </entry>
  <entry>
    <title>200208：瘟疫，党，怎样说话</title>
    <url>/2020/02/08/200208/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>昨天说今天该讲讲ANSI编码，并且不再去微博乱逛了，但早上习惯性地点开翻几页，又感觉那根弦紧了一紧。有一些话想说，但在境内当然是没办法开口的，无论说得多么谨小慎微也避不过全体人民“群防群控”的自我审查。GitHub Pages上这块无人造访的IP就算作是互联网的“法外之地”，让我在这里信口开河，“反动”几下吧。</p>
<p>我早年从知乎结识的网友<a href="https://www.zhihu.com/people/jingujisuzuka" target="_blank" rel="noopener">神宫寺铃香</a>发了这么一段：</p>
<p><img src="https://i.loli.net/2020/02/08/CRmJTiBnxeSjaVZ.jpg" alt="路易十六一文不值"></p>
<p>这段话出自法国大革命时期吉伦特派的皮埃尔·韦鸠尼昂·韦尼奥之口。这样的言辞是如何得以出现的？当中国的某个掌权者的做法与宪法背道而驰之时，我们能够像这样大胆斥责吗？</p>
<p>显然是不能的。“得道者多助，失道者寡助”，受到这样批判的当然是寡助者——多助者在被这样批判的时候，发出批判的人立刻就会被口水淹没。不幸的是，政治的发展和技术的变革让得道者不一定多助，失道者也不一定寡助了，或者至少将他们多助、寡助的时间点大大延后，使得许多事物可以被扼杀于摇篮。</p>
<p>这些天，肺炎疫情把武汉政府的虚伪面具撕得稀烂，官僚主义、形式主义的败絮化为血的火焰，烧穿包装纸让魔幻的现实在全世界面前光彩夺目。因此，舆论的战斗被推到自习近平同志就任以来所未有的高度，甚至有人表示“上一次有这么多人觉醒，还是1989年”，品葱的反共分子和连登的香港废青们弹冠相庆，似乎民智将开，马上就要十月革命一声炮响，共产党就要被打倒了。</p>
<a id="more"></a>

<p>但从大体上看，中国共产党经历九十九年仍然是得道者。多助寡助自不必说，光是党员就有9000万之巨，假如将其看作一种有具体名头的宗教，那也是世界第五大教了。得道就在于，无论当年是通过机缘巧合还是苏联援助，还是中共声称的历史必然性，即“没有共产党就没有新中国”的阐释，中共最终是成功在中国建立了较为稳定的社会主义政权，使中国摆脱了半殖民地半封建社会的性质，这一点无论怎么抹黑都是不可否认的。而且经过七十年的“艰难探索”，在集中力量办大事，杀了许多好人和坏人之后，在让懒惰的人穷下去，勤劳的人富起来之后，成为了“第三世界”中有头有脸的一员，甚至让一部分狂妄的人提前敢于和曾经骑在祖先头上的“西方列强”掰掰手腕。</p>
<p>但是哪个政权是可以永远存在的呢？古代的帝王号称受命于天，但嫡传几代就免不了“天数有变”的历史周期律；“资本主义社会”以资本为中心，政权怎么更迭都是服务于资本，本质上没有多少区别；中国的马克思主义者认为建设社会主义并逐渐发展到共产主义的究极形态是破除周期律的方法——毕竟那时就根本没有政权了。</p>
<p><strong>可是我们并不能很自信地声称我们的国家是一个社会主义国家，朋友们。</strong> 尽管习近平同志鼓励我们要自信，要有“道路自信、理论自信、制度自信、文化自信”，我们依然没有自信。中国人失掉自信力了吗？</p>
<p><img src="https://i.loli.net/2020/02/08/ilGZPOxw13Me97R.jpg" alt=""></p>
<p>“我对社会主义没有概念”，这是一个迷惘的青年人的话语，也是时代的缩影。他成长在远离战争与革命的21世纪中国，至少他从日常生活中体会不到我们和我们曾经的敌人到底有什么不同，也许区别仅仅在我们的限制比他们更多。</p>
<blockquote>
<p>我们从古以来，就有埋头苦干的人，有拼命硬干的人，有为民请命的人，有舍身求法的人，……虽是等于为帝王将相作家谱的所谓“正史”，也往往掩不住他们的光耀，这就是中国的脊梁。 </p>
<p>——鲁迅</p>
</blockquote>
<p>我们看到，至今仍然有埋头苦干的人和拼命硬干的人，但为民请命、舍身求法的人去了哪里？他们虽有的在发光发热，甚至在主席之位孤军奋战，却也有许多人成了“404”，那些人里有的收到了训诫书，有的在监狱，有的亡命天涯，有的已经死去。</p>
<p>人民万岁！但人民即将失败，他们不知道自己的故乡到底是不是恶之花绽放的土地，他们今天可以高唱“我和我的祖国”，明天就可以对整个世界绝望。因为他们是无知的。这并不能怪罪他们，我们一方面把民主作为核心价值观，另一方面却希望所有的民都做同样的主，到头来他们仍然一无所知，把个人的命运交给国家，甚至把国家偶像化，好像自己并非是国家的主人，并非是时代的铸造者。</p>
<p>当小布尔乔亚们的“韭菜”论大行其道的时候，我想就算我会被人称为下一茬“韭菜”，我也应保持一定的乐观：虫子虽然是虫子，却也不妨害它们成为世界生物之林中的佼佼者。但浅薄的我听到那些被称为公知的智者的悲观言论，乃至“诸夏”这种极度绝望的观点，又不免要动摇了。</p>
<p>其实我所期望的、人们所期望的哪有那么复杂。我希望那些被写在《中华人民共和国宪法》上的东西能被那些声称“依法治国”的人好好执行。如果做不到当初就不应该写下来，就算临时反悔把一些什么从宪法上抹掉也没关系，但承诺过的事情没能做到，性质是很恶劣的。但是这点小小的愿望，在几乎不允许讨论《宪法》的国度，连用《宪法》赋予我的“言论自由”说出来的机会也很难有。</p>
<p><img src="https://i.loli.net/2020/02/08/EtUHdcrPWOQGp5Z.jpg" alt="不存在的宪法"></p>
<p>因此我逐渐走向中立，这是绝大多数中国人最擅长的：“我就什么话也不说。这是最好的。”把世界交给那些象牙塔中经天纬地的学究吧！他们比我们这些什么都没经历过的臭小子们强太多太多，在他们眼中任何超脱飞扬的思想都是老掉牙的笑话，任何激情澎湃的斗争都是大棋中必然的一步。哈哈！</p>
<p>那些有话想说的人，他们依然秘密集结在社会之光照不到的阴暗角落，战战兢兢或者大义凛然。“这个社会就是这样”、“别人说只是那么说”、“真话是不能乱讲的”、“所谓的规则和正义只是感动自己”——沉重而颠倒黑白的话语却在共和国的每一处角落，与染血的悲壮国歌一同飘扬：“起来，不愿做奴隶的人们……”</p>
<blockquote>
<p>庚子元宵。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>国事</tag>
      </tags>
  </entry>
  <entry>
    <title>200207：绿叶，月，细毛顶端</title>
    <url>/2020/02/07/200207/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>也很有些时间没更新博客了。在我没反应过来的时候，时间依旧飞速地流逝。</p>
<p>这近一个月来发生的事太多又太少，无非绕不开“新型冠状病毒感染的肺炎疫情”一事。截至今日我已经有半个多月未尝出过门了，站在阳台上看着除了人以外什么都还存在着的大街，感到有些荒诞。“末日之后”的感觉却又不是那么浓烈，也许是我度过几次独自在寝室的大学假期，已经习惯了在杳无人烟的氛围里，抬头看着漏下日光的翠绿梧桐叶子发呆的生活吧。</p>
<p>大学的最后一个假期也将要过去，我大抵是不会再有体验这种生活的机会了——这种莫名有点感慨的心态，就像当年高考前最后的一次晚自习——以后不会再有晚自习了，也不会再有晚自习上小心回避着老师而听的歌、看的闲书了。“大学四年顶个球”，留下的东西实在不多，而我才刚刚开始认识这个世界。</p>
<p>身边参加了考研的朋友们，面对前途大多迷茫，苦笑着一年努力八成喂了狗。往往是越学越了解自己的浅薄，就像现在看看6年前入宅不久时自己写的、自己得意的东西，显得与2020年的网络那么格格不入，像mikufans时期的弹幕乃至古早时期猫扑大杂烩里的帖子，没有经过思考的吐槽、没有经过考证的论调中，真挚与弱智三七分成。</p>
<p>不过网络变化其实不大，至少真挚与弱智的三七分成还是没变。谁都没有上帝视角，哪一方都太容易被现实愚弄，绕来绕去才发现大家其实都有同一种病，没有谁就高人一等。</p>
<a id="more"></a>

<p>要说高中的基调是怎样，我想起来的就是大一时初次在华科见到的——其实直到如今也一样——在黑糊糊树影的簇拥之上那个圆月。只是高中所见的月被“黄冈中学”的明亮红色灯牌和教学楼上缠着的黄色灯带烘托着，再被些许我可能叫得出名字的星点围绕着，似乎要黯淡些。说来也怪，这么些年，每有了要去观察月亮的心时，偏偏就是“天心月圆”。或者，就是在远远的远方，薄薄的渐变色里浮着的一勾新月。新月，它总让我想起伊斯兰世界，那个世界似乎比这新月还要遥远。</p>
<p>新月，新月沃地，那里的印象就是天方、阿萨辛和游侠纳斯列金。文化与瘟疫最早的起源之一在这里。</p>
<p><img src="https://i.loli.net/2020/02/07/CRgwvaHt1qonkpN.jpg" alt="新月"></p>
<p>说回瘟疫，短短半个多月的肺炎时期见到的荒诞比过去几年加起来还多。元旦八勇士之后，那由于湖北“两会”而消失的半个月且不说，之后的封城，武汉病毒所，上海药物所，N95口罩，双黄连，无人机，唱国歌，红十字会，火神山，雷神山，方舱，一直到今天以自己的逝去让全国人民更加地哀痛的李文亮医生，这个阵仗早已比2003年的非典高了许多等级。那时候我应该还在上学前班，记忆尤其模糊，只记得曾造访过江家巷的筒子楼，还怎的学习过英语，那一带的炸酱面相当不错。唯一可以确信的，就是没有像如今这样严格的隔离，大家的生活似乎照常。</p>
<p>隔离之前，好在为了预备不发快递的新年，我预先购入了《塞尔达传说：旷野之息》。这看来是极为英明的决定，这段时间若没有这张卡带作我随时跳到海拉鲁大陆的传送门，世界就太过于枯燥了。50多个小时的跋山涉水，好像是我自己在经历，也许这就是21世纪最伟大的游戏吧。</p>
<p><img src="https://i.loli.net/2020/02/07/P5poIKaDeCj8mSt.jpg" alt="米法"></p>
<p>就这么玩下去当然不是办法，虽然原定2月16日的开学时间肯定是推迟了，春招想必也是推迟了，可我要做的事情是一点也没有减少。前几天Unity发来一封电邮，为了大家在家有学可上，给大中华区用户送来了4个月的Unity Learn Premium会员，我可真是谢谢您（诚挚）。跟着弄了几天，写出一个与自己的毕设没啥关联的Demo，对Unity的了解是从兔毛顶端摸到了兔子皮。今天是成功Deploy出来的快乐日子，倒是不想多学了。</p>
<p>明天呢？明天做什么？总得迎来明天的，不管怎么“Ready perfectly”，「東方珀露澗 ~ Aurora of Dragon Lore.」它总得继续动笔。</p>
<p>翻翻To Do？哦，我的ANSI编码还没讲呢。就连已经写完一个多月的C++字符串也还留在待办里没划掉，我是有多久没打开这玩意了？这个主界面的待办创建于去年12月10日，我的毕设积了两个月的灰啊。</p>
<p><img src="https://i.loli.net/2020/02/07/hwvXZ6KmbzTtA4k.jpg" alt="主界面ToDo"></p>
<p>好，明天就先花一点时间来写ANSI编码吧，这个应该挺快的。主界面……我想基本UI也许可以弄出来，至于AudioClip，我想还得了解了解同人音乐方面的利用规约，总不能真就靠自己作曲吧——如果我勤奋一点，其实现在应该已经学会做Arrange了，懒狗要不得啊。</p>
<p>啊，还有八字没一撇的开题报告呢。我不应该继续上微博跟着他们群情激愤或者痛哭流涕了，我的人生是自己的。春招的命运都暂且不谈了，我如今最想做的就是完成《東方珀露澗》，然后顺利毕业。</p>
<blockquote>
<p>庚子正月几望。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>被禁锢的自由——对中国动漫的几点看法</title>
    <url>/2020/02/07/%E8%A2%AB%E7%A6%81%E9%94%A2%E7%9A%84%E8%87%AA%E7%94%B1-%E5%AF%B9%E4%B8%AD%E5%9B%BD%E5%8A%A8%E6%BC%AB%E7%9A%84%E5%87%A0%E7%82%B9%E7%9C%8B%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>谈到动漫，世界上比较有权威的大概只有三个国家：日本、美国和中国。然而当动漫在国外蓬勃发展时，我国动漫却总不受观众待见。在我们看来，中国动漫所遭遇的窘境，根本原因是我国广电总局长期以来所施加的压力以及大部分制作人的庸俗思想。</p>
<p>在美国 ，动漫寄托的是天马行空的想象、美利坚人民独特的冒险精神；在日本，动漫早已成为这个国家新型文化中的重要组成部分，在任何地方都能看到它的影子，这种文化的浪潮席卷世界……中国与它们的不同在于，美日都称动漫为“文化”，或者干脆是“艺术”，而我国一直将动漫作为“产业”对待。这就是我们在政府态度上的差异。广电总局还一再说为了大力促进国产动漫“产业”发展，在各种时段禁播境外动漫作品，实在是恶性循环！</p>
<p>动漫，它的存在意义在于使未成年人更明晰地了解这个世界，或者让成年人从中也有所感悟，所以它理应是面向所有年龄段观众的，然而既然这样，就不可避免地要含有一些所谓“成人世界”的元素，就是广电总局所说的“恐怖、暴力、色情、凶杀、犯罪”等等。因此，为了“创建和谐社会”，“还孩子们一片纯净的天空”，许多好作品都不受光电待见，最典型的就是《秦时明月》，这部被民众广泛认为“冲出国门，走向世界”的诚意之作，曾经差点被禁播，现在也不怎么受电视台的追捧，只是在网络上一直受人关注。《秦时明月》讲的是战国时代的故事，它有点征伐、武侠、爱恨交织的元素怎么了？光电却曾认为它“血腥暴力内容不健康”。什么居心？那么，日本的作品《日在校园》中女主角之一杀死男主角和女主角其二并分尸的情节（其原因还是由于男主角乱搞男女关系）真可谓是和谐社会的“毒草”了。</p>
<a id="more"></a>

<p>日本动漫可能在广电看来“不健康”，然则它们往往蕴涵着深刻的思想。比如《Date A Live》，开头就说“30年前的一场‘空间震’，使三千万人命丧黄泉”，这时广电就会说“小孩子看了多不好啊，禁播！”但《Date A Live》的主要情节是用爱改变引发“空间震”的精灵的暴戾性格，使其融入人类社会，宣扬的是“兼爱”、“非攻”的思想，展现的是世界的美好，但这样的情节放到国内可能会被认为是“鼓动未成年人早恋”云云。据我们的判断，广电对于“教唆未成年人早恋”的作品极其反感，甚至连广电最喜欢的“动物世界”类型动漫（角色全都是各种动物）也逃脱不了这样的“铁律”，导致一代经典（“动物世界”中的经典）《虹猫蓝兔七侠传》被禁播。广电，你也太小看现在的孩子们的心理承受能力了吧。</p>
<p>在《名侦探柯南》情节越来越高智商的同时，我国作品陷入了“低龄化”的圈子，真正适合全年龄段的国产作品，就只有以《秦时明月》为代表的一小批作品。许多在网络上受人追捧的作品的制作者叹道：“像我们《十万个冷笑话》这样‘和谐’的作品绝对上不了电视！”能上电视的，总是以《喜羊羊与灰太狼》为代表的大批“低龄化”、“低智商”的作品。我们不否认这些作品对低龄人群的作用，但我们作为青少年，也理应拥有适合我们年龄段的优秀国产作品。</p>
<p>国产作品存在一个严重的架构问题。许多作品有很强的的“未来感”，讲什么星际航行或者时间旅行之类，为了渲染还不惜重金非要做成三维的，然则情节实在不与其华丽的外表匹配，绝大多数都是好人一路刷怪，逢怪必胜，然后偶尔出几个拽一点的就多打一两集还是必胜，最后一路杀到最终Boss，一场惊天动地的大战之后好人重伤，坏人被打死，世界解放；或者“复杂”一点，最终大战中Boss放了个阴招杀了女主角，男主角痛不欲生小宇宙爆发用不科学的超必杀技秒杀Boss，最后女主角又不知怎么回事地复活，然后，还是大团圆结局……这类作品的开山鼻祖大概是当年的《神兵小将》，实在是逢怪必胜啊。只有一些有节操的作品能脱离这一情节，比如《葫芦娃》中“小蝴蝶”死后就没有复活，然则最后还是“葫芦小金刚”一路刷怪，一般是秒杀，于是又“正义战胜了邪恶”，蛇精再次被封印。只有含金量高，世界观宏大的作品才能冲击“经典”，如《火影忍者》、《海贼王》、《死神》等 ，这样的作品才能催生出“文化”。这种超长篇作品，情节复杂，可能分好几条明线暗线，但又十分严谨，所以经过冷静的推理剖析甚至可以知道角色们在同一时间里大概在做什么……这样才具有研究价值，令人回味无穷。由于大部分改编自漫画或小说，它们拥有了如此强的故事性，而我国作品，据我所知，没有任何一部由漫画或小说改编，从来只有由动漫改编为漫画（如《魁拔》）或小说改编为漫画（如《盗墓笔记》、《斗破苍穹》等），这就大大限制了动漫的剧情，因为做动漫的设计剧情必然胜不过专业作家、漫画家。然而这条路在中国走起来似乎很困难，中央对于这个貌似的确很反感，《新闻联播》曾有两则报道，令我等实在无语。</p>
<p>其一：一位记者走向书摊（“非正常拍摄”又一次神秘地出现在屏幕右上角），拿起漫画《斗破苍穹》单行本1翻阅，询问店主销售情况。这倒没什么，CCTV的一贯作风而已。然而当记者翻到退婚情节里萧炎被刺时，说了一句经典的话：“啊，一刀下去血就出来了，小孩子看了多吓人啊！”在此我只能默默吐槽一句你这句话让那些尸横遍野血流成河灭绝人性的抗日神剧好不容易积攒的存在感瞬间付诸东流了啊！难道“小孩子”在动漫作品里看不到这种“血腥”，在电视里就看不到吗？这和“掩耳盗铃”不知为何有几分相似。</p>
<p>其二：有条新闻说“同性交友网站在中国兴起”，然而其背景却是国内著名动漫网站“哔哩哔哩”，于是许多网友纷纷戏谑地表示“妈妈对不起我是那儿的会员还是高级的！”如果不是CCTV的工作人员太二（估计不会），那我们就能从这则新闻里看到深深的恶意。“哔哩哔哩”在这件事后甚至更改了域名。</p>
<p>从这两则报道中，我们看出中国的动漫发展是被禁锢的，《我叫MT》甚至登上了英国的报纸，但要打进电视，总会被以“狗肉上不了正席”一类的理由毙掉，那敢问一句什么才不是“狗肉”？难道是《喜羊羊与灰太狼》这样的作品才能上“正席”？中国从来不缺人才，从来不缺好的创意，然而佳作却总是被简单粗暴地拒之门外，可能国家机关早就习惯了这样做，奇怪的是那些官僚却还在奇怪中国动漫投入了那么多资金怎么就走不出国门成不了经典，他们有反省过自己的行为吗？一颗种子被锁在铁盒子里，再怎么努力它也冲不破牢笼，因为笼罩着它的是不负责任的黑幕。就像中国足球，无论怎么请外教请外援都改变不了非专业的现状，而且现在的学生越来越厌恶体育课了，他们到底被给过多少自由？又有多少真正有才能的人，只是因为没有“后门”可走，就被庸才取而代之？这简直像一个杀人凶手伏尸大哭：“我亲爱的朋友，你死得好惨哪！到底是哪个混蛋害死了你……”这就是某些人的丑恶嘴脸。</p>
<p>限制中国动漫发展的另一方面就是制作者普遍的庸俗思想，一切都以盈利为中心，于是造就了大批所谓的“动画电影”。《喜羊羊与灰太狼》每年出一部贺岁片，不知道从孩子们身上赚了多少钱；连一些游戏，如《赛尔号》等也竞相模仿。然而却没有任何一部称得上经典，能与美国的Pixar、Disney，日本的吉卜力相提并论——《千与千寻》、《玩具总动员》、《冰雪奇缘》……哪一个不是一上映就引发轩然大波，风靡全球？中国的作品做到过吗？如今的制作者甚至早已摒弃了中国瑰丽的传统文化，可外国人却视若珍宝，让《功夫熊猫》、《成龙历险记》在异乡生根发芽，实在是讽刺！与中国制作者相比，我们的邻邦日本，情况就大不相同了。作家写出小说，画师为其作画、设计人物形象，出版社整理成书，制作方严格按照化石的设计改编出动画，电视台安排放送，所有的人都是怀着神圣、肃穆、庄严、激动的心态做自己的工作。《Date A Live》动画第一季的制作方，在公司陷入困窘之中时仍然一丝不苟地制作，终于做出了登峰造极的作品。而这家公司却在这部千古绝唱上映后不久由于种种原因破产倒闭，但他们的敬业专注执着成功地使这12集动漫成为璀璨的经典。这令我国浮躁的制作者汗颜。</p>
<p>搞动漫是为了什么？那是一种梦想，是希望，是使命感。是为了成功的喜悦，看到自己的作品像自己的孩子一样在世上诞生，这些都不是金钱所能衡量的。可惜在中国，这样有艺术家情怀的制作者还是太少，许多人都在求新求异的路上迷失了方向，忽略了那来源于心灵深处的感动。动漫带给我们快乐，温暖，羁绊，教会我们怎样去爱自己，爱别人——即使二次元的世界里有再多的邪恶力量，也比一个用甜言蜜语堆砌起的“太平盛世”要好得多。</p>
<p>突然想到了著名AV女优苍井空的一句名言：“我脱下衣服躺在镜头前，是为了生存；而有的人衣冠楚楚地坐在镜头前，嘴里却满是赤裸裸的欺骗。”</p>
<blockquote>
<p>此文撰于2014年4月16日，趁原稿尚未损毁，整理于此。<br>由于知识水平与时代背景的局限，如今看来是相当野蛮。<br>日光之下并无新事，以史为鉴！</p>
</blockquote>
]]></content>
      <tags>
        <tag>国事</tag>
        <tag>遗产</tag>
      </tags>
  </entry>
  <entry>
    <title>为小米手环4制作自定义表盘</title>
    <url>/2020/01/11/%E4%B8%BA%E5%B0%8F%E7%B1%B3%E6%89%8B%E7%8E%AF4%E5%88%B6%E4%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E7%9B%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="https://i.loli.net/2020/01/12/uMehFaU86boClZL.jpg" alt="小米手环4"></p>
<p>在以100元的低价将Pebble Time转让给同学之后，今天买到了小米手环4NFC版。说实话Pebble是真的好用，可惜反射屏带来的续航依旧不是那么完美，而且人在国内，这些东西还是与国内的“生态”接轨比较好。</p>
<p>拿到新电子产品，当然得瞎折腾一阵。首先就得换个表盘。但可惜，小米运动APP里的自定义表盘仅仅支持3种预置布局下的背景图自定义，这显然不够酷。</p>
<p>不过，在<a href="https://www.bandbbs.cn/" target="_blank" rel="noopener">米坛</a>这个网站我找到了真正意义上自定义表盘的方法，而且<a href="https://amazfitwatchfaces.com/" target="_blank" rel="noopener">amazfitwatchfaces</a>上已经有了相当多的自定义表盘。但是我想要继续使用曾经在Pebble上用的<a href="https://apps.rebble.io/zh_CN/application/529ab1b6d17b5033ba000033" target="_blank" rel="noopener">EVA表盘</a>，发现网上并没有现成资源后我决定自己制作。</p>
<p>简单地说，小米手环4的表盘是由一个<code>json</code>文件控制布局的一系列图片构成的。这个<a href="https://www.bandbbs.cn/threads/533/" target="_blank" rel="noopener">注释版万能json</a>展示了该json文件的形式。将自定义的json文件与资源文件，即要显示的一系列图片，经过<a href="https://geekdoing.com/threads/mb4-resource-pack-unpack.1383/" target="_blank" rel="noopener">MB4 Resource pack/unpack</a>工具打包后就能生成表盘<code>bin</code>文件了。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">"Time": &#123;</span><br><span class="line">    "Hours": &#123;</span><br><span class="line">      "Tens": &#123;</span><br><span class="line">        "X": 70,</span><br><span class="line">        "Y": 10,</span><br><span class="line">        "ImageIndex": 23,</span><br><span class="line">        "ImagesCount": 3</span><br><span class="line">      &#125;,</span><br><span class="line">      "Ones": &#123;</span><br><span class="line">        "X": 70,</span><br><span class="line">        "Y": 60,</span><br><span class="line">        "ImageIndex": 11,</span><br><span class="line">        "ImagesCount": 10</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>以这段json代码为例，它控制表盘中时间部分的小时显示。</p>
<p>X和Y是图片左上角的坐标。这里的<code>ImageIndex</code>是指资源图片的起始编号，是其4位数字的文件名。而<code>ImageCount</code>是从起始图片开始向后有多少张图片被此处使用。由于是24小时制——12小时制也许也可以，但我不知道如何设置——小时需要用到表示<code>0</code>、<code>1</code>、<code>2</code>的3张图片。需要注意的是，资源图片的编号必须从<code>0000</code>开始连续，且所有的图片都要在json中被使用到，否则无法正常生成。</p>
<p>最后的效果：</p>
<p><img src="https://i.loli.net/2020/01/12/lPeLST9Rt4iHQr7.gif" alt=""></p>
<blockquote>
<p>发布地址：<br><a href="https://amazfitwatchfaces.com/mi-band-4/view/11723" target="_blank" rel="noopener">amazfitwatchfaces</a><br><a href="https://github.com/Macyrate/EVA_font_watchface" target="_blank" rel="noopener">GitHub</a><br><a href="http://watchface.pingx.tech/h5/#/pages/detail/detail?id=1058400" target="_blank" rel="noopener">米坛</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>HustBase完成</title>
    <url>/2020/01/05/HustBase%E5%AE%8C%E6%88%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="https://i.loli.net/2020/01/24/PgJko6yGmOHnYqW.png" alt="HustBase结构"></p>
<p>经过一个月的胡乱操作，这个数据库总算是按照预期地跑了起来。</p>
<h1 id="主要工作"><a href="#主要工作" class="headerlink" title="主要工作"></a>主要工作</h1><ol>
<li>提供了数据定义功能：定义数据库、系统表、数据表、索引。</li>
<li>提供了数据库操作功能：创建、打开、关闭、删除数据库。</li>
<li>提供了数据表操作功能：创建、删除数据表。</li>
<li>提供了索引操作功能：（部分）创建、删除索引。</li>
<li>提供了按条件记录操作功能：插入、修改、删除数据表中的记录。</li>
<li>为查询模块提供部分语义分析功能。</li>
<li>编写部分用户界面模块功能。</li>
</ol>
<h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>编写模块的过程中，主要出现了以下几个问题：</p>
<ol>
<li><p>对MFC、Windows API的不熟悉</p>
<p> MFC实在是极其古老的东西，可以说早就停止支持，但本沿袭了十年的工程中仍然大量使用，尤其是HustBase.cpp中不得不使用。关于MFC的文档缺乏系统性和本地化，阅读起来较为困难。</p>
<p> 如今的Windows开发基本上是用.NET Framework和C#进行的，C++的实现非常佶屈聱牙，仅仅是启动一个选择路径的窗口就要耗去一整天时间搜集资料。类似的过程，加上对C++遗忘较多，让我在开发初期花费了大量时间。</p>
</li>
</ol>
<a id="more"></a>

<ol start="2">
<li><p>稳健性的缺失</p>
<p> 数据库管理系统需要考虑的东西是比较多的，各种奇怪的情况层出不穷，这就需要在编程之前充分考虑。另外由于C++语言本身既有严格性又有不安全性，导致许多细小而严重的错误难以被快速检出，造成匪夷所思的执行结果。这也引发了最严重的下一个问题。</p>
</li>
<li><p>内存分配的错误</p>
<p> 在对系统管理模块进行的测试过程中，我们常常遇到极为“神秘”的问题：所有的功能都能按照预期实现，但在一个随机的时间节点，或是对<code>RM_FileScan*</code>等进行free操作时会引发“堆损坏”错误，即<strong>HEAP CORRUPTION DETECTED</strong>。</p>
<p> 一开始我以为这是HustBase框架本身的问题，因为任务书中指定的开发环境应为VS2010，而我使用的是VS2019。但其他同样使用VS2019进行开发的小组并没有出现同样问题，于是我们认为这是由某处访问越界造成的，尤其是早期版本中我使用了大量的<code>memcpy( )</code>函数，这很容易造成访问越界。但当我逐渐用<code>strcpy( )</code>或严谨的指针操作取代<code>memcpy( )</code>，并且对所有写内存操作进行检查后，该问题仍然存在。</p>
<p> 最后我们发现，这个问题出现在内存分配时：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FileScan = (RM_FileScan*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(FileScan));</span><br></pre></td></tr></table></figure>

<p> 在<code>sizeof( )</code>中，我错误地填写了<code>FileScan</code>，而非其作为指针指向的<code>RM_FileScan</code>结构体。因此，这一语句为指针分配了一个指针本身长度的内存空间，即4字节。但后面我将一个结构体填入了这块内存空间，这造成了越界。</p>
<p> 由于对<code>FileScan</code>的内存分配几乎在系统管理模块的每个功能函数中都需要使用，这才使无论使用什么功能，都会随机出现该错误。对内存进行操作时，看清楚自己在写什么东西太重要了！</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次综合能力培养实验时间跨度较长，任务较为复杂繁重。</p>
<p>实验开始时，我们野心勃勃，觉得数据库很简单，特别是由于已经有了较为全面的代码框架，我们认为可能只需要一两个“良好的夜晚”就能实现大部分功能。但显然这是不现实的，实际的开发过程远比想象中“痛苦”。分小组开发的方式让我进一步熟悉了使用Git进行协作的流程，也让我体会到了何谓“1 + 1 &lt; 2”。组员<a href="https://github.com/LLGZONE" target="_blank" rel="noopener">LLGZONE</a>由于还有实习工作在身，压力更是巨大，这使得我们的工作进度常常难以对接。</p>
<p>最终我们度过了艰难的一个月，开发出了一个具有一定“鲁棒性”，但功能还不太完善，没有多表连接查询，也没有完善地接入索引的数据库管理系统。好歹，It works，我们看这是好的，并且没有任何坏处。</p>
<p>这次我们没有使用GitHub，而是使用了国内的Gitee码云进行版本控制，由此也感受到了“另一种选择”——其用户体验确实非常良好。</p>
<p>总之，这里应该引用Linus Torvalds所说的名言：</p>
<p><strong>（* 咏 唱 开 始 *）</strong></p>
<p><img src="https://i.loli.net/2020/01/24/DtoulHzyZFSndYg.png" alt="Linus名言"></p>
<p>所以，如果以后数据库综合能力培养实验还要做下去，并且想要做得好，请不要再使用目前沿用了十年的MFC代码框架了。</p>
<h1 id="梦想封印-Enterprise-v0-0-1-alpha"><a href="#梦想封印-Enterprise-v0-0-1-alpha" class="headerlink" title="梦想封印 Enterprise v0.0.1-alpha"></a>梦想封印 Enterprise v0.0.1-alpha</h1><p><img src="https://i.loli.net/2020/01/24/tg3QhfeB9cOGaHz.jpg" alt="HustBaseScreenshot.jpg"></p>
<p>基于<code>HustBase</code>的<del>大型民用</del>数据库管理系统<code>梦想封印 Enterprise</code>的第1个技术预览发行版。</p>
<p> <strong>注意：</strong> </p>
<p>此版本尚不支持有条件多表查询和索引操作。</p>
<p><a href="https://github.com/Macyrate/hustbase/releases" target="_blank" rel="noopener">Release(GitHub)</a></p>
<p><a href="https://gitee.com/strangenamebc/hustbase/releases" target="_blank" rel="noopener">Release(Gitee)</a></p>
]]></content>
      <tags>
        <tag>Cpp</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>从C++里的一大堆字符串说起</title>
    <url>/2019/12/30/%E4%BB%8EC-%E9%87%8C%E7%9A%84%E4%B8%80%E5%A4%A7%E5%A0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%B4%E8%B5%B7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>写数据库管理系统时遇到了不少关于C++字符串的问题，要命的是C++的字符串种类实在是太多了，今天试着搜集一些资料总结一下。</p>
<h1 id="char-foo-bar-和-char-foo"><a href="#char-foo-bar-和-char-foo" class="headerlink" title="char foo[bar] 和 char* foo"></a>char foo[bar] 和 char* foo</h1><p><code>char foo[bar]</code>这种形式被称为“C风格字符串”，它是从C语言中流传下来的。它实际上完全就是char型的数组，只是你可以用这样的方式来给它赋值，看上去比较像“字符串”：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这两行都定义了相同的字符串"Hello"</span></span><br><span class="line"><span class="keyword">char</span> foo1[] = <span class="string">"Hello"</span>;      <span class="comment">//末尾有隐藏的'\0'</span></span><br><span class="line"><span class="keyword">char</span> foo2[<span class="number">6</span>] = &#123;<span class="string">'H'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'\0'</span>&#125;;</span><br></pre></td></tr></table></figure>

<p><code>char* foo</code>是声明了一个字符指针，指向单个字符，可以将其当作以<code>&#39;\0&#39;</code>为末尾的字符串的首字符地址。如果要把字符串赋给它，需要先申请内存空间，再使用<code>memcpy()</code>或<code>strcpy()</code>。当然，也可以不分配空间，直接用<strong>十分危险的指针赋值</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* foo1 = (<span class="keyword">char</span>*)<span class="built_in">calloc</span>(<span class="number">6</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="built_in">strcpy</span>(foo1, <span class="string">"Hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* foo2 = <span class="string">"Hello"</span>;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h1 id="CString"><a href="#CString" class="headerlink" title="CString"></a>CString</h1><p><code>CString</code>是<code>MFC</code>的类，使用它需要包含<code>afx.h</code>。</p>
<p><strong>什么是MFC？</strong></p>
<blockquote>
<p>微软基础类库（英语：<strong>M</strong>icrosoft <strong>F</strong>oundation <strong>C</strong>lasses，简称<strong>MFC</strong>）是一个微软公司提供的类库（class libraries），以C++类的形式封装了Windows API，并且包含一个（也是微软产品的唯一一个）应用程序框架，以减少应用程序开发人员的工作量。其中包含的类包含大量Windows句柄封装类和很多Windows的内建控件和组件的封装类。</p>
</blockquote>
<p>总之，作为Visual C++的一部分，这是一个上古遗留之物。不愧是十年前的课设……</p>
<p>CString是MFC中最常用的字符串类。其数据成员只有一个，那就是字符串在内存中的起始地址。它还有许多方法，如多种构造函数、用于连接和比较的运算符重载、用于格式化的<code>Format</code>，以及各种用于对字符串进行替换、查找、删除的方法。这个类将C++中极为复杂、包含大量内存操作的字符串操作简化了不少。</p>
<h1 id="string"><a href="#string" class="headerlink" title="string"></a>string</h1><p>string之前一直弄不太明白。这明明是每个语言都应该有的基本东西，但是鉴于C和C++之间乱七八糟的关系以及错综复杂的各种标准，就连这种“基本”也轮廓模糊到让人难以提起兴趣探索。</p>
<p>需要知道的是，<strong>string是C++标准库中的类。</strong>确切地说，string类定义于C++标准库的<code>&lt;string&gt;</code>头文件。</p>
<p>关键的问题是，什么是<a href="https://zh.cppreference.com/w/cpp/header" target="_blank" rel="noopener">C++标准库</a>？这个名字很容易和标准模板库（Standard Template Libraries, STL）混淆，但实际上它们最开始是不同的东西。C++被标准化最早是1998年的<code>ISO/IEC 14882:1998</code>，即所谓的C++98。而STL始于C++尚未被标准化的1993年，它很大程度上影响了几年后C++标准中标准库的制定，因此其内容与C++标准库有非常大的重合。但需要注意的是，<strong>STL不完全是C++标准库的一部分</strong>，C++标准里也从来没有“STL”这一说法。C++标准库中的“STL”可以说是STL的一个“Fork”。</p>
<p>C++标准库包含一系列不带<code>.h</code>后缀的头文件，用尖括号引用。其中除宏定义以外的内容包含在名称空间<code>std</code>中，这也是许多C++程序都有一句<code>using namespace std;</code>的原因。</p>
<p>这是<a href="https://en.cppreference.com/w/cpp/algorithm/qsort" target="_blank" rel="noopener">cppreference</a>上对<code>std::qsort</code>的一段示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     //C++输入/输出流标准头文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;      //C++标准库中来自C标准库的部分，去掉.h并在前面加c</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;      //同上</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">-2</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="number">-743</span>, <span class="number">2</span>, INT_MIN, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> size = <span class="keyword">sizeof</span> a / <span class="keyword">sizeof</span> *a;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::qsort(a, size, <span class="keyword">sizeof</span> *a, [](<span class="keyword">const</span> <span class="keyword">void</span>* a, <span class="keyword">const</span> <span class="keyword">void</span>* b)     <span class="comment">//指定名称空间std</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> arg1 = *<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span>*&gt;(a);</span><br><span class="line">        <span class="keyword">int</span> arg2 = *<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">int</span>*&gt;(b);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(arg1 &lt; arg2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arg1 &gt; arg2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//  return (arg1 &gt; arg2) - (arg1 &lt; arg2); // possible shortcut</span></span><br><span class="line">    <span class="comment">//  return arg1 - arg2; // erroneous shortcut (fails if INT_MIN is present)</span></span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ai : a)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ai &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="LPSTR，以及各种乱七八糟的"><a href="#LPSTR，以及各种乱七八糟的" class="headerlink" title="LPSTR，以及各种乱七八糟的"></a>LPSTR，以及各种乱七八糟的</h1><p>这就是较为难以理解的东西了，名字让人一头雾水。<code>LPSTR</code>算是最简单的形式，还有什么<code>LPCTSTR</code>,<code>PCTSTR</code>等等，这都是些啥？</p>
<p>其实这些全大写的神秘数据类型依然来自MFC，它们都是Windows特色数据类型。STR显然代表的是字符串，重要的是它们的前缀。</p>
<p>前缀中主要包含这么几个字母：</p>
<ul>
<li>LP：长指针Long Pointer，代表这是一个32位指针。说是Long是因为上古Windows中的Pointer还是16位。</li>
<li>C：常量Const，代表这是一个常量。</li>
<li>T：代表使用<code>_T</code>宏，这个宏是用于动态支持Unicode这样的宽字节编码（即用多个字节代表一个字符）的。如果Unicode有定义，那么带T前缀的字符串就是Unicode编码的，否则依然是窄字节编码ANSI。</li>
<li>W：宽Wide，代表使用宽字节编码，如Unicode。</li>
</ul>
<p>此外，MFC中还有神秘的<code>BYTE</code>、<code>WORD</code>、<code>DWORD</code>，其实就是分别对应<code>unsigned char</code>、<code>unsigned short</code>、<code>unsigned long</code>。</p>
<blockquote>
<p>关于ANSI和Unicode，另外再开一篇文章讲好了。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Cpp</tag>
        <tag>数据结构</tag>
        <tag>考古</tag>
        <tag>标准</tag>
      </tags>
  </entry>
  <entry>
    <title>191226</title>
    <url>/2019/12/26/191226/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>冬至已经过了好几天，这次我没能在节气当天写随笔了——也许是一个危险的信号，象征着“持之以恒”依然不存在于我的字典中？</p>
<p>近期在做本科阶段最后的课程设计：综合能力培养。选择的是数据库方向（这算是几个月前“大数据开发”的历史遗留），三人一组用C++编写一个数据库系统。C++对我几乎是“未曾设想的道路”了。</p>
<p>啊，思绪繁杂。不过既然叫随笔，也不该讲求甚么“章法”，就依照“随笔”其名，想一出是一出地写吧。</p>
<p>首先还是在做数据库系统时遇到了海量的问题。这回是不怎么能“倚靠大佬”，相互借鉴交融并包了，所以基本上除了在一筹莫展时从GitHub上稍微看看往届学长的思路之外，都是自己老老实实写出来的东西。这个时候就能体现出“亲力亲为”太少的问题了，功夫是真的不行：一天可能摸不出50行代码，而且逻辑混乱，调试痛苦，维护困难。要说这水平是大二时候的我，倒也勉强可以接受，但是大学四年差不多就剩一个学期了，就连差强人意都算不上。</p>
<blockquote>
<p>“我并不想变强，也并不想解决问题，只是想表达自己并非坐以待毙，想表达自己在努力，只是摆出这样一个明显的姿态将自己正当化。我想说自己没办法，我想说自己束手无策，只是为了放弃，我才会做出拼命努力的表象……”<br>——《Re：从零开始的异世界生活》 第18话</p>
</blockquote>
<p>这是我觉得十分危险的一种状态，这段话也时常被我用来反省。实际上这几个月，乃至这几年我还真有点这个意思，表面看起来并不算是“堕落”，却也说不上是在真正“努力”。</p>
<p>努力……难道人必须要努力才能存在吗？显然不是，往往带恶人活得同样滋润。</p>
<p>成年以后，年龄似乎就失去了意义，特别是知识爆炸的这个年代。我们往往把自己与年长自己许多岁的人，或者同龄人中抛头露脸的最顶尖的那一小撮进行比较，然后得出自己一无是处的结论。也许这结论有一半是真，但另一半大抵是十余年“挫折教育”的延续。</p>
<p>内卷，内卷，依然是内卷——东亚几乎要在这梦魇下失去未来。如今不会有人幻想“皇帝的金锄头”，天国和地狱一样空空荡荡，因它们都降临到了地上。成功了的人总是相似，仰视他们的人则各有各的痛处，并且知道自己几乎不可摆脱。些许人已经淡漠，但多数人仍要挣扎，他们的结果并没有太大不同。</p>
<p>我憎恶冬天。冬天总是阴云密布的，却总不下雨——下雨亦是一阵寒过一阵。偶然见了太阳，也是如同吸干了血的尸体，连同被这阳光照射的人物，都成了干尸了。寒冷麻痹思考，逐渐放弃思考。</p>
<p>极简。极简并非以致无欲。与其说是降低饱和度，不如说是增高对比度。</p>
<p>小小寰球。“我们并不孤独。”让我在天文台倒下！</p>
<blockquote>
<p>己亥腊月朔日。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity异步场景加载</title>
    <url>/2019/12/15/Unity%E5%BC%82%E6%AD%A5%E5%9C%BA%E6%99%AF%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在游戏中，场景加载是很常用的功能。如果要在加载的时候让当前的场景还能正常运行，或者加载时能有一个包含进度条之类组件的加载界面，就应该采取异步的场景加载方式。</p>
<h1 id="同步加载"><a href="#同步加载" class="headerlink" title="同步加载"></a>同步加载</h1><p>在讲异步加载以前，先说同步加载。</p>
<p>当执行同步加载时，正在运行的场景会被阻塞，产生卡顿，这种方法适合小型的、不怎么需要获取读取进度的场景的加载。如在地牢中切换到另一个房间，读取完成之前当前房间中的一切都静止不动，这种情况应该是用同步加载实现的。</p>
<p>Unity使用<code>SceneManager</code>类的静态方法<a href="https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadScene.html" target="_blank" rel="noopener">LoadScene</a>实现同步的场景加载。由于是静态方法，不需要对<code>SceneManager</code>类进行实例化，只要使用命名空间<code>using UnityEngine.SceneManagement;</code>就可直接通过<code>SceneManager.LoadSceneAsync</code>访问。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法原型：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadScene</span>(<span class="params"><span class="keyword">int</span> sceneBuildIndex, SceneManagement.LoadSceneMode mode = LoadSceneMode.Single</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadScene</span>(<span class="params"><span class="keyword">string</span> sceneName, SceneManagement.LoadSceneMode mode = LoadSceneMode.Single</span>)</span>;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>其中，第一个参数可以是场景的编号<code>sceneBuildIndex</code>，也可以是场景的名称<code>sceneName</code>。</p>
<div class="note info">
            <p><strong>什么是场景编号？</strong></p><p>场景编号是工程中每个场景唯一的<code>int</code>型编号，记录在Unity的<code>File-&gt;Build Settings-&gt;Scenes in Build</code>中。如果没有看到你想要的场景，可以通过Build Settings中的<code>Add Open Scenes</code>加入场景。</p>
          </div>

<p>第二个参数所说的<code>LoadSceneMode</code>是一个枚举类，包含<code>Addtive</code>和<code>Single</code>两种加载方法。前者是在保留当前场景的基础上加载其他场景，如果是临时打开一个全屏的设置界面，就可以使用这种加载方式；而后者在加载完新场景之后就不保留原来的场景，适合进行关卡的切换等。</p>
<h1 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h1><p>异步加载和同步加载大同小异，但是它通过C#的“协程”使得加载过程看起来是在后台运行。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法原型：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncOperation <span class="title">LoadSceneAsync</span>(<span class="params"><span class="keyword">string</span> sceneName, SceneManagement.LoadSceneMode mode = LoadSceneMode.Single</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncOperation <span class="title">LoadSceneAsync</span>(<span class="params"><span class="keyword">int</span> sceneBuildIndex, SceneManagement.LoadSceneMode mode = LoadSceneMode.Single</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncOperation <span class="title">LoadSceneAsync</span>(<span class="params"><span class="keyword">string</span> sceneName, SceneManagement.LoadSceneParameters parameters</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncOperation <span class="title">LoadSceneAsync</span>(<span class="params"><span class="keyword">int</span> sceneBuildIndex, SceneManagement.LoadSceneParameters parameters</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>方法原型与同步加载非常相似，方法名也只是加了一个“Async”。但最大的不同是，<code>LoadSceneAsync</code>返回的是一个<code>AsyncOperation</code>类对象，用于对后台的加载过程进行监测，其中有一个比较有意思的<code>bool</code>型属性<code>allowSceneActivation</code>，如果将其设置为<code>false</code>，加载进度<code>public float progress</code>会在0.9处暂停，直到将<code>allowSceneActivation</code>设置为<code>true</code>时再继续加载剩下的10%。</p>
<p>需要注意，<strong>Unity并不支持多线程</strong>，这里使用的协程实际上是一种Unity主线程上的伪线程。在VS的线程调试窗口里也可以看到协程启动后其实仍然在原来的线程里，<strong>我认为</strong>它大概和传说中的<strong>纤程</strong>就是一种东西，而后面的几个工作线程应当是C#的CLR开辟的。</p>
<p><img src="https://i.loli.net/2020/01/12/YavnLJtRl5qicGF.png" alt="纤程？"></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//这里给出一个简单的例子：</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">AsyncLoading</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> return new <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">3</span></span>)</span>;     <span class="comment">//加载太快了，先播上3s的加载动画</span></span><br><span class="line">    operation = SceneManager.LoadSceneAsync(<span class="string">"StartMenuScene"</span>, mode: LoadSceneMode.Single);</span><br><span class="line">    <span class="keyword">while</span> (!operation.isDone)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(operation.progress);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadScene.html" target="_blank" rel="noopener">Unity - SceneManager.LoadScene</a></li>
<li><a href="https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html" target="_blank" rel="noopener">Unity - SceneManager.LoadSceneAsync</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/46859738" target="_blank" rel="noopener">知乎 - Unity 的多线程、协程、纤程</a> </li>
<li><a href="https://blog.csdn.net/ksgt00629518/article/details/53894892" target="_blank" rel="noopener">CSDN - Unity多线程、线程池的使用</a></li>
<li><a href="https://blog.csdn.net/qq_42462109/article/details/83096135" target="_blank" rel="noopener">CSDN - Unity异步加载场景SceneManager.LoadSceneAsync与AsyncOperation的使用</a></li>
</ol>
<blockquote>
<p>虽然是个很简单的需求，但是涉及的东西不少也不简单，我至今也没完全搞明白……</p>
</blockquote>
]]></content>
      <tags>
        <tag>Unity</tag>
        <tag>C Sharp</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>191207</title>
    <url>/2019/12/07/191207/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>12月4日中午，腾讯代理的国行版Nintendo Switch发布，这也是我所一直等待的。</p>
<p>果不其然，锁服不锁区，eshop只能用国服，外区游戏能用实体卡但无法联机，并没能在索尼和微软之上更进一步，和当年的神游相比倒是略有放开。</p>
<p>虽然将来可能会爆出“后门”，但没个一年半载很难说。对我而言，虽然错过了双十一和黑五，但已经没有再等下去的必要了。未来的游戏从业者没有一台本世代的家用机，成何体统？于是当天下午，就以1888+310元的价格入手了日版续航增强Switch以及《宝可梦 剑》。</p>
<p><img src="https://i.loli.net/2020/01/12/M2IrfnixCdL4TRj.jpg" alt="Switch开箱"></p>
<p>其实本来准备遵照传统从荒野之息开始，奈何店主没有，就买了宝可梦。说起来，虽然“神奇宝贝、宠物小精灵、口袋妖怪、精灵宝可梦”地过了这么多年，我却没有完整通关过任何一作，也算是童年一桩憾事。去年买到NDSL之后，也有一小段时间曾试着玩过著名的同人作品《口袋妖怪 漆黑的魅影》，不过也只打过两个道馆，然后就去《大航海时代》里开船了。因此，这次从拿到卡带的第一刻起，我就开始了近乎废寝忘食的攻略。</p>
<p><img src="https://i.loli.net/2020/01/12/qnLSlNHK9fYB1Jj.jpg" alt="漆黑的魅影 剑"></p>
<a id="more"></a>

<p><img src="https://i.loli.net/2020/01/12/dI5v27siMfJt6Uz.jpg" alt="馆主"></p>
<p>三天时间里，我屡次错过饭点，两回凌晨三点才放下手柄，洗漱也是草草了事。每到一个新的地点，我就迫不及待去寻找时装店，在试衣间反复横跳试图弄出好看的搭配；我骑着自行车在旷野游荡，向训练家们掠夺食材；道馆挑战中期，某位仁兄用“魔法交换”送来Lv60的铜镜怪，让我顺风顺水地打过妖精和岩石道馆；草路镇外的麦田里间，我不知吹了多少次口哨，才得以遇到一只皮卡丘；极巨化团体战里，我带着波克基斯在一众大佬的无极汰那、苍响、藏玛然特之间瑟瑟发抖……</p>
<p><img src="https://i.loli.net/2020/01/12/NITFwGcpgqt8YOl.jpg" alt="伽勒尔的黎明"></p>
<p>据说这一作砍掉了不少东西，以至于让许多老玩家感到不满，但倒是很适合我这个宝可梦初心者。与“剑/盾”好像没啥关系的小学生作文剧情也可以说是“平平淡淡才是真”——毕竟露璃娜才是本作的精髓（不）。也许玩过六七世代之后我会觉得剑盾是什么“臭鱼烂虾”，但是在这几天里，我玩得确实很开心。</p>
<p>最终，我也有了自己的苍响：</p>
<p><img src="https://i.loli.net/2020/01/12/IZCwoyAxi4R8ua7.jpg" alt="苍响"></p>
<p><strong>真有你的啊，游戏富力克！</strong></p>
<p>花了可能有三十个小时，我终于完全通关了《宝可梦 剑》。本来在今天凌晨这一“壮举”就已经完成，白天我应该再次投入到紧张的工作学习中去，毕竟我现在也没有其他卡带了……但是Nintendo Online会员的FC游戏合集又吸引了我，许多古老的经典游戏现在可以方便地“鉴赏”了。</p>
<p>作为姑且算是的STG玩家，首先游玩的就是早已多次听闻的《太空巡航机》（Gradius）。一开始真是没整明白它的武器升级系统，用单发子弹打到一面后半段，上中下全方位围追堵截，差点直接把我劝退。弄懂了系统之后，这30年前的游戏玩起来也是爽快得很。掉残就武器清空的设计依然不太亲民，好在如今有即时存档，乃至TAS般的“时间倒流”功能，不大功夫我就成功通关。</p>
<p><img src="https://i.loli.net/2020/01/12/xj4VoHQew68MtEd.jpg" alt="太空巡航机"></p>
<p>可是这玩意它果然不止有一周目。在打过难度有所提高的二周目之后，面对逐渐丧心病狂的三周目，我果断选择了存档退出——再打下去恐怕该是无尽模式了。之后又了解到原来它的续作就是如雷贯耳的《沙罗曼蛇》，难怪感觉自机的形态十分相似。</p>
<p>接下来就是《双截龙2》，我曾玩过GameBoy版本的《双截龙》，当时就感到颇有难度，主要是出招十分玄学，打击感也不是那么好。这次玩2代，打人倒是感觉简单了些，可是后期各种地形杀和卡位简直恶心至极，第六关的一大堆跳台让我无数次落命，一气之下Quit。</p>
<p>然后是从i wanna和FGO知道的，要人命的《魔界村》。这里我没有注意说明，点开了摆在最上面的一个，谁知它竟然是直接从第六关开始的版本，游戏一开始我还没意识到自己在哪就暴毙了。试了几次果断退出，然后看到了下面的“正常”版本——正常个鬼啊！还是那么的难，我连第一关都过不了，不过多少了解了操作方法。于是我再次作死地进入第六关，千辛万苦上了两层楼，然后被卡死在一条被我打得只剩个头，却怎么也打不死的龙那里。这龙四处乱飞，判定奇大，一挨就死，我使出浑身解数操纵这个愚笨的骑士闪转腾挪，始终还是化作了一具沙雕的骷髅。</p>
<p>那就来点相对亲民的吧，《忍者龙剑传》。初次玩到这个游戏还是在小学的时候，大抵当初接触的是FC忍龙2，我就记得那个标志性的橙红色手里剑图标了。忍龙不愧为FC动作游戏楷模，手感真的是好，打谁都是一刀可太忍者了。唯一令我难受的就是那个抓墙跳，只能抓住却不能攀爬，判定也很是神秘，这一点都不蔚蓝！</p>
<p>忍龙的电影式过场动画在FC时代也是一大特色。我玩的时候字幕蹦得比较快，而且受限于分辨率，笔划稍多的汉字都代以假名，我只能读个半懂不懂。前面的几关虽然略有难度，但比起刚刚体验过的《魔界村》实在是不值一提，许多次我其实是因为爬墙不熟练让时间耗尽而失败。</p>
<p>可是，在爬上这座山之后，一切都变了！</p>
<p><img src="https://i.loli.net/2020/01/12/EomCKcdkyxGagJ2.jpg" alt="忍者龙剑传"></p>
<p>我从来没有像今天这样憎恨鸟！这些鸟正如魔界村的那条该死的龙，绕着曲线来撞你，一下就是两格血，跟挨了一发炮弹一样。要命的是，往往是面前一个端着蓝火加特林的士兵，前后钻出两只豹子，墙头还站着一个丢十字架的迷之牧师，手忙脚乱之际，两只鸟从天而降，你唯一能做的就是乱打一气，交给天命。</p>
<p>在可能有上千次的“时间倒流”之后，我还是卡在了放闪电的BOSS那里。蹲也好跳也好，电球总是以超高速追踪的形式命中，就连《只狼》里的雷电奉还也使不出来。不查攻略，我是想不到该怎样打了，而且我也不愿再回档了，就留到以后吧。</p>
<p>“鉴赏”了这么些FC游戏之后，我意识到它们之所以难，大抵是因为FC的游戏从街机演化，而街机的第一目的就是尽可能多且快地从玩家那里抢夺硬币。这样的设计理念实在是相当罪恶，对于普通玩家而言，这不过是较为精美的“贪玩蓝月”罢了——在用充钱带给人快乐这方面，甚至还不如贪玩蓝月。</p>
<p>写了这么多，明天可真的该再次投入到紧张的工作学习中去了。</p>
<blockquote>
<p>己亥大雪。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>游戏</tag>
        <tag>任天堂</tag>
      </tags>
  </entry>
  <entry>
    <title>Aseprite和Photoshop入门成果</title>
    <url>/2019/12/03/Aseprite%E5%92%8CPhotoshop%E5%85%A5%E9%97%A8%E6%88%90%E6%9E%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>由于准备solo操作，美工大部分就得自己搞定了。</p>
<h1 id="Aseprite"><a href="#Aseprite" class="headerlink" title="Aseprite"></a>Aseprite</h1><p>Pixel Art其实很早就想玩一玩，不过之前一直没有找到合适的工具。如今因为要做游戏的任务驱动，终于开始尝试了。也因此，认真搜索资料之下就知道了<code>Aseprite</code>这个🐂🍺到爆炸的像素画制作软件，Steam售价38元，非常划算。</p>
<iframe src="https://store.steampowered.com/widget/431730/" frameborder="0" width="646" height="190"></iframe>

<p>我学习的是Youtube上MortMort这位小哥的教学视频，讲得非常清晰：</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/videoseries?list=PLR3Ra9cf8aV06i2jKmgKvcYVHI86-4K_b" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p>如果没有代理，可以在bilibili观看该系列视频的<a href="https://www.bilibili.com/video/av14603015" target="_blank" rel="noopener">第一部分</a>：</p>
<iframe src="//player.bilibili.com/player.html?aid=14603015&cid=23810173&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>这是我在还没有看教学视频之前，自己胡乱尝试下摸索了将近一整天完成的<a href="https://www.pixiv.net/artworks/78095634" target="_blank" rel="noopener">第一幅作品</a>：</p>
<p><img src="https://i.loli.net/2020/01/12/rWmnCw9V1uBeDH6.gif" alt="youmu"></p>
<a id="more"></a>

<p>虽然看起来比较憨憨，但是基本上熟悉了Aseprita的大部分功能。甚至，还进了Pixiv动图日榜？（说明一天根本没几张动图投稿嘛）</p>
<p><img src="https://i.loli.net/2020/01/12/SCUkuMRXxmgA5Yz.png" alt="进了排行榜？"></p>
<p>最大的感受就是，和制作了《幻想乡萃夜祭》的<a href="https://www.pixiv.net/member.php?id=205166" target="_blank" rel="noopener">煮茶</a>julao相比，我画的就是个🔨！这种像素数少的画反而极其考验抽象思维能力和绘画功底，因为每一个像素都有其表现作用。如果精打细算充分利用的话，完全可以在极为有限的像素中表现出大量的细节，令人赏心悦目：</p>
<p><img src="https://i.loli.net/2020/01/12/vmK8GTFi9q2QkVj.png" alt="煮茶NB！"></p>
<p>不过，我暂且还是程序员，不是专业像素艺术家，这边的技能树还是慢慢点吧……</p>
<h1 id="Photoshop"><a href="#Photoshop" class="headerlink" title="Photoshop"></a>Photoshop</h1><p>Photoshop可谓是博大精深，我目前仅仅学习了PS CC自带的教程，能把它当作Windows画图高级版使用了……</p>
<p>这是今晚试着作出的東方project传统艺能启动页面：</p>
<p><img src="https://i.loli.net/2020/01/12/u4XcFYiphUo8WS9.png" alt="启动页面"></p>
<p>其中使用的字体<code>汉仪昌黎宋刻本(原版)W</code>和<code>Mithril</code>来自<a href="http://www.hanyi.com.cn/font-list" target="_blank" rel="noopener">汉仪字库</a>，汉仪确实是个非常nice的厂。</p>
<p>说到字体，就还有一个不错的网站：<a href="https://www.likefont.com/" target="_blank" rel="noopener">识字体 - www.likefont.com</a>，顾名思义这就是个用图片识别字体的网站，准确度相当高。</p>
<p>那么明天试着把<code>少女祈祷中</code>弄上，再去Unity里做个游戏主界面？有了主界面怎能没有音乐……？得想法子整个活，把<code>623532 623532 623532 7175</code>的ZUN节传统艺能搞起来。</p>
<blockquote>
<p>所以说这一个星期我也太摸了吧……</p>
</blockquote>
]]></content>
      <tags>
        <tag>动画</tag>
        <tag>游戏</tag>
        <tag>图像</tag>
      </tags>
  </entry>
  <entry>
    <title>为Hexo博客添加全局APlayer播放器</title>
    <url>/2019/11/25/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80APlayer%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>如果你只是想要在自己站点的左下角加一个极其Stable的音乐播放器，而不想听我废话自己踩的坑，请直接跳转：<br><a href="/2019/11/25/为Hexo博客添加全局APlayer播放器/#Show-me-the-CODE">“Show me the CODE!”</a></p>
          </div>

<h1 id="早期尝试"><a href="#早期尝试" class="headerlink" title="早期尝试"></a>早期尝试</h1><h2 id="网易云iframe"><a href="#网易云iframe" class="headerlink" title="网易云iframe"></a>网易云iframe</h2><p>今天，我试图解决一个历史遗留问题。</p>
<p>之前我博客上的音乐播放器一直都是网易云的外链iframe，就这个样式的：</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1384318412&auto=0&height=66"></iframe>

<p>我一直把这个玩意放在sidebar里。但是问题是，移动版视图下sidebar是不展示的，只有header能够显示出来，而且还需要用toggle展开。我使用的主题是<code>NexT</code>，试验了一下，需要修改的地方是：</p>
<p><code>\themes\next\layout\_partials\header\index.swig</code></p>
<p>由于toggle展开的是<code>site-nav</code>，将源码修改如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; partial('_partials/header/brand.swig', &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"site-nav"</span>&gt;</span></span><br><span class="line">  &#123;&#123; partial('_partials/header/menu.swig', &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;</span><br><span class="line">  <span class="comment">&lt;!--网易云iframe--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">"//music.163.com/outchain/player?type=2&amp;id=1384318412&amp;auto=0&amp;height=66"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--网易云iframe end--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;%- if theme.algolia_search.enable or theme.local_search.enable %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"site-search"</span>&gt;</span></span><br><span class="line">    &#123;&#123; partial('_partials/search/index.swig', &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;- next_inject('header') &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/01/12/Dmhzxi8XFIQK7np.jpg" alt="site-nav中的iframe.jpg"></p>
<p>这个效果属实🍔🍔。并且在桌面版视图下还会把sidebar压下去，不太理想。</p>
<a id="more"></a>

<h2 id="明月浩空音乐"><a href="#明月浩空音乐" class="headerlink" title="明月浩空音乐"></a>明月浩空音乐</h2><p>有没有悬浮式的播放器呢？有的。随便查一查就看到了这篇文章：<a href="https://leafjame.github.io/posts/2636059693.html" target="_blank" rel="noopener">一款炫丽的网页播放器插件</a>，这里介绍了<code>绚丽彩虹播放器</code>，确实是够绚丽的，点进去一看还是个东方二次元，连域名都叫<code>badapple.top</code>，爱了。</p>
<p>一阵操作之后，预览的效果确实挺理想的，可是到我网站上就只能播放第一首曲子了，和上面那篇文章的评论区里一位老哥说的一模一样：</p>
<p><img src="https://i.loli.net/2020/01/12/Sb8tgk2FZLrnu3i.jpg" alt="出现了绚丽的问题"></p>
<p>在我试图解决这个问题的时候，<code>badapple.top</code>突然就503了，回想起上面最后的更新日期是2018年，我就感到一阵不妙。不一会儿我就发现了和这绚丽播放器几乎<code>完 全 一 致</code>的替代品<a href="https://music.ain19.com/" target="_blank" rel="noopener">AIP播放器</a>，并且找出了前面问题的解决方案。可是，这两个东西相似度怎么能够这么高？？</p>
<p>原来它们都是从<a href="https://player.lmih.cn/" target="_blank" rel="noopener">明月浩空音乐</a>改来的，而这个原版是需要收费的。这明月浩空又是何许人也？传闻其名乃“李明浩”，这里有他不知真假的黑历史：<a href="https://www.chinasuc.cn/?thread-151.htm" target="_blank" rel="noopener">关于Colorful2.6(明月浩空模板)后门剖析</a>。</p>
<p>本来如果我不太在意这个插件的安全性，折腾播放器的经历到这里就应该结束了。可是AIP播放器它不能自由修改主题色，而默认的颜色偏偏还是绿的，强迫症让我不能忍。看了看它的加载方式，是用<code>\theme\next\layout\_layout.swig</code>中插入的JS脚本加载远端服务器上的CSS，JS、CSS、播放列表都在远端，这可没法随便改了。</p>
<p>当然，也许我可以自己写一个CSS（在NexT里用的是Stylus）来覆盖它的设定——可惜我不会。</p>
<p>那咋办嘛，只能再看看有没有其他选择了。如此“简单”的需求难道会没有对应的开源软件吗？</p>
<h1 id="APlayer"><a href="#APlayer" class="headerlink" title="APlayer"></a>APlayer</h1><p>在寻找替代品的过程中，我曾看到过这篇文章：<a href="https://diygod.me/best-players-in-hexo/" target="_blank" rel="noopener">可能是目前最好用的两个 Hexo 播放器插件</a>，讲的是开源的<a href="https://github.com/MoePlayer/hexo-tag-aplayer" target="_blank" rel="noopener">hexo-tag-aplayer</a>，这是一个给hexo使用的<a href="https://github.com/MoePlayer/APlayer" target="_blank" rel="noopener">APlayer</a>。</p>
<p>然而在看了它的文档之后，我没有第一时间get到它的点，特别是不知道要咋用。README.md里关于用法仅有一句：</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">&#123;% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %&#125;</span><br></pre></td></tr></table></figure>

<p>这是个啥？当时我虽然知道Hexo的<code>Tag Plugins</code>，准确地说是NexT带来的<a href="https://theme-next.org/docs/tag-plugins/note" target="_blank" rel="noopener">Bootstrap Callout</a>——不得不说，<code>Tag Plugins</code>这个名字起得真是沙雕，它太容易和<code>tags</code>混淆了——但是我因为没什么机会用到，并没有细看过它的格式，所以也并不明白这<code>{&#37; &#37;}</code>是个什么操作。</p>
<p>现在必须得找其他方法的话，那就只好研究一下了。看了些Issues才搞明白原来是写在md文件里的，这与我的想法背道而驰——我希望能放在所有页面的固定位置，如果能做到网易云音乐网页版那样跳转页面而播放进度不变就再好不过了。</p>
<p>经过一段时间的测试之后，我发现如果使用<code>hexo-tag-aplayer</code>最好的解决方案就是如这个<a href="https://github.com/MoePlayer/hexo-tag-aplayer/issues/58" target="_blank" rel="noopener">issue</a>所言，在md里插入播放器后，再把生成的html文件里对应部分复制到header的<code>index.swig</code>里。可是这不就是个威力加强版的网易云iframe了吗？！</p>
<p>其实如果不是因为另一个问题，也还勉强能用。它的<code>fixed</code>模式（文档里翻译为“固定模式”）总让人感觉不太对劲，播放列表竟然是向上展开，如果放在header里，本来位置就很靠上，向上展开之后有一部分会伸出页面之外。虽然有一个默认值为<code>340px</code>的参数<code>listmaxheight</code>表示播放列表展开的高度，但我将其调为负值时，不但没有变成向下展开，而且还把播放列表倒过来了……</p>
<blockquote><p>当你感到迷惑，就应该去查Issues，大概率会有人和你遇到同样的迷惑问题。</p>
<footer><strong>沃兹·吉硕德</strong></footer></blockquote>

<p>所以我又查到一个<a href="https://github.com/MoePlayer/hexo-tag-aplayer/issues/79" target="_blank" rel="noopener">issue</a>，什么？<code>吸底</code>？这正是我想要的——这说的不就是<strong>原版</strong>APlayer吗？！</p>
<p><img src="https://i.loli.net/2020/01/12/Rm4tpK1sBMrdcyT.jpg" alt="APlayer吸底模式"></p>
<p>在APlayer的文档里，对<code>fixed</code>模式的描述是<code>吸底</code>，这才是我所期望的功能，前面被“固定模式”这个沙雕翻译给整蒙了。那么，原版APlayer又是怎么用的呢？</p>
<p><img src="https://i.loli.net/2020/01/12/CBPWNdEnRqrUoHs.jpg" alt="APlayer入门"></p>
<p>看到这里，我的迷惑更上一层楼，有一定前端知识的人应该很快就能看懂这里在说什么，但是我显然不是……</p>
<p>好在这时看到这篇文章：<a href="https://cloud.tencent.com/developer/article/1157669" target="_blank" rel="noopener">添加全站 APlayer 播放器</a>，看起来把这段代码加到<code>_layout.swig</code>的body里就OK了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aplayer"</span> <span class="attr">data-id</span>=<span class="string">"534542404"</span> <span class="attr">data-server</span>=<span class="string">"netease"</span> <span class="attr">data-type</span>=<span class="string">"song"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是依然不行：</p>
<blockquote>
<p>这里的外部调用链接没有包含版本号，默认加载最新 release 版本；正常来说不会出什么问题，但是如果需要 100% 稳定运行，建议自行加上版本号。</p>
</blockquote>
<p>事后发现这里加载的最新版本MetingJS是<code>2.0.0</code>，但实际上这个版本和APlayer根本不兼容，而MetingJS的文档却给人一种稳得一批的感觉：</p>
<p><img src="https://i.loli.net/2020/01/12/tmUfeSh5KFILic7.jpg" alt="虚假的MetingJS文档"></p>
<p>（都不Supported你贴个啥APLAYER啊！！）</p>
<p>好，那就自己加上版本号。这里从<code>jsDelivr</code>引用了三个文件，APlayer的CSS和JS，Meting的JS。最新的（截至2019年11月25日）稳定版本使用如下，你也可以去<code>jsDelivr</code>自行查找。</p>
<h1 id="Show-me-the-CODE"><a href="#Show-me-the-CODE" class="headerlink" title="Show me the CODE!"></a>Show me the CODE!</h1><p>如果你和我一样使用<code>NexT</code>主题，请复制以下代码，定位到<code>\theme\next\layout\_layout.swig</code>，将其粘贴到body体内即可。如果是其他情况，<strong>大同小异！大同小异！</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引用依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 我使用的APlayer本体 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"aplayer"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-id</span>=<span class="string">"2465890057"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-server</span>=<span class="string">"netease"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-type</span>=<span class="string">"playlist"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-fixed</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-autoplay</span>=<span class="string">"true"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-order</span>=<span class="string">"random"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-volume</span>=<span class="string">"0.55"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-theme</span>=<span class="string">"#cc543a"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-preload</span>=<span class="string">"auto"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果将本体放在body里面导致页面加载出现问题，请尝试放到body体后面--&gt;</span></span><br></pre></td></tr></table></figure>

<p>  APlayer的属性设置，请查阅<a href="https://aplayer.js.org/#/zh-Hans/?id=%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">APlayer中文文档-参数</a>以及能让你使用音乐平台的<a href="https://github.com/metowolf/MetingJS" target="_blank" rel="noopener">MetingJS</a>。</p>
<blockquote>
<p><strong>注意：</strong> 如果你使用上述代码，请以<code>data-xxx</code>格式书写参数名！</p>
</blockquote>
<h1 id="Bonus：使用pjax，页面跳转不重新播放"><a href="#Bonus：使用pjax，页面跳转不重新播放" class="headerlink" title="Bonus：使用pjax，页面跳转不重新播放"></a>Bonus：使用pjax，页面跳转不重新播放</h1><p><strong>最后一步！</strong></p>
<p><a href="https://music.163.com/" target="_blank" rel="noopener">网易云音乐网页版</a>底部的播放器，无论在网易云里如何跳转页面，只要还在当前标签页都是不重新加载的，这样就可以使正在播放中的音乐不随页面跳转中断。怎样实现这个功能呢？</p>
<p><a href="https://www.zhihu.com/question/23720144" target="_blank" rel="noopener">知乎-网易云音乐网页版底部的播放器是如何实现在切换网页时不停止播放音乐的？</a></p>
<p>这篇文章讲述了pjax的使用：<a href="https://cloud.tencent.com/developer/article/1096366" target="_blank" rel="noopener">迷你音乐播放器及实现全站pjax无刷新加载</a></p>
<p>虽然不是专讲APlayer，但是大同小异，大同小异！我作为对前端没什么了解的人，就跟着这个路子踩坑吧。</p>
<p>需要添加pjax和<code>1.7.0</code>以上版本的jquery，我这里依然从<code>jsDelivr</code>引用，最好放在body体结束前：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- require JQuery --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- require pjax --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/pjax@0.2.8/index.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后按照以下方法使用pjax:</p>
<p><img src="https://i.loli.net/2020/01/12/gsN2MBVqIzCW9Uf.jpg" alt="使用pjax"></p>
<p><strong>然而，全部木大！</strong> 该跳还是跳了，也许是我姿势不对。</p>
<p>我转念一想，<code>NexT</code>这种历史悠久的主题，<code>pjax</code>这么好用的技术，岂有不内置的道理？鬼使神差之下，我打开主题的<code>_config.yml</code>一搜，还真的有：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Easily enable fast Ajax navigation on your website.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-pjax</span></span><br><span class="line"><span class="comment"># For moreinformation: https://github.com/MoOx/pjax</span></span><br><span class="line"><span class="attr">pjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>仅仅直接在这里把选项置为<code>true</code>是不行的，因为虽然配置文件里已经写了选项，但其实并没有安装对应的插件。关于如何使用，<a href="https://github.com/theme-next/theme-next-pjax" target="_blank" rel="noopener">Dependencies</a>的文档里说得极为清楚，在此就不赘述了。</p>
<p>开启之后，全站都实现了无刷新加载，接下来你就随便戳吧，音乐始终会在左下角播放的。</p>
<p>至此，一整天的折腾之旅才算是终于告一段落了。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>前端</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏设计理论学习笔记 壹</title>
    <url>/2019/11/24/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A3%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="迭代设计"><a href="#迭代设计" class="headerlink" title="迭代设计"></a>迭代设计</h1><p><strong>游戏设计由1%的灵感和99%的重复组成。</strong></p>
<p>分析-&gt;设计-&gt;实现-&gt;测试-&gt;分析……</p>
<p>这就是迭代设计的流程。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>面向的玩家群体？</strong> 这决定了游戏里应该有哪些要素。无论，做这个游戏的目的是毕业设计，面向的群体就是<del>评审老师</del>我自己了。如果能有些弹幕爱好者玩就更好了。</p>
<p>这么一想，应该像STG一样有多难度级别，还要有计分系统给人刷。但是我向来都不在意分数。或者像《东方梦想曲》那样做得极难但不限重试次数，这就很亲民——其实更符合的应该是绀珠传。</p>
<p><strong>我有什么资源？</strong> 当然，只有我自己的一百天左右时间，以及网络上配布的相关素材。</p>
<p><strong>现有技术有什么？</strong> 现有技术指与要设计的作品相关联的<strong>现存游戏及其他媒介</strong>。对我来讲，具体的是Unity引擎，东方Project的大量官方以及同人游戏。同人游戏中可以着重参考的是登陆steam的几部作品，《东方红辉心》、《永远消失的幻想乡》、《东方华彩乱战》。还有些不属于东方但类型相似的游戏，比如《Enter the Gungeon》和其模仿者《元气骑士》等。</p>
<p><strong>如何尽快制作原型？</strong> 高效利用时间，优先开发<strong>核心机制</strong>并进行测试。美工、音乐等外观要素可以在后期进行处理。</p>
<p>设计、实现和测试，此处不必多讲。</p>
<a id="more"></a>

<h1 id="创新：头脑风暴"><a href="#创新：头脑风暴" class="headerlink" title="创新：头脑风暴"></a>创新：头脑风暴</h1><blockquote>
<p>尽可能的多想点子，再扔掉那些不好的。</p>
</blockquote>
<ol>
<li>拓展阶段，围绕一个主题，任意联想发散。</li>
<li>收集阶段，将所有的想法依次写到卡片上。</li>
<li>碰撞阶段，任取两张卡片用来思考。</li>
<li>评分阶段，筛选出一些最好的点子。</li>
</ol>
<h1 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h1><p>设计与开发是非常曲折的过程。几乎没可能在不对原本想法进行任何变化的情况下直接实现成品，而是一个初始原型激发更多灵感，促使制作出第二个原型，然后逐步演化为一部优秀的作品。</p>
<p>标准的游戏开发分为以下阶段：</p>
<ol>
<li>制作前：试验不同原型，最终制作出一个简短但能表现预期成品的整体样貌的Demo。</li>
<li>制作：及早确定游戏机制等系统设计，然后是关卡设计、美学要素等。以Demo为核心作出相应的高完成度内容。</li>
<li>内部测试：系统设计已经100%确定，针对测试中出现的问题和Bug进行修改。</li>
<li>Beta测试：作品基本完成，只对找出的余下Bug进行修复，而不作出任何更改。</li>
<li>黄金阶段：CD-ROM时代，压制盘碟的母盘是黄金制的。这个阶段代表游戏已经完全可以发布。</li>
<li>发售后：修改、调整、开发DLC……</li>
</ol>
<p><strong>过多的内容是游戏项目的第一杀手！</strong> 裁剪！裁剪！裁剪！</p>
<h1 id="以玩家为中心的目标"><a href="#以玩家为中心的目标" class="headerlink" title="以玩家为中心的目标"></a>以玩家为中心的目标</h1><h2 id="趣味性"><a href="#趣味性" class="headerlink" title="趣味性"></a>趣味性</h2><p>游戏的趣味性由<strong>乐趣性、吸引力和满足感</strong>组成。</p>
<p>乐趣性是让人愉快的要素，包括竞争、赌博（概率性）、感知与模仿。</p>
<p>吸引力是抓住玩家注意力，使玩家沉浸的要素。</p>
<p>满足感是指作品的游玩过程需要满足玩家的一些愿望。</p>
<h2 id="游戏性态度"><a href="#游戏性态度" class="headerlink" title="游戏性态度"></a>游戏性态度</h2><p>游戏性态度是指<strong>玩家愿意全身心投入到游戏中去的态度</strong>。只有玩家愿意全身心投入，才会保持良好的心态并遵守规则。从这个角度，应该注重<strong>尊重玩家而非利用他们</strong>。</p>
<h2 id="心流"><a href="#心流" class="headerlink" title="心流"></a>心流</h2><p>对于玩家的能力，如果游戏难度一直太高，会导致挫败感；难度一直太低，就会无聊。</p>
<p>需要让玩家感受到游戏的难度和<strong>获胜的机会</strong>。具有一定的挑战性让玩家刚刚好能够不断进步，并且要有明确的最优目标，让玩家的每次进步立刻能得到反馈（进步会让玩家更靠近最优目标，从而感受到自身的进步）。</p>
<p>在这种<strong>挑战——提高——反馈——新一轮挑战</strong>的循环波动中，玩家能集中投入，进入“心流”，带来难以忘怀的体验。要注意的是，虽然心流是非常理想的状态，但其<strong>难以持续15-20分钟以上</strong>。因此，更好的做法是间断性地营造心流，其他时间可以降低些许难度，让玩家感受自己能力的提升与强大。这也许就是为什么高难度的BOSS战之后往往安排简单的关卡。</p>
<h2 id="冲突对抗"><a href="#冲突对抗" class="headerlink" title="冲突对抗"></a>冲突对抗</h2><p>冲突是玩家的需求之一。可以是玩家之间的竞争，也可以是玩家与游戏系统之间的对抗。</p>
<h2 id="力量感"><a href="#力量感" class="headerlink" title="力量感"></a>力量感</h2><p>拥有内在动力（即自己设立目标的自由）的时候，玩家可以在心流中获得更大的愉悦。可以给玩家选择的机会，并且用多变的游戏机制让选择的多样性成为可能，这是具有一定自由度的游戏设计。</p>
<p>给玩家提供“表演”的权力，也是力量感的体现。</p>
<h2 id="关注和投入"><a href="#关注和投入" class="headerlink" title="关注和投入"></a>关注和投入</h2><p>这个部分的原则和戏剧的三幕结构是基本吻合的。一个良好的兴趣曲线应该是以下的形式：</p>
<p><img src="https://i.loli.net/2020/01/12/XEby5FwUW4Bs2QK.jpg" alt="兴趣曲线"></p>
<p>大型的游戏里设立结构性的任务，任务本身具有相应的兴趣曲线，并且从整个游戏的视野看也有相似的兴趣曲线，这就是理想的设计。</p>
<p><strong>这里试按照此兴趣曲线分析东方STG正作：</strong></p>
<p><strong>对于单独的一面</strong>，B是关卡开始而尚没有报关卡名的那一段，许多时候在这里会安排一些代表性的敌人来揭示这一关的主要内容，如辉针城4面开头的的阴阳玉☯激光中玉自机狙+大蝴蝶🦋竖直米弹，这一段简直紧张至极；还有永夜抄五面、六面开头突然蹦出的兔子🐇，会把四处乱飞的玩家打个措手不及。</p>
<p>接下来是C，短暂休息，出现关卡标题、BGM名称，音乐与场景随之进入正题，关卡正式开始。D是道中前半段，一般较有规律，稳扎稳打。随即进入E，道中BOSS出现。之后的F是道中后半段，可能较为混乱，也比较困难。最后短暂清空，到达G的关底BOSS处，开始激烈的符卡对决。</p>
<p><strong>从全盘来看</strong>，不包括Extra关卡的话，一面到六面则正好对应这里的B~G。虽然“自古三面出神曲”，但是二三面其实都没有在游戏的主题核心上更进一步，而是到了四面才真正进入主题。红魔乡、地灵殿四面进入馆中；绀珠传四面抵达月球；风神录里甚至到了四面关底才得知守矢神社的存在。因此除终盘外兴趣最高的一面是四面也就很显然了。</p>
<blockquote>
<p>嗯，这是设计剧情的良好参考。</p>
</blockquote>
<h2 id="令人感兴趣的决定"><a href="#令人感兴趣的决定" class="headerlink" title="令人感兴趣的决定"></a>令人感兴趣的决定</h2><blockquote>
<p>游戏应该是一系列有意义的决定组成的。<br>—— Sid Meier</p>
</blockquote>
<p>怎样的决定是“有意义的”？以下是设计选项的一些原则。</p>
<ol>
<li><strong>辨别性。</strong> 系统要能领会玩家的意图。</li>
<li><strong>完整性。</strong> 玩家认为自己的决定能够造成长期影响。</li>
<li><strong>含糊不清。</strong> 玩家并不能完全确定决定造成的影响，只能作出猜想。</li>
<li><strong>清晰。</strong> 这与上一条并不冲突，清晰指的是选项表达的意思应该清晰明白，让玩家能凭直觉感受到选择可能带来的结果。</li>
<li><strong>双重效果。</strong> 决定带来的结果有积极的一面，也有消极的一面。</li>
<li><strong>新颖。</strong> 如果选项与玩家最近做出的决定有很大不同，那么选择就是新颖的。新颖的选择更能够吸引玩家的注意。</li>
</ol>
]]></content>
      <tags>
        <tag>游戏</tag>
        <tag>笔记</tag>
        <tag>游戏学</tag>
      </tags>
  </entry>
  <entry>
    <title>关于“涌现”的思考</title>
    <url>/2019/11/23/%E5%85%B3%E4%BA%8E%E2%80%9C%E6%B6%8C%E7%8E%B0%E2%80%9D%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>“涌现”可以说是相当重要，我认为它是一个与重复游玩密切相关的概念。涌现导致不同的游戏体验，而单个玩家感受不同游戏体验的方法就是换种思路重复游玩。这可以说是游戏可玩性的一种代表。</p>
<p>我需要着重参考的非东方游戏中有《Enter the Gungeon》和《元气骑士》。想到这里我发现了一个共同点，它们都用多样的自机天赋、武器、技能、Buff实现了“涌现”。   </p>
<p>但我是否需要这样做呢？以上两个游戏都是Rougelike类型，甚至连随机生成的地图都高度体现着“涌现”，具有高度的重复游玩性，但我想要做的是一个拥有线性叙事的游戏。 </p>
<p>枪牢用“杀死过去的枪”这个线索巧妙地把重复的游玩变成一定程度上的线性叙事，元气骑士则完全不在意这个，剧情只是随口一说，花式推地牢才是其核心。</p>
<p>其他游戏是怎么做的呢？如果是自由度高的大型游戏，极长的主线首先就无须让人进行重复游玩。如果要体现“涌现”，无数的支线任务、收集要素、角色养成就能体现作用。</p>
<p>《战地1》这种游戏，其单人模式根本就是多人竞技模式的新手教学，而多人竞技模式中的涌现是由多名玩家的行为共同构建的。</p>
<p>还有《黑暗之魂》、《只狼》这样的，虽然剧情趋于线性，但提供多结局且难度极高，多周目还能继续提高难度，专供想要挑战自己的玩家食用。</p>
<p>想来想去，我要做的游戏可能在内嵌层上更接近于STG游戏（或者说，和STG一样古老的形式？）。STG是怎么做的呢？</p>
<a id="more"></a>

<p>就拿东方正作来说：</p>
<p><strong>提供了多种自机</strong>——比起枪牢那种自机选择只影响天赋的机制，STG中的自机还与其攻击手段对应，这使得不同机体的游玩体验可能大大不同。</p>
<p><strong>固定的少量资源</strong>——在奖残吃满的情况下，能够使用的雷与残的总量基本固定，如何合理分配这些资源来提高通关可能？由于设计上基本不会能让人仅靠拼资源就能顺利通过每一个难点，所以策略是因人而异的，这也是一种涌现。</p>
<p><strong>不同的难度等级</strong>——但是对于没有游玩经验的玩家，即使是Easy难度可能都需要多次游玩进行反复练习。要求不续关完整通关（甚至必须是Normal及以上难度）才能到达Good Ending，这种机制也在增加玩家的游玩时间。</p>
<p><strong>额外的Extra关卡</strong>——完整通关之后才能够解锁的Extra关卡。长度较长，难度较高且有大量初见杀，需要反复练习。这个部分不怎么体现“涌现”，基本是用于补充说明剧情以及延长游戏时间。</p>
<p>这时候，查到一篇讲涌现式游戏设计的文章：</p>
<p><a href="https://www.chuapp.com/?c=Article&a=index&id=285949" target="_blank" rel="noopener">涌现式游戏设计：《荒野大镖客：救赎2》和开放世界的未来</a></p>
<p>看来，涌现式的游戏设计固然好，但是并不适合刚刚起步的我。</p>
<p>买了份华彩乱战玩了玩，“就这？就这？就这？”之声充斥我的脑海，不过细细一想，工程量还是不小，毕竟我才打到二面。不过基本的风味还是懂了，一言蔽之——<strong>没内味儿！</strong>说到东方，我印象里最棒的就是永夜抄和风神录那种匠气打造的爽快感了吧……关于这个可能需要另外的分析。</p>
<p>不过买还是要买的，玩还是要接着玩的，支持天朝同人嘛。</p>
<iframe src="https://store.steampowered.com/widget/1124830/" frameborder="0" width="646" height="190"></iframe>

<p>好像又和“涌现”没啥关系了。我想到导师给我报错了的课题，写的是“DBG游戏”，这让我有点联想到非想天则那几款FTG，符卡不亦是卡吗？符卡的组合不也是Deck Building吗？也许这个方向可以有更多的想法。</p>
]]></content>
      <tags>
        <tag>游戏</tag>
        <tag>游戏学</tag>
      </tags>
  </entry>
  <entry>
    <title>191122</title>
    <url>/2019/11/22/191122/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>10月24日之后又过了快一个月，这一个月我干了些什么？</p>
<ul>
<li>进入IFPR研究所实习，写了一点点代码；</li>
<li>从完全不会C#到现在理解了基本概念的水平；</li>
<li>对Unity有了初步的了解；</li>
<li>Markdown的写作进一步熟练；</li>
<li>联系到了不错的毕业设计导师；</li>
<li>拿到了感兴趣的毕业设计课题；</li>
<li>开始学习游戏设计理论；</li>
<li>同人ARPG「東方珀露澗 ~ Aurora of Dragon Lore.」立项。（就在刚才）</li>
</ul>
<p>最重要的是没那么丧了，因为得以去实验室搬搬砖，看到自己的代码在体量庞大的系统里运转还是略有成就感的。也正是因为这里曾经热衷于独立游戏开发，如今只以“巨神”之号流传江湖的实验室导师，让我开始走上这条邪路。</p>
<p>下午着实是焦虑不堪，乃至去空间发了条动态。</p>
<blockquote>
<p>log_191122<br>焦虑，焦虑永远是学习路上最大的障碍。<br>得知身边的人一个个已经或即将上岸，得到了飞升一般的进化，而自己还在走一条看不到还有多远，更不知通向何处的道路，想不焦虑都难！<br>我可太需要休息和放空思想了，但光阴似箭，deadline不我待，停下来的一时一刻都是愧疚的煎熬。<br>功不唐捐…功不唐捐！为何要妄自菲薄呢？<br>明明要吃饱穿暖，在这个时代还并不是那么难。<br>我又在胡乱分析些什么呢。真正的进取之人会有无病呻吟的闲情逸致吗？喝口水，Keep Calm and Carry On。    </p>
</blockquote>
<p>今天虽然没有设计理论上的学习进度，但经过一整天的查文献和开脑洞，总算是有了个大致的背景设计思路，然后又“咬文嚼字”地定了个标题。万事开头难，这算是开了个头？不过这个标题现在看来总感觉过于直白，甚至一下就能看出许多端倪——果然ZUN的“起名字程度的能力”令人无法望其项背。</p>
<p>这几年为了“考据”陆陆续续购买的民俗学资料，如今也能派上一点用场了。</p>
<p>那么明天就继续学习游戏设计理论，接下来仔细打磨我的构想，能在十二月到来前正式开工就太好了。然后在寒假前弄出基本的框架……害，越说越远了，开发计划应该等理论基础充实一点再订。</p>
<p>再过两个节气即是冬至，一个我似乎有很多印象又似乎没有的时间点。那时我能不能有更现实的进步呢？</p>
<blockquote>
<p>己亥小雪。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏分析框架学习笔记 贰</title>
    <url>/2019/11/21/%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B4%B0-%E5%88%86%E5%B1%82%E5%9B%9B%E5%85%83%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本节讲述<code>分层四元法</code>框架。</p>
<p>从这里开始，内容十分庞杂，我只将值得记录的部分记下来。</p>
<h1 id="内嵌层"><a href="#内嵌层" class="headerlink" title="内嵌层"></a>内嵌层</h1><p>游戏的最终目标也许是“为了赢”，但这是最“长期”的目标，为了实现长期目标，许多个短期、中期目标必不可少。这些目标有轻重缓急，其间也许还会有互相冲突。</p>
<p>游戏的视觉与听觉是最能被直观感受到的美学内嵌，也比机制对情绪的影响力有效得多。</p>
<p>叙事内嵌需要着重讲讲。</p>
<h2 id="叙事内嵌"><a href="#叙事内嵌" class="headerlink" title="叙事内嵌"></a>叙事内嵌</h2><h3 id="传统戏剧"><a href="#传统戏剧" class="headerlink" title="传统戏剧"></a>传统戏剧</h3><p><strong>五幕结构：</strong></p>
<ol>
<li>铺垫：介绍前情、设置、重要角色</li>
<li>情节上行：发生故事，使重要角色与戏剧间的张力上升</li>
<li>高潮：汇集前面的所有剧情，矛盾达到顶点</li>
<li>情节下行：高潮引发的后果，剧情向结尾发展</li>
<li>结局：故事的结末</li>
</ol>
<p><strong>三幕结构：</strong></p>
<ol>
<li>第一幕：铺垫<br>首先以“钩子”开头，足够刺激以迅速勾起观众注意；<br>然后引发事件，让事件进入主角生活，主角开始启程；<br>第一幕与第二幕之间是第一戏剧点，自此真正的故事开始。 </li>
<li>第二幕：对抗<br>第二幕是故事的主要发展，主角经历一系列坎坷，情节推进到第二戏剧点。<br>第二戏剧点使主角作出重大决定，由此走向结局。   </li>
<li>第三幕：结局<br>故事的高潮往往接近尾声，所有冲突汇集，悬念落下之后不久，故事即结束。</li>
</ol>
<a id="more"></a>

<h3 id="互动叙事与线性叙事的区别"><a href="#互动叙事与线性叙事的区别" class="headerlink" title="互动叙事与线性叙事的区别"></a>互动叙事与线性叙事的区别</h3><p>互动叙事基本上不可能是完全的自由，本质上依然限制着可能性。支线、伏笔、NPC，都是可以在玩家的选择之外影响剧情走向，控制情节的元素。</p>
<p>互动叙事中的主角是玩家的化身，因此不可避免地，玩家的真实性格也许会与角色的性格错位。这种分歧有时却是可以被妥善利用的。</p>
<blockquote>
<p>内嵌层的要素是静态的，也是开发者唯一可以完全掌控的部分。而到了动态层，游戏就成为了涌现。</p>
</blockquote>
<h1 id="动态层"><a href="#动态层" class="headerlink" title="动态层"></a>动态层</h1><p>玩家使游戏从内嵌层走向动态层，从一系列要素转变为一种体验。</p>
<p>这之中，最重要的概念就是<code>涌现</code>。它能使简单的规则产生复杂的动态行为，即多种多样的玩法和游戏体验。但涌现也有大致的规律，可以部分为开发者所预测并引导。</p>
<p>动态机制的思考应该<strong>让游戏能够倾向于策略性</strong>，为玩家提供多种获胜选择。游戏的机制会逐渐将玩家导向“最优策略”指引下的行动，这一点是可以用于展现美学设计的。</p>
<p>动态美学在游戏进行时产生，其中“过程美学”是用代码逻辑生成的，可以被开发者控制；而“环境美学”与游戏在玩家手中运行的物理环境（分辨率、音质，乃至光敏性癫痫）有关，基本不受控制。因此，主要讲过程美学。<strong>过程美学是随着游戏的进行，根据玩家的行为动态产生的音乐与美术等。</strong> 动态的音乐和音效、粒子系统、过程动画，乃至Minecraft中随机生成的世界地貌都属于过程美学。</p>
<p>真正的动态叙事是难以在电子游戏中实现的，可能只有在龙与地下城中才能见到。它是更高级的涌现形式，甚至能涌现出在内嵌层的设计之外，却在情理之中的行为。</p>
<p>动态技术，可以将它理解为涌现的各种行为对软硬件的影响，这一点几乎与游戏设计不沾边了。</p>
<h1 id="文化层"><a href="#文化层" class="headerlink" title="文化层"></a>文化层</h1><p>文化层已经走向了游戏之外，几乎脱离了游戏本身的互动体验。</p>
<p>这个层面的元素基本上由社区、MOD、同人展现。</p>
<p>需要注意的是，由开发者授权的跨媒体不属于文化层，而是具有其本身的内嵌层。</p>
<hr>
<blockquote>
<p>今天实在摸了些鱼，进度不多。</p>
</blockquote>
]]></content>
      <tags>
        <tag>游戏</tag>
        <tag>笔记</tag>
        <tag>游戏学</tag>
      </tags>
  </entry>
  <entry>
    <title>收集东方Alphes风立绘素材</title>
    <url>/2019/11/21/%E6%94%B6%E9%9B%86%E4%B8%9C%E6%96%B9Alphes%E9%A3%8E%E7%AB%8B%E7%BB%98%E7%B4%A0%E6%9D%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>策划着要制作游戏的时候，就想着大概需要弄一些立绘。对于东方同人游戏，最好的立绘莫过于<del>ZUN绘</del>黄昏风了。黄昏边境的立绘画师早为Alphes，后为春河萌，现在又拉出了TOKIAME，不过由于非想天则的巅峰，资源最多的应该还是Alphes风格，这也是长期以来俗称的“黄昏风”。</p>
<p>《东方萃梦想》的Alphes妖梦：</p>
<p><img src="https://i.loli.net/2020/01/12/h7VEtAqfgsz1YkC.png" alt="Alphes妖梦"></p>
<p>《东方深秘录》的春河萌秦心：</p>
<p><img src="https://i.loli.net/2020/01/12/MCnbfwBgiDke3ur.png" alt="春河萌秦心"></p>
<p>TOKIAME绘制的蓬莱山辉夜：</p>
<p><img src="https://i.loli.net/2020/01/12/UyJcEqauVIt28C5.jpg" alt="纯米大吟酿 蓬莱泉辉夜"></p>
<p>为了寻找Alphes风立绘，我最初是在Pixiv搜索<code>東方　立ち絵</code>，然后就发现了<a href="https://www.pixiv.net/member_illust.php?id=743845" target="_blank" rel="noopener">kaoru</a>这个作者，他绘制了大量不错的Alphes风格立绘，并且全都可以自由进行非商业使用。依照说明我来到了他的站点<a href="http://gensoukyou.1000.tv/" target="_blank" rel="noopener">幻想幽玄庵</a>，这里有几乎所有正作角色的立绘素材，绝大部分还带有<code>.psd</code>文件，这可太有用了。</p>
<p><img src="https://i.loli.net/2020/01/12/8mSVtWT4jq5vEaY.jpg" alt="kaoru id=743845"></p>
<p>依照幻想幽玄庵这个大概是社团名的名称，我又在THBWiki上找到了<a href="https://thwiki.cc/Alphes%E9%A3%8E%E7%AB%8B%E7%BB%98%E7%B4%A0%E6%9D%90" target="_blank" rel="noopener">Alphes风立绘素材</a>页面，这里给出了<code>CharacterNentoka机</code>这个软件，可以在不用PS的情况下更加方便地生成立绘。我暂时就不用这个了，虽然没有Photoshop，但我装了Krita，试着熟悉一下操作好了。</p>
<p>另外，Pixiv还有一位大量绘制Alphes风立绘的画师<a href="https://www.pixiv.net/member_illust.php?id=4920496" target="_blank" rel="noopener">dairi</a>，甚至其画风更加精致，也有更多的新人物素材（看得出来他的画技是在逐步提高的）。结合这两位dalao的资源，凑齐一套立绘应该是不成问题的了。</p>
<p>目前暂时想到要使用的角色有这么几位，立绘都已经能够找齐了：</p>
<ul>
<li>魂魄妖梦</li>
<li>鬼人正邪</li>
<li>秦心</li>
<li>西行寺幽幽子</li>
<li>博丽灵梦</li>
<li>魂魄妖忌</li>
<li>……</li>
</ul>
<blockquote>
<p>啊——社区这种东西果然还是便利啊。</p>
</blockquote>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>图像</tag>
        <tag>东方Project</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏分析框架学习笔记 壹</title>
    <url>/2019/11/20/%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A3%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="游戏学的常用框架"><a href="#游戏学的常用框架" class="headerlink" title="游戏学的常用框架"></a>游戏学的常用框架</h1><h2 id="MDA"><a href="#MDA" class="headerlink" title="MDA"></a>MDA</h2><blockquote>
<p>M：Mechanics，机制——数据层面上的组件与算法。<br>D：Dynamics ，动态——对输入输出的实时响应。<br>A：Aethetics，美学——交互唤起的情绪反应。</p>
</blockquote>
<p>需要注意的是，由于游戏机制上的一点点变化就会在动态上引发动态上的大变化，进而在美学上引发巨大变化，因此游戏机制的调整是应该慎之又慎的。  </p>
<p>对于设计者，<strong>首先应该敲定想要玩家体会到的美学，据此来创造动态和机制。</strong> 怎样的动态能展现这样的美学？怎样的机制能产生这样的动态？</p>
<p>而对于玩家，首先接触到的是机制，即游戏的规则，由此产生动态，在动态中体会到设计者预想的美学。</p>
<a id="more"></a>

<h2 id="形式、戏剧和动态元素"><a href="#形式、戏剧和动态元素" class="headerlink" title="形式、戏剧和动态元素"></a>形式、戏剧和动态元素</h2><blockquote>
<p>形式：与媒体和互动无关的游戏的骨架，包括规则、资源和界限。<br>戏剧：剧情、叙事、设定。这使得游戏成型，使玩家理解规则，产生共鸣。<br>动态：游戏运行的状态，包括决策、行为、游戏实体间的联系。这里的动态范畴比MDA中的更大。</p>
</blockquote>
<h3 id="形式元素"><a href="#形式元素" class="headerlink" title="形式元素"></a>形式元素</h3><p>形式元素是不可或缺的部分，如果移除了若干形式元素，可能就无法被称得上是游戏。</p>
<p>形式元素有以下几种：</p>
<ul>
<li>玩家交互模式：单人？团队？乱斗？合作？……</li>
<li>目标：目的是什么？如何获取胜利？</li>
<li>规则：玩家能做些什么？</li>
<li>过程：在规则之下玩家做了什么？</li>
<li>资源：哪些东西是有价值的？</li>
<li>边界：游戏与现实的界限在哪里？</li>
<li>结局：游戏如何结束？</li>
</ul>
<h3 id="戏剧元素"><a href="#戏剧元素" class="headerlink" title="戏剧元素"></a>戏剧元素</h3><ul>
<li>前提：游戏世界的背景故事。</li>
<li>角色：故事中的人物。是角色为玩家代言？还是玩家遵从角色意志？</li>
<li>戏剧：游戏的情节，包含所有的叙事。</li>
</ul>
<h3 id="动态元素"><a href="#动态元素" class="headerlink" title="动态元素"></a>动态元素</h3><ul>
<li>涌现：简单的规则带来动态的游戏体验。要充分理解规则的内涵。</li>
<li>涌现叙事：玩法本身可能催生动态的叙事。</li>
<li>试玩：多多试玩才能理解游戏的动态运行。</li>
</ul>
<h2 id="四元法"><a href="#四元法" class="headerlink" title="四元法"></a>四元法</h2><h3 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h3><p>四元法中的“机制”不同于MDA所说的机制，它指的基本上是上文提到的“形式元素”。</p>
<h3 id="美学"><a href="#美学" class="headerlink" title="美学"></a>美学</h3><p>四元法的“美学”是能被五感直接感受到的艺术部分，这一点也与MDA中的美学不同（后者指的是游戏触动的情绪）。这是四元中最为明显的一个。</p>
<h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>游戏使用的所有技术都包含于此——硬件、软件、渲染管线等等。桌面游戏的骰子、卡组、表格等等按照四元法角度也算在技术之中，而不是机制。这是四元中最隐蔽的一个。</p>
<h3 id="剧情"><a href="#剧情" class="headerlink" title="剧情"></a>剧情</h3><p>四元法的剧情即是上文提到的“动态元素”。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>看到这里，我几乎是一脸懵逼，这三种分析方法都让我感到各有道理却又混乱不堪。尤其是四元法，初看总觉得哪里不太对？</p>
<p>但是实际上，这就是把一个游戏拆分成几个职位各自的负责部分——分属于设计师，艺术家，程序员和编剧。</p>
<p>最后我看到一句话：</p>
<blockquote>
<p>分层四元法结合并扩展了上述的所有框架。</p>
</blockquote>
<p><strong>所以既然这么好用，为什么不早点说！！</strong></p>
<h1 id="分层四元法"><a href="#分层四元法" class="headerlink" title="分层四元法"></a>分层四元法</h1><p>分层四元法分为三层——内嵌层、动态层和文化层。每一层都由上面四元法的四种元素构成。但我们把“剧情”改称为“叙事”，这一概念更加广泛，可以涵盖背景、角色、情节。</p>
<p>我的理解是，内嵌层上思考的重点是“游戏应该是怎样的？”；动态层上则是“玩家会怎样进行游戏？”；文化层上是“游戏能否具有某种现实意义？”。</p>
<blockquote>
<p>至于分层四元法的详细阐释与分析，明天再写吧。</p>
</blockquote>
]]></content>
      <tags>
        <tag>游戏</tag>
        <tag>笔记</tag>
        <tag>游戏学</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity脚本开发学习笔记 贰</title>
    <url>/2019/11/18/Unity%E8%84%9A%E6%9C%AC%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B4%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>书接上文。</p>
<h2 id="按键控制"><a href="#按键控制" class="headerlink" title="按键控制"></a>按键控制</h2><p><code>Input.GetKey</code>和<code>Input.GetButton</code>两种方法用于获取按键情况。</p>
<p>区别在于，Key有确定的KeyCode。KeyCode是Unity内置的枚举类，内含各种键盘、手柄按键，如空格键就由<code>KeyCode.Space</code>表示。</p>
<p>而Button是可以自定义详细配置的。在<code>Edit-ProjectSettings-Input</code>中可以对输入进行详细配置，为一种操作提供一个字符串别名。只要使用<code>GetBotton(string str)</code>就可以监测对应的输入了。</p>
<p>除了知道按键是否被按下之外，我们还需要确切地知道按键在哪一帧被按下，哪一帧被松开。 因此，这两个方法都有衍生的<code>GetxxxDown</code>和<code>GetxxxUp</code>。在对应按键被按下后的第一帧，<code>GetKeyDown</code>返回true，而到了第二帧，它就再次返回false了。同理，<code>GetKeyUp</code>也仅在松开按键后的第一帧返回true。</p>
<p>当然，这些方法都应该被放在Update()函数里，这样才能在每一帧对按键进行监测。</p>
<a id="more"></a>

<h2 id="摇杆控制"><a href="#摇杆控制" class="headerlink" title="摇杆控制"></a>摇杆控制</h2><p>确切地讲，这里应该是“轴”而不是摇杆。不过比起按键，摇杆更能体现“轴”的涵义，虽然按键确实也可以作为轴。</p>
<p>摇杆控制就比较麻烦了，因为按键只有按下与没按下两个状态，可以简单地用bool值表示，但摇杆有推移的距离，只能用浮点数表示。而且摇杆还有反向。</p>
<p>对于这些特性，GetKey之类的方法显然无法处理，所以需要使用<code>Input.GetAxis</code>。</p>
<p><code>Input.GetAxis</code>的参数是称为<code>axisName</code>的字符串，可以在<code>Edit-ProjectSettings-Input</code>中定义。其返回的是一个-1到1之间的浮点数，<code>Positive Botton</code>使其返回正值，而<code>Negative Botton</code>让其返回负值。</p>
<p><code>Sensitivity</code>和<code>Gravity</code>决定了按键触发/松开时返回值多快地上升/归零。</p>
<p>此外还有<code>Dead</code>值，这使得可以不对较小幅度的摇杆活动进行处理，一定程度上能够防止误触。<code>Snap</code>选项，其为true时如果同时触发了<code>Positive Botton</code>和<code>Negative Botton</code>，就返回0。</p>
<p>以上说的，是比较“完备”的摇杆控制，但是在很多时候我们并不需要这个“轴”返回浮点值。举个例子，《刺客信条：起源》中并没有以往的“奔跑”键，而是用摇杆推移的幅度决定移动速度，这就非常<code>GetAxis</code>。如果用键盘操作，WASD控制方向，是没有推移幅度这一说的，我们就当按下按键就是摇杆直接推到底，这就是<code>Type</code>属性为<code>Key or Mouse Button</code>而不是<code>Joystick Axis</code>的轴。无论如何，巴耶克并不是弹射起步，而是有gravity和sensitivity的作用。</p>
<p>但是，在东方的STG里就没有这些玩意，大家的运动都像加速度不存在一样。这种情况下，应当使用<code>Input.GetAxisRaw</code>方法，按键后返回的是1和-1这两个整数而非浮点数。</p>
<p><img src="https://i.loli.net/2020/01/12/DIymHzGMqFd2kUu.png" alt="不可思议的幻想乡"></p>
<h2 id="重写和成员隐藏"><a href="#重写和成员隐藏" class="headerlink" title="重写和成员隐藏"></a>重写和成员隐藏</h2><p>关于这一点，可以看看微软文档：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords" target="_blank" rel="noopener">了解何时使用 Override 和 New 关键字</a>。</p>
<p>以前我以为“重写覆盖”是一个词，但今天发现似乎并非如此。</p>
<p>重写（Overriding，有人称为覆盖）是在派生类中重新实现基类中已有的方法和属性等，为了安全，基类中被重写的方法/属性需要有<code>virtual</code>修饰符（或者abstract、override），派生类重写的方法/属性需要有<code>override</code>修饰符。由于是重新“实现”，重写的方法签名/属性类型和名称必须和之前保持一致，也不能改变访问性，重写方法相当于只是重新编写了方法的函数体。</p>
<p>我的理解是，<strong>在派生类中重写之后，从基类继承下来的方法/属性就相当于不存在了</strong>。因此，不管我们把派生类的对象当成该类的对象还是其基类的对象，在直接调用方法时调用的都是重写之后的方法。</p>
<p>而成员隐藏则完全不同（Member Hiding，虽然也有人称其为覆盖），它虽然看上去是在派生类中用<code>new</code>修饰符重新定义了基类中已有的成员，<strong>但！是！</strong> 从基类继承下来的成员并没有消失，而是被<strong>隐藏</strong>了。如果我们把派生类的对象作为其基类的对象（Upcasting，向上转型），那调用到的就是被隐藏的基类成员。</p>
<p>总而言之，“覆盖”这个翻译是谁发明的？出来挨打！</p>
<h2 id="委托和事件"><a href="#委托和事件" class="headerlink" title="委托和事件"></a>委托和事件</h2><p>委托（delegate）可以被当作函数指针。要定义委托，首先需要用<code>delegate</code>关键字声明一个模板，模板展示了这种委托应该存放怎样的函数——用其返回类型以及参数列表来限定。</p>
<p>可以把委托名直接当成函数名来用。</p>
<p>委托支持“多播”，这使得我们可以把同一类型的函数集中放到一个委托里，只要调用这个委托，就是依次调用委托中函数列表里的函数。用<code>+=</code>和<code>-=</code>运算符把函数加入委托或从委托中删除。</p>
<p>最初看到多播委托这里，我还没有领会这个机制的用处，但很快我就看到了“事件”。</p>
<p>事件就是一种特殊的委托，或者说它非常类似于公共的多播委托。我们在定义委托的基础上使用<code>event</code>关键字定义一个事件。</p>
<p>对于同一个事件，不同的对象可能有不同的反应，也就有不同的处理函数。如果把唤起事件视作调用委托，那么一系列的事件处理函数就是委托的函数列表，要订阅或取消订阅事件的话，用<code>+=</code>和<code>-=</code>就好了。</p>
<h2 id="协程和生成器"><a href="#协程和生成器" class="headerlink" title="协程和生成器"></a>协程和生成器</h2><p>看到C#协程（Coroutine）里熟悉的<code>yield</code>，我想到的是此前在Python中学到过的生成器（Generator）。简直是一个套路，运行到yield时，函数返回，但下次调用该函数时不会再从头执行，而是从上次退出的地方之后开始执行。</p>
<p>实际上生成器就是协程的一种，称为半协程（Semi-coroutine），这是一种受限制的协程实现。</p>
<p>在这里面学问很深，我才疏学浅暂且接触不到，这里就贴个知乎专栏链接吧：</p>
<p><a href="https://zhuanlan.zhihu.com/p/25513336" target="_blank" rel="noopener">Coroutine从入门到劝退 - 王迅的文章 - 知乎</a></p>
<blockquote>
<p>暂时就记到这里了。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Unity</tag>
        <tag>C Sharp</tag>
        <tag>游戏</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity脚本开发学习笔记 壹</title>
    <url>/2019/11/17/Unity%E8%84%9A%E6%9C%AC%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A3%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这两周，实验室并不是很忙，而且毕业设计也将要开始选题了，我终于开始如上次说的，开始学习C#和Unity。</p>
<p>这篇日志是在学习了Unity的官方视频教程之后记录的一些理解。</p>
<p>我所阅览的是由<a href="https://space.bilibili.com/7647261" target="_blank" rel="noopener">风农</a>发布在bilibili的翻译版。</p>
<h2 id="Awake-和-Start"><a href="#Awake-和-Start" class="headerlink" title="Awake() 和 Start()"></a>Awake() 和 Start()</h2><p>这两个函数用于做一些前置性工作。</p>
<p>不同之处在于，<code>Awake()</code>只要脚本被加载就会执行，即使脚本没有被使能（也就是勾上）。而<code>Start()</code>则在<code>Awake()</code>之后执行，且脚本必须被使能。</p>
<h2 id="Update-和-FixedUpdate"><a href="#Update-和-FixedUpdate" class="headerlink" title="Update() 和 FixedUpdate()"></a>Update() 和 FixedUpdate()</h2><p><code>Update()</code>很简单，每一帧调用一次。但显然，每一帧的渲染时间不会是一致的，即调用<code>Update()</code>的间隔时间不确定，这就导致如果我们把物理效果放到<code>Update()</code>里，会导致物理效果不太流畅。</p>
<p>为了保证物理运动与时间之间的紧密联系，应该使用<code>FixedUpdate()</code>。顾名思义，这是“固定的”Update，即间隔时间可以保持一致。间隔时间由<code>Time.fixedDeltaTime</code>决定，默认的时间是<code>0.02s</code>，一秒钟调用50次。</p>
<h2 id="坐标与向量"><a href="#坐标与向量" class="headerlink" title="坐标与向量"></a>坐标与向量</h2><p>Unity使用左手坐标系，三轴的相对位置依照下图所示。与数学立体几何中的一般表示不同，在这里Z轴代表的是“深度”而不是“高度”。</p>
<p><img src="https://i.loli.net/2020/01/12/Y3NegGcqRf1EUOM.jpg" alt="左手坐标系"></p>
<p>Unity包含了一些用于进行向量运算的方法，它们基本被放在<code>Vector2</code>和<code>Vector3</code>类里。</p>
<p><code>Vector3</code>里包含了一些常用向量，以(0,0,1)为<code>forward</code>（依照上面的坐标手势，中指指向前面），有<code>up</code>、<code>down</code>、<code>left</code>、<code>right</code>、<code>back</code>，以及(0,0,0)的<code>zero</code>和(1,1,1)的<code>one</code>。<code>Vector2</code>里没有z轴，故没有<code>forward</code>和<code>back</code>。</p>
<h2 id="游戏对象、组件，及其开关"><a href="#游戏对象、组件，及其开关" class="headerlink" title="游戏对象、组件，及其开关"></a>游戏对象、组件，及其开关</h2><p>一个游戏对象（GameObject）可以拥有多个组件（Component）。</p>
<p>比如一个简单的点光源，其本身是一个<code>GameObject</code>。首先它有一个<code>Transform</code>组件标示其位置、旋转、缩放等信息，还得有一个<code>Light</code>组件让它发光。也许，还有若干用于控制这个点光源的脚本组件。</p>
<p>如果我们关闭这个游戏对象（我们把它叫做激活/停用），那么这个灯整个就从场景中消失了。用游戏对象的<code>SetActive(bool value)</code>方法来实现这一点。</p>
<p>需要注意的是，如果游戏对象有多层结构，将一个父对象停用并不会使其子对象停用（虽然效果上，子对象也消失了）。查看一个对象到底是在层级中被激活还是本身确实在场景里激活了，可以用游戏对象的activeInHierarchy()和activeSelf()方法来确定。</p>
<p>要关掉灯，除了让灯凭空消失，我们当然还有更正常的做法。每一个组件都有一个bool类型的<code>enabled</code>标志位，只要把这个标志位设为<code>false</code>，就能去使能（禁用）这个组件。如将点光源的<code>Light</code>组件禁用，光是没了，但灯依然还在原处。</p>
<blockquote>
<p>今天先记到这里好了。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Unity</tag>
        <tag>C Sharp</tag>
        <tag>游戏</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>191102</title>
    <url>/2019/11/02/191102/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这一周，我开始了在华科<a href="http://ifpr.hust.edu.cn/" target="_blank" rel="noopener">聚变与等离子体研究所</a>的实习。</p>
<p><img src="https://i.loli.net/2020/01/12/IGZg3wHjUOtp9TE.jpg" alt="J-TEXT"></p>
<p>其实我完全不明白自己应该干什么。八月底退出考研大军之后，我捡起大一没能坚持看下去的廖雪峰Python教程读了个大概（在这期间，Python 3甚至已经普及了），半懂不懂地接触了些之前所学的语言里没有讲过的“迭代器、生成器、装饰器”一类玩意，就去投秋招简历了。</p>
<p>可想而知，一个数据结构、算法、操作系统、计算机网络统统没复习，没有刷LeetCode，工程实践基本靠课程设计（甚至还有不少是东拼西凑）的学生，哪家公司会收留就有鬼了。何况，我投的岗位还是数据研发，但在这之前我对数据研发的了解还真的是仅限<code>Hadoop</code>和<code>Spark</code>的拼写……</p>
<p>因此，笔试直接挂是理所当然的了。可是投字节跳动实习的时候，我这个铁憨憨还是投了数据研发。好歹实习不用笔试，不过面试当然还是挂了——一个小时的面试里，全是灵魂拷问，“人，有实力，是不怕的”，但是没有实力的话就算冷静镇定也不会带来更好的结果。</p>
<a id="more"></a>

<p>那既然这样，就开始学吧。九月，在Python学习、实习扫尾和秋招投递的混乱中度过。月底，为了养生的规律作息，我搬出学校宿舍，和一群退休爹爹婆婆住在森林公园对面。静谧的午后，他们摇着轮椅去沐浴阳光。这确实是好的，我暂且告别了凌晨两点睡，上午十点醒的混沌生活，每天能在起床时看到楼下初中生们的早自习了。</p>
<p>剧情又恰似高中的落魄时刻，不过却相隔四年半了。十月，我和那个少女每天高强度对线（并不是），好歹不至于成为一瞬就能为未来的孩子找到无数上学地点的标准A岛肥肥。这时候我才开始真正使用<code>Git</code>，并且试着使用<code>GitHub</code>上那些我曾经从未碰过的功能——Fork，Pull Request，Issue，Review等等。我暂时完成了Python的基础学习；试着理清了之前一直没整明白的几种排序算法；经过好几天的折腾，这个网站也总算重新开了起来。这时候，我一边思虑着应该再找份实习，一边觉得该开始学习真正的“数据研发”了。</p>
<p>数据研发还没有学起来，我先去了<a href="https://github.com/RichardoML" target="_blank" rel="noopener">保研室友</a>的实验室参观。这就是在聚变与等离子体研究所了。虽然靠近托卡马克装置（<a href="https://thwiki.cc/地狱极乐熔毁" target="_blank" rel="noopener">「Hell’s Tokamak」！</a>），但是这个实验室做的主要是计算机控制系统。我半开玩笑问实验室导师能否接收我去实习，结果这二次元浓度拉满的导师也就同意了。</p>
<p>行，我暂且不用思考去哪找份实习了。我把在实验室实习的时间限定在寒假之前，希望寒假还有机会去某个真正的企业混一混。</p>
<p>他们使用C#语言开发了一个用于构建物联网的好用系统：<a href="https://github.com/jtext-103/CFET2Core" target="_blank" rel="noopener">CFET</a>。目前看来，我们的工作是将各种东西——硬件和软件，乃至抽象化的概念——编写成C#类，然后接入CFET系统，成为可以统一调遣的Resources。</p>
<p>C#！作为<code>M$</code>的脑残粉，会写C#本应该是基本素养，但是我曾懒得学——其实，是微软那一套乱七八糟的名字整蒙了我，很长一段时间里我都不明白C#、.NET Framework、.NET Core、Mono、Xamarin之间的关系，就像我搞不清Java SE、EE、ME和JDK、JVM之间的关系一样。Python就没那么麻烦，但是即使是Python 2和Python 3的区别那时都能让我放下教程，这只能用懒来形容了。</p>
<blockquote>
<p>“说到痛处就气急败坏，其实还是一条懒狗。”</p>
</blockquote>
<p>好，我不作懒狗了。既然还要写两个月的C#，那就学C#好了，而数据开发就此“刚起跑，就跌倒”（笑）。</p>
<p>不过C#最大的问题就是由于历史原因在国内太冷门了，专门面向它的工作机会少之又少，这可能并不太适合基础不牢，试图短短几个月突击一下拿到offer的我。唯一的路径就是再学学Unity，然后去做游戏开发了。在一分钟之前我还稍有不乐意，虽然自己终究是喜爱游戏的，但一方面当爱好变成职业，热情便可能渐渐衰减；另一方面游戏行业在国内目前依然是“臭老九”，而且单纯作为开发者参与一个项目基本上不会有什么决定权，不可避免地要亲自把翔端给玩家吃。难顶啊。除非能找到一群真正志同道合的人。但是在这一分钟里我想了想，拿游戏开发和数据开发相比，果然还是会选择游戏开发。</p>
<p>就像那时字节跳动HR问我：“你为什么要投数据开发岗？”是啊，为什么呢。明明也不是那么有兴趣，非要说的话可能是因为看上去比较简单，让我有种可以稍稍逃避的错觉。错觉到底是错觉，从舒适区里爬出来时的阵痛不可避免。</p>
<p>我觉得，我应当首先是个东方众（至少现在还是），然后才是个臭写代码的（其实根本不会写）。独立游戏乃至同人游戏，还是有它的魅力所在的。如果可以，我很希望自己未来能避开996和无偿加班的苦海，让自己在能靠自己挣的钱买下想读的书、想听的专辑、想玩的游戏的同时，也能有时间去欣赏它们。这是我对“自由”的诠释。</p>
<p>但是，在中华民族伟大复兴的中国梦实现之前，这样的自由能够有吗？虽然说是什么985大学的计算机专业学生，那都是简历上的漂亮话，真实的自己直到几个月乃至几分钟前都是没有目的、没有热情，对自己也没有要求的咸鱼。正是那时候的自己竟然在怀抱着远大理想，在风里畅想着<code>Project REI</code>。</p>
<p>愈是说，愈是有妄自菲薄的意思了。说什么呢，这里可是博丽的分社啊，博丽那快晴的巫女是不会如此阴郁的。换个思路，至少自退出考研以来的两个多月，我还是从真·什么都不会的铁five成为了会一点点东西的five，也许再过几个月甚至能摆脱five的头衔呢？</p>
<p>那么，现在的战略就是，为了手头的实习也为了春招，我需要先系统性地学习C#。在这之外，我还必须学习Unity和游戏设计的基本思想，再用实验室955之外的时间争取做出一个像模像样的游戏Demo——当然，这应当是个东方Project二次创作同人游戏。虽然这里就和本社一样不会有人造访，也没有任何一座神明的护佑，只有一个无名之辈的呓语，但这里可是博丽的分社啊。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>191024</title>
    <url>/2019/10/24/191024/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>对于所谓“现充”，我一向是不屑一顾的。对于所谓人人趋之若鹜的“潮流”，我更是嗤之以鼻的。</p>
<p>毕竟这种东西，和他们自己说的一样，“流行是个圈”，有甚么意思呢？</p>
<p>是故在根本没有校服的高中时代，同学们——只要有条件的，个个汪洋恣肆泼洒青春时，我常常以和我心象般灰暗，似我体重般深沉的军夹克、牛仔裤、徒步鞋示人：一种自我麻痹式的超然放逐。那时的我只是一个丢不掉过去的失魂人，或者说，是过去的“什么”拉扯着我的魂魄，将它的一端钉在了2013年那个该死春季的墓碑上。</p>
<a id="more"></a>

<p>一晃七年，我日复一日，我得过且过；我浑浑噩噩，耗费了我已走过人生的三分之一——而其前三分之二，我甚至没有三两记忆。我学知识，忘得比学得更快；我记日记，终究又付之一炬；我结好友，“远走高飞难找寻”。</p>
<p>唯一可以确信的，居然是这六七年我对东方project有了不少了解，而且从对STG基本没有概念到全通e、若干通n的程度，以及知道了一些文化方面的皮毛，能让我在新作里认出一些个出典，但也仅此而已。</p>
<p>起初他们流行屌丝文化，我虽尚幼但仍然抵触；后来他们吹捧鲜肉韩星，我亦觉得怪异非常；现在他们搞起快手抖音，我只敢敬而远之。我脱离流行文化，不看电视、不听新歌，更叫不出明星们的名字，连英雄联盟也不曾打；即便是电影，也只是偶尔凑个热闹而已。</p>
<p>每天我都能看到做着意义不明的事，开着低级趣味玩笑的闲人；也能见到蒙昧无知，却依然妄自尊大咄咄逼人的蠢人。<strong>可气，可笑，可悲！</strong> 但这个世界依然前进得太快，好像只有我自己在退行：没有什么比这更令人恐惧和焦虑的了——我！我也是他们中的一员！</p>
<p>我实在是一个活在过去的人。曾经我以为这是我的特质，这是我的“格调”，但实际上是莫名其妙的自卑在驱使我不断加强自己的“AT力场”。</p>
<p>这是我和任天堂的“孽缘”：作为五线城市普通家庭的孩子，小学有幸在官二代同学那里玩到了Sony PSP，于是到了2011年我读初一之时，我想要一台游戏机。只不过，我决定要从任天堂的平台开始。和每个中国孩子一样，我不免需要靠成绩来证明自己足以配得上神的恩赐。我是幸运的，我拿了学生时代唯一的一个全校第一：至于这背后有怎样的阴谋阳谋、机缘巧合，已经不重要了。</p>
<p>其实3DS在那时已经发布，但之前只玩过4399和4399游戏盒的我，哪里敢想什么裸眼3D，更别提对没见过钱的初中生而言那天文数字般的价格。我想要一台2006年的NDSL，那红色外壳上的龙纹让我兴奋不已。然而父母那时承诺的礼物额度大抵只有300元而已，NDSL虽是上一世代，依然要价600；我只有退而求其次，在400元左右的2004年初代NDS中找寻，试图捡漏。但显然，这是不现实的，我只能再“退而求其次”，我看向了2003年的GBA SP，一台不带卡带的二手机器差不多就是300元了。至于卡带，只有之后“节衣缩食”来攒了，而且我甚至觉得这是一件很浪漫的事。</p>
<p>这时已经是2011年，我希望得到一台2003年的游戏机。然而这个愿望依旧不能满足，因为在中国基本不会有哪个父母会给孩子奖励游戏机，这是我后来才意识到的事实。我没有不开心，好像这一切本就是理所当然，唯一让我有点难过的，是次年的伦敦奥运会开幕式上，我看到英国的孩子们在玩着3DS。最后我来到了武汉，在东湖边享用了当时我们的城市里还没有的必胜客披萨。那一餐我吃得很开心也很满足，但之后至今的八年里，虽然必胜客已经遍地开花，我却再未走进任何一家的大门。</p>
<p>一直到了大学，到了2018年，这件小事才有了一点转机。其实在这之前，关于任天堂，关于掌机，乃至关于游戏还有许许多多记忆，不过这又是另一个故事了。2018年的暑假，我看完了《幸运星》，泉此方的NDSL唤起了我的记忆，和多年前一样，我打开淘宝，我输入了<code>NDSL</code>——不同的是，这一次我得以点下了购买按键。</p>
<p><img src="https://i.loli.net/2020/01/12/TRwhQNn6WO3q1zC.jpg" alt="此方的NDSL"></p>
<p>与和善的老板商谈几句，我要了和此方同款的深蓝色。货到了，是2006年生产的批次。我很开心，虽然跨越了十多年，但我总算玩上了《逆转裁判4》。</p>
<p><img src="https://i.loli.net/2020/01/12/9oXJrIUPlFSBqt1.jpg" alt="此方的NDSL in 现实"></p>
<p>可是，2018年了，早已经是Nintendo Switch的时代了，当年与NDSL同台竞技的索尼掌机也早已成了时代的眼泪。在这样的时代，来自十二年前的简单快乐让我投入且专注。现在，我认为这是我最为怪异的一点。</p>
<p>“这样的事，以后还多着呢。”但我不想这样下去。如果我还能被称为“少年”，那这个念头可能就是我唯一的“倔强”。</p>
<p>可是，要怎样做？</p>
<p>不知道。想到这里，我心里空空荡荡，能抓住的绳索只有EVA。我没有什么鉴赏水平，EVA览毕，只记得了一点：庵野秀明的“补完计划”，是让阿宅走出自己闭锁的AT力场，走向社会。</p>
<p>“那个东西”，它终究要死去。</p>
<blockquote>
<p>己亥霜降。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>游戏</tag>
        <tag>任天堂</tag>
      </tags>
  </entry>
  <entry>
    <title>为Hexo配置Gitalk，并更改主题颜色</title>
    <url>/2019/10/20/%E4%B8%BAHexo%E9%85%8D%E7%BD%AEGitalk%EF%BC%8C%E5%B9%B6%E6%9B%B4%E6%94%B9%E4%B8%BB%E9%A2%98%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="配置Gitalk"><a href="#配置Gitalk" class="headerlink" title="配置Gitalk"></a>配置Gitalk</h1><p>在重新搭建这个站点的过程中，碰到一个“小”问题：以前我的网站使用的是WordPress，内建了评论系统，而现在在Hexo站点中该如何引入评论系统？</p>
<p>当然，这根本就不是问题，Hexo最著名的主题NexT已经在配置文件中给出了多种可供选择的评论系统。Google搜索到的大部分人使用的是Disqus，然而当我按照他们的流程一通操作后，执行<code>hexo g</code>却永远都是：</p>
<pre><code>next disqus TypeError: Cannot read property &apos;replace&apos; of null</code></pre><p>在我感到阵阵窒息之后，我看到了这样的issue：</p>
<p><img src="https://i.loli.net/2020/01/12/fkE8JSxeo4pjmu7.jpg" alt="不支持Disqus.jpg"></p>
<p>我人傻了，3月份就不支持了咋现在还在配置文件里？</p>
<blockquote>
<p>显然，当时匆匆扫过的我并没明白 <code>暂时的解决方案是 count: false</code> 是什么意思。</p>
</blockquote>
<p>于是我转而尝试其他的评论系统，好么，国内的一个赛一个麻烦，又是实名认证又是人脸信息的，还是别了。而国外的又时刻有被河蟹的风险。</p>
<p>终于我看到了Gitalk，它基于GitHub的issue，只要有GitHub账号就可以评论，看来同性交友网站不倒，这玩意就能用下去。</p>
<a id="more"></a>

<p>配置起来不算太麻烦，在NexT的配置文件里<strong>找到comments块，将gitalk给active上</strong>（这一步很重要），再去下面一点的gitalk块里按照文档一顿填，基本就完事了。</p>
<p>给出我的配置以供参考：</p>
<p><img src="https://i.loli.net/2020/01/12/jPw6frglHAW52ME.jpg" alt="gitalk块配置"></p>
<p>到这里，理论上你基本就能看到和gitalk官网上一样的效果了。</p>
<p>然而，坑爹的事情不会就此停止，如果你在本地<code>hexo s</code>，然后打开一篇文章，你应该确实会看到“Gitalk加载中”，然后 * 噔  噔  咚 * ，出现了这样的场景：</p>
<p><img src="https://i.loli.net/2020/01/12/VmbrWfpDMNute5O.jpg" alt="未找到相关的Issues"></p>
<p>你会试着点击<code>使用GitHub登录</code>，然而什么也没有发生，这大概是因为GitHub的登陆结果传不回本机的Hexo server。不必奇怪，尽管<code>hexo d</code>将它部署上去，访问你的站点再次点击它就好了。</p>
<p>需要注意，每篇文章下面的Gitalk都需要你戳上一下才能开始运行，这是因为刚刚说过的，Gitalk的原理是issue，你得以管理员的身份在repo里给每篇文章开上一个对应的issue，其他人才能在下面留言。</p>
<p>举个栗子，这是我用于测试Gitalk的几个留言在站点上的样子：</p>
<p><img src="https://i.loli.net/2020/01/12/62GCSo1yZp3ixRW.jpg" alt="gitalk在站点上"></p>
<p>而这是repo里对应的issue：</p>
<p><img src="https://i.loli.net/2020/01/12/l7pDt8vaf1gKdmk.jpg" alt="gitalk在issue中"></p>
<p>注意到红线标出的这一行，Gitalk就是用这两个标签来对应issue和文章的。</p>
<h1 id="更改Gitalk的主题颜色"><a href="#更改Gitalk的主题颜色" class="headerlink" title="更改Gitalk的主题颜色"></a>更改Gitalk的主题颜色</h1><p>如果你足够细心，也许会注意到官方的gitalk是蓝色的，而我站点中的却是与页头一致的绯色。</p>
<p>这两种颜色差别太大，我想要保持网页配色的一致性，于是免不了多折腾两下。</p>
<p>要更改颜色，首先就得知道这是什么颜色。</p>
<p>F12，审查元素，可以看到默认的色号是<code>#6190E8</code>。</p>
<p><img src="https://i.loli.net/2020/01/12/mjACFTl8et5hfwp.jpg" alt="默认配色"><br>既然如此，我们去Gitalk的repo，找找这个色号出现在哪些地方。</p>
<p><img src="https://i.loli.net/2020/01/12/EAkaJT7sGz8jcC1.jpg" alt="repo中的位置"></p>
<p>可以看到，这个色号出现在<code>dist/gitalk.css</code>和<code>src/style/index.styl</code>中。而真正决定Gitalk颜色的，应当是<code>dist</code>（Distribution，分发）中的<code>gitalk.css</code>。</p>
<p>明白了这一点，我们就可以整活了。首先将这个repo给fork过来，再将<code>dist/gitalk.css</code>中的色号全都改成想要的样子。我使用的绯色<code>#CC543A</code>取自<a href="http://nipponcolors.com" target="_blank" rel="noopener">NIPPON COLORS - 日本の伝統色</a>。</p>
<p>康康初音浅葱色？</p>
<p><img src="https://i.loli.net/2020/01/12/rzUKvqA5SIT7tPG.jpg" alt="浅葱"></p>
<p>这套色彩也是锤子的坚果手机“文青版”那几个骚气配色名称：远州鼠、落栗、苏芳、石竹、枯草、柳煤竹茶、锖青磁、鸠羽紫的来源。</p>
<p><img src="https://i.loli.net/2020/01/12/7p1J9MOtAChDqyi.jpg" alt="坚果手机文青版"></p>
<p>当然，这还不算完，我们得让NexT主题用上我们修改过的<code>gitalk.css</code>。</p>
<p>我们可以在next文件夹里搜索gitalk，看看它是如何被加载的。</p>
<p><img src="https://i.loli.net/2020/01/12/UiRWDco3Tr6IAls.jpg" alt="gtalk搜索结果"></p>
<p>显然，第2、4行的<code>gitalk_css_uri</code>和<code>gitalk_js_uri</code>就是关键。它说明gitalk的文件可以从两个地方加载：一个是<code>theme.vendors</code>，也就是主题配置文件<code>_config.yml</code>的<code>vendors</code>块中的记录，一个是<code>jsdelivr</code>这个CDN。</p>
<p><img src="https://i.loli.net/2020/01/12/FpBQKzJZhqjdtmY.jpg" alt="gitalk vendors"></p>
<p>以上两张截图里的CDN已经被我改成了我修改后的分支中对应的文件。关于这个CDN地址的格式，可以参看<a href="https://www.jsdelivr.com" target="_blank" rel="noopener">jsDelivr官网</a>的说明。</p>
<p>地址修改完成后，<code>hexo g -d</code>走起，你的配色应该已经成了想要的样子，庆贺吧！</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World Again!</title>
    <url>/2019/10/20/Hello%20World%20Again!/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>我又回来了。</p>
<blockquote>
<p>最早是为了交计算机基础作业而制作的网站，从此走上不归之路……</p>
<p>想到用WordPress很大程度上是受老司机<a href="https://www.saber.我爱你" target="_blank" rel="noopener"> @雪见仙尊（https://saber.我爱你）</a>影响。</p>
<p><em>↑这个站的域名已经改为 <a href="https://saber.love" target="_blank" rel="noopener">saber.love</a></em></p>
<p>什么时候自己也能把网站建的那样好啊……</p>
<p>站长万年不变的QQ：624629073</p>
</blockquote>
<p>这是2016年末写在原网站<a href="http://macyrate.site" target="_blank" rel="noopener">macyrate.site</a>的关于页面的话。</p>
<p><img src="https://i.loli.net/2020/04/15/SGHbnmTzjqXRsDh.png" alt="WordPress旧站"></p>
<p><img src="https://i.loli.net/2020/01/12/PkKrectW9o4GnAf.jpg" alt="当时用的Flash插件导致手机端出现问题"></p>
<p>由于后来有科学上网的需求，我在vultr租用了一台位于美帝的云虚拟机。为了统一管理，我作死地把站点也从阿里云迁移到了那里，结果没过多久，在一场腥风血雨的不知何故后，我的服务器当场白给，而我竟然没有备份源码，只在github上留了一份甚至还未调试完全的Hexo静态页面。</p>
<p>这太令人窒息了。</p>
<p>三年过去，当年没折腾完的Hexo，现在是时候好好用用了。</p>
<p>回想起来，我还真是什么都浅尝辄止：就连GitHub亦是。直到大四领悟到自己是个彩笔，这样混下去将会失学又失业的事实，我才开始老老实实系统地学习这些堪称“基础设施”的东西。</p>
<p>Hello World Again，希望这次我能坚持得久一点。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>一个不错的素材网站</title>
    <url>/2016/12/30/%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%94%99%E7%9A%84%E7%B4%A0%E6%9D%90%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="https://i.loli.net/2020/01/12/TLnEIjlPvA8V6fe.jpg" alt="搞不定抠图.jpg"></p>
<p>今天有仙交同学在空间发自己抠图的苦逼经历</p>
<p>当时我就坐不住了，MDZZ，都什么年代了去个底还要手动PS？</p>
<p>之前为了做答辩PPT（没错，就是为了那次作业我才做了这个破站），是找过纯色图片去底的方法的，结果最简单易用的果然永远是在线工具！！</p>
<p>干货：<a href="http://www.aigei.com/bgremover" target="_blank" rel="noopener">BgRemover - 在线图片去底工具</a></p>
<p>10秒后的成果：</p>
<p><img src="https://i.loli.net/2020/01/12/DQq1RFeETnkP9or.jpg" alt="去底校徽.jpg"></p>
<p>这个工具所属的<a href="http://www.aigei.com/" target="_blank" rel="noopener">爱给网</a>里还有大量的蜜汁素材和视频教程，相当实用。</p>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>图像</tag>
      </tags>
  </entry>
  <entry>
    <title>161218</title>
    <url>/2016/12/18/161218/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>祖国神仿的英梨梨终于在我的书桌上找到了自己的工作：</p>
<p><img src="https://i.loli.net/2020/01/12/qLInJ2OEl1cspUT.jpg" alt="英梨梨.jpg"></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Steam游览记录：Eternal Senia（永恒的赛妮亚）</title>
    <url>/2016/12/17/Steam%E6%B8%B8%E8%A7%88%E8%AE%B0%E5%BD%95%EF%BC%9AEternal%20Senia%EF%BC%88%E6%B0%B8%E6%81%92%E7%9A%84%E8%B5%9B%E5%A6%AE%E4%BA%9A%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="https://i.loli.net/2020/01/12/VvuFk1lsjyEWmOQ.jpg" alt="senia-1.jpg"></p>
<p>台湾独立开发者做的免费ARPG，好顶赞！</p>
<p>鬼知道我是怎么看到这个游戏的，反正大概是因为被封面上的赛妮亚萌杀了戳进来的。</p>
<p>像素风ARPG，好评如潮，还免费【想起了手机上曾经玩过的《勇士的黎明》（神TM人物选择界面还有迷之东方梗）】，果断下载。仅仅300MB不到的体积，如果设置中文也只需数十MB的数据包，实在是个小游戏。</p>
<p>游戏开局强烈的魔塔既视感，主角带着神器冲进塔里救人，被套路之后神器损坏，从零开始。后面的剧情也比较狗血，三个大章节都是一个套路：刷怪，打小BOSS，疯狂收集材料，合成一套神器，顺便收集属性书，然后打大BOSS。</p>
<p>但是，不知道为什么就是这么带感啊！！！一口气刷过去根本停不下来啊！！！</p>
<p>大概我享受着这种见证赛妮亚从一个脆弱胆怯的少女逐渐成长为真正的勇者的过程吧。</p>
<p>我玩着感觉还是比较投入的。后期赛妮亚会觉醒R技能，爆发出“永（hei）恒（hua）”的力量，威力巨大，但是除非为了保命，我完全不愿意用这个技能。因为一旦使用，一段时间内赛妮亚都会黑化，在菜单里看着十分揪心。</p>
<a id="more"></a>

<p>这是赛妮亚正常的样子：</p>
<p><img src="https://i.loli.net/2020/01/12/XWjeo37dDmVFc6O.jpg" alt="senia-2.jpg"></p>
<p>这是黑化之后的样子：</p>
<p><img src="https://i.loli.net/2020/01/12/qBp75tYzHCF2msl.jpg" alt="senia-3.jpg"><br>不！我不要赛妮亚被玩♀坏！！！</p>
<p>另外，BGM非常棒，时而轻松缓和，时而压抑恐怖，时而高雅圣洁，时而欢快激动，主题曲《悲伤的另一面》更是有味道啊。</p>
<p>BOSS房间前可以选择BOSS难度，我由于相信自己的“高超技术”，每次都作死地选“困难”，所幸前面的BOSS套路都不深，顶多用浪死的结果换来BOSS的所有技能情况，然后第二次打轻松过关。但是最终BOSS和前面的难度简直不在一个次元，让我想起了一度被魂魄妖梦支配的恐惧。</p>
<p>然而当我好不容易打到最后，才发现三种结局居然没有一个和谐美满，我的刀片饥渴难耐，作者肯定和老虚共同编译过Trade.py！<del>（直接证据：一周目通关后开放的特典房间里，作者的头像是掉头狂魔Charlotte）</del></p>
<p>三个不同程度的BAD ENDING之中好歹算是最好的结局：</p>
<p><img src="https://i.loli.net/2020/01/12/iME7W6S9kbx5NCT.jpg" alt="senia-4.jpg"></p>
<p>不过作者说续作正在制作，看来最后大概还是能给我们一个完美结局……吧？</p>
<p>从赛妮亚的这句话看来，还是很有可能的：</p>
<p><img src="https://i.loli.net/2020/01/12/lYds6XFNjHqaEMw.jpg" alt="senia-5.jpg"></p>
<iframe src="https://store.steampowered.com/widget/351640/?t=Steam%E8%AF%84%E8%AE%BA%EF%BC%9A%0A%E5%85%8D%E8%B4%B9%E6%B8%B8%E6%88%8F%E9%87%8C%E7%9A%84%E5%B0%8F%E7%B2%BE%E5%93%81%EF%BC%8C3-4%E4%B8%AA%E5%B0%8F%E6%97%B6%E9%80%9A%E5%85%B3%E6%B5%81%E7%A8%8B%E5%B9%B6%E4%B8%8D%E7%AE%97%E9%95%BF%E3%80%82%0A%E6%B4%97%E8%84%91%E7%9A%84BGM%E8%AE%A9%E6%88%91%E5%BE%AA%E7%8E%AF%E4%BA%86%E5%BE%88%E4%B9%85%E3%80%82%E6%9C%80%E5%90%8E%E7%9A%84%E5%87%A0%E5%B9%85CG%E7%9B%B8%E5%BD%93%E6%83%8A%E8%89%B3%E3%80%82%0A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%8D%95%E3%80%81%E6%98%93%E4%B8%8A%E6%89%8B%EF%BC%8C%E4%BD%86%E6%98%AF%E6%89%93boss%E8%BF%98%E6%98%AF%E5%B0%8F%E5%B0%8F%E5%9C%B0%E8%80%83%E9%AA%8C%E6%8A%80%E6%9C%AF%EF%BC%8C%E6%9C%89%E8%B6%A3%E3%80%82%0A%E5%94%AF%E4%B8%80%E5%80%BC%E5%BE%97%E8%AF%9F%E7%97%85%E7%9A%84%E5%BA%94%E8%AF%A5%E6%98%AF%E5%8F%8D%E5%A4%8D%E5%88%B7%E5%B1%9E%E6%80%A7%E4%B9%A6%E4%BA%86%E3%80%82%0A%E7%8B%AC%E7%AB%8B%E4%BD%9C%E8%80%85%EF%BC%8C%E6%9C%9F%E5%BE%85%E5%85%B6%E7%BB%AD%E4%BD%9C%E3%80%82" frameborder="0" width="646" height="190"></iframe>]]></content>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>回乡见闻</title>
    <url>/2016/12/13/%E5%9B%9E%E4%B9%A1%E8%A7%81%E9%97%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>前两日回老家，参加了曾外祖母的葬礼。我对曾外祖母完全没有印象，似乎十几年来确凿未曾见过一面（大概是我见过时还小，早已忘了）。但是葬礼还是要认真对待，于是穿了从头到脚的一身黑。</p>
<p>我原本觉得葬礼是庄严肃穆，套路很深的，结果大家根本不按套路来啊。</p>
<p>戴上代表曾孙辈的红头巾我就进了场。对着曾外祖母的棺材磕了三个头后，我才发现气氛很违和。场内相当喧闹，主要音源来自一个临时搭建的舞台。大概是丧葬公司搞的吧，舞台上挂着一个大红色LED显示屏，滚动播出着孝子孝孙们的……点歌金额？</p>
<p>原来这个舞台是点歌用的吗。</p>
<p>再看台上，一个中年妇女捏着话筒搞事，大概是类似于主持人的吧。她宣读“送行点歌单”时，声音抑扬顿挫，细细一听就发现原来交钱越多的便被喊得越有气势，有个砸了一千元的来宾名字叫的震天响，而那些只点了一两百元的就给含糊地混过去了。</p>
<p>这倒没什么，你们爱唱便唱罢，葬礼庆典、坟头蹦迪也就算了。</p>
<a id="more"></a>

<p>然而到了晚上，居然请来了一个演员，不是为了别的，而是为了让她在这陌生人的葬礼上表演嚎啕大哭。这演员一身古代孝妇行头，竟然真的哭出了眼泪。于是大家也就很欣慰，有人便给主持人递上红票子算是捧了场。主持人则是喜笑颜开，把一张张红票子收进口袋时还不忘对着话筒宣讲这位演员的专业，以及其眼泪是真的有感而发，否则不可能真的哭出来云云云。</p>
<p>虽然很可笑，我姑且忍了罢。没准是什么特别的丧葬习俗呢。</p>
<p>然而接下来便不对了，演员在主持人数钱的当口暂停了哭声。此时又有两人送上红票，主持人接过来便讲“我们又有两位孝子孝孙为老太君送上十全十美”云云，回过头便切换成流利的土话对着那演员飙起：“你快点儿哭撒，冇看倒你一哭钱就来了？几赚钱哦，我都不想说你了，你跟我快点哭撒！”大概为了防止后台听不到，主持人还是对着她的话筒大声说的。</p>
<p>后台和演员也很配合，音乐声马上走起，演员酝酿一两秒便又涌出货真价实的泪水，带着哭腔继续撕心裂肺。台下的大家脸上露出了默契的笑容，各自继续抽烟喝酒，闲谈打牌。</p>
<p>EXCUSE ME???</p>
<p><img src="https://i.loli.net/2020/01/12/aZ37uBVIxUEQYGC.jpg" alt="黑人问号.jpg"></p>
<p>淡定如我，都不由得为此感到惊奇，这已经是明目张胆的抢钱了吧。罢了罢了。</p>
<p>直到这个时候，我才头一次为躺在棺材里的曾外祖母感到同情与痛心。</p>
<p>一辈子，活了快一个世纪了，身经百战见得多了之后，最后就特么是这样？就这样让自己的遗体被充满铜臭味的气氛环绕着？就这样走向人生的结末？</p>
<p>我有一句妈卖批，不知当讲不当讲。</p>
<p>古代守孝三年，现在简化了，应该也至少守到五七、七七，或者百天啊？尸骨未寒，甚至还未下葬，大家就围绕在棺材前兴奋的开party，真是66666。</p>
<p>我记得，母亲曾经说过，在她小时候，那里是一个充满文化气息的和谐村落，她家也算得上是个书香门第，和我父亲那里的“穷乡僻壤”不知道高到哪里去了。我也记得，舅舅曾经说过，现在不行了，大家全都只知道打牌赌钱混日子，农活基本也荒废了。</p>
<p>我能怎么办？我也很绝望啊？</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Flash暴力膜-说明</title>
    <url>/2016/12/08/Flash%E6%9A%B4%E5%8A%9B%E8%86%9C-%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这篇文章是对“Flash暴力膜”一文的说明。</p>
<blockquote>
<p>“所以×××同志同我讲话，说‘中央都决定了，你来当总书记’。我说另请高明吧，我实在也不是谦虚。我一个上海市委书记怎么到北京来了呢？但是，×××同志讲‘大家已经研究决定了’。后来我念了两首诗，叫‘苟利国家生死以，岂因祸福避趋之’。”</p>
<p><em>—— 长者</em></p>
</blockquote>
<a id="more"></a>

<p>Flash的素材来源于站长之家和百度图片（那张AV画质的背景图是中国联合工程公司，原国机二院），使用软件是Adobe Flash Professional CS6，因为没有VISA卡只好下载了破解免费版，在此向Adobe致歉(。</p>
<p>制作过程比较简单，动画效果只有树和帽带的晃动（但是至少熟悉了flash的基本操作），毕竟我们要做到简洁纯朴啊。</p>
<p>本来想给文字也添加一个动画效果的，但是出现了各种迷之问题，就秉承一贯的“简洁风”弃了。</p>
<p>真正劳神的是把.swf插到wordpress站点里，因为flash早就是时代的眼泪了，wordpress已经不再支持.swf的上传，找来了“Swf Upload Enabler”插件才上传成功；插入.swf又用到WOPUS论坛上大佬的方法，引入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--其实我也不知道是不是这段代码，网站迁移时这里的内容丢失了（--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">id</span>=<span class="string">"flashcontent"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">classid</span>=<span class="string">"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">width</span>=<span class="string">"550px"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">height</span>=<span class="string">"400px"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"movie"</span> <span class="attr">value</span>=<span class="string">"mymovie.swf"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--[if !IE]&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">"application/x-shockwave-flash"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">data</span>=<span class="string">"mymovie.swf"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">width</span>=<span class="string">"550px"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">height</span>=<span class="string">"400px"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Fallback or "alternate" content goes here.</span><br><span class="line">    This content will only be visible if the SWF fails to load.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--[if !IE]&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（WP-Syntax简直有毒，锻炼视力的时刻到了）（代码显示效果以后再调试吧）</p>
<p>把url改为媒体库中文件的链接，再改改宽高，就完成了。</p>
<p>但是移动端上显示很不理想，因为尺寸不会自适应，导致排版出现缺陷（况且移动端根本不支持flash）</p>
<p>嘛，不过就这样吧。</p>
<blockquote>
<p><strong>天若有情天亦老，我为长者续一秒；</strong></p>
<p><strong>垂死病中惊坐起，谈笑风生又一年。</strong></p>
</blockquote>
]]></content>
      <tags>
        <tag>Flash</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>Flash暴力膜</title>
    <url>/2016/12/08/Flash%E6%9A%B4%E5%8A%9B%E8%86%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="https://i.loli.net/2020/01/12/uIR1rUVtanXyz7H.gif" alt="暴力膜.gif"></p>
<p>本应是Flash的，但时间已过3年，Flash成了时代眼泪中的时代眼泪，拿gif凑数好了（这抖动频率有点太快了）</p>
]]></content>
      <tags>
        <tag>Flash</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World!</title>
    <url>/2016/11/23/Hello%20World!/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>迈向web世界的第一步。</p>
<p>今后也要努力学习科学技术，做一个对社会有用的新世纪大好青年！</p>
<p><img src="https://i.loli.net/2020/01/12/FA5mlze3Bs9bIQG.jpg" alt="辉夜"></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
