<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World!</title>
    <url>/2016/11/23/Hello%20World!/</url>
    <content><![CDATA[<p>迈向web世界的第一步。</p>
<p>今后也要努力学习科学技术，做一个对社会有用的新世纪大好青年！</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99483:/FA5mlze3Bs9bIQG.jpg?authkey=AIbyrqnS5z58phc" alt="辉夜"></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Flash暴力膜-说明</title>
    <url>/2016/12/08/Flash%E6%9A%B4%E5%8A%9B%E8%86%9C-%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>这篇文章是对“Flash暴力膜”一文的说明。</p>
<blockquote>
<p>“所以×××同志同我讲话，说‘中央都决定了，你来当总书记’。我说另请高明吧，我实在也不是谦虚。我一个上海市委书记怎么到北京来了呢？但是，×××同志讲‘大家已经研究决定了’。后来我念了两首诗，叫‘苟利国家生死以，岂因祸福避趋之’。”</p>
<p><em>—— 长者</em></p>
</blockquote>
<span id="more"></span>
<p>Flash的素材来源于站长之家和百度图片（那张AV画质的背景图是中国联合工程公司，原国机二院），使用软件是Adobe Flash Professional CS6，因为没有VISA卡只好下载了破解免费版，在此向Adobe致歉(。</p>
<p>制作过程比较简单，动画效果只有树和帽带的晃动（但是至少熟悉了flash的基本操作），毕竟我们要做到简洁纯朴啊。</p>
<p>本来想给文字也添加一个动画效果的，但是出现了各种迷之问题，就秉承一贯的“简洁风”弃了。</p>
<p>真正劳神的是把.swf插到wordpress站点里，因为flash早就是时代的眼泪了，wordpress已经不再支持.swf的上传，找来了“Swf Upload Enabler”插件才上传成功；插入.swf又用到WOPUS论坛上大佬的方法，引入代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--其实我也不知道是不是这段代码，网站迁移时这里的内容丢失了（--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">id</span>=<span class="string">&quot;flashcontent&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">classid</span>=<span class="string">&quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">width</span>=<span class="string">&quot;550px&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">height</span>=<span class="string">&quot;400px&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;movie&quot;</span> <span class="attr">value</span>=<span class="string">&quot;mymovie.swf&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--[if !IE]&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">&quot;application/x-shockwave-flash&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">data</span>=<span class="string">&quot;mymovie.swf&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">width</span>=<span class="string">&quot;550px&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">height</span>=<span class="string">&quot;400px&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Fallback or &quot;alternate&quot; content goes here.</span><br><span class="line">    This content will only be visible if the SWF fails to load.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--[if !IE]&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（WP-Syntax简直有毒，锻炼视力的时刻到了）（代码显示效果以后再调试吧）</p>
<p>把url改为媒体库中文件的链接，再改改宽高，就完成了。</p>
<p>但是移动端上显示很不理想，因为尺寸不会自适应，导致排版出现缺陷（况且移动端根本不支持flash）</p>
<p>嘛，不过就这样吧。</p>
<blockquote>
<p><strong>天若有情天亦老，我为长者续一秒；</strong></p>
<p><strong>垂死病中惊坐起，谈笑风生又一年。</strong></p>
</blockquote>
]]></content>
      <tags>
        <tag>Flash</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>Flash暴力膜</title>
    <url>/2016/12/08/Flash%E6%9A%B4%E5%8A%9B%E8%86%9C/</url>
    <content><![CDATA[<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99485:/uIR1rUVtanXyz7H.gif?authkey=AIbyrqnS5z58phc" alt="暴力膜.gif"></p>
<p>本应是Flash的，但时间已过3年，Flash成了时代眼泪中的时代眼泪，拿gif凑数好了（这抖动频率有点太快了）</p>
]]></content>
      <tags>
        <tag>Flash</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title>回乡见闻</title>
    <url>/2016/12/13/%E5%9B%9E%E4%B9%A1%E8%A7%81%E9%97%BB/</url>
    <content><![CDATA[<p>前两日回老家，参加了曾外祖母的葬礼。我对曾外祖母完全没有印象，似乎十几年来确凿未曾见过一面（大概是我见过时还小，早已忘了）。但是葬礼还是要认真对待，于是穿了从头到脚的一身黑。</p>
<p>我原本觉得葬礼是庄严肃穆，套路很深的，结果大家根本不按套路来啊。</p>
<p>戴上代表曾孙辈的红头巾我就进了场。对着曾外祖母的棺材磕了三个头后，我才发现气氛很违和。场内相当喧闹，主要音源来自一个临时搭建的舞台。大概是丧葬公司搞的吧，舞台上挂着一个大红色LED显示屏，滚动播出着孝子孝孙们的……点歌金额？</p>
<p>原来这个舞台是点歌用的吗。</p>
<p>再看台上，一个中年妇女捏着话筒搞事，大概是类似于主持人的吧。她宣读“送行点歌单”时，声音抑扬顿挫，细细一听就发现原来交钱越多的便被喊得越有气势，有个砸了一千元的来宾名字叫的震天响，而那些只点了一两百元的就给含糊地混过去了。</p>
<p>这倒没什么，你们爱唱便唱罢，葬礼庆典、坟头蹦迪也就算了。</p>
<span id="more"></span>
<p>然而到了晚上，居然请来了一个演员，不是为了别的，而是为了让她在这陌生人的葬礼上表演嚎啕大哭。这演员一身古代孝妇行头，竟然真的哭出了眼泪。于是大家也就很欣慰，有人便给主持人递上红票子算是捧了场。主持人则是喜笑颜开，把一张张红票子收进口袋时还不忘对着话筒宣讲这位演员的专业，以及其眼泪是真的有感而发，否则不可能真的哭出来云云云。</p>
<p>虽然很可笑，我姑且忍了罢。没准是什么特别的丧葬习俗呢。</p>
<p>然而接下来便不对了，演员在主持人数钱的当口暂停了哭声。此时又有两人送上红票，主持人接过来便讲“我们又有两位孝子孝孙为老太君送上十全十美”云云，回过头便切换成流利的土话对着那演员飙起：“你快点儿哭撒，冇看倒你一哭钱就来了？几赚钱哦，我都不想说你了，你跟我快点哭撒！”大概为了防止后台听不到，主持人还是对着她的话筒大声说的。</p>
<p>后台和演员也很配合，音乐声马上走起，演员酝酿一两秒便又涌出货真价实的泪水，带着哭腔继续撕心裂肺。台下的大家脸上露出了默契的笑容，各自继续抽烟喝酒，闲谈打牌。</p>
<p>EXCUSE ME???</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99484:/aZ37uBVIxUEQYGC.jpg?authkey=AIbyrqnS5z58phc" alt="黑人问号.jpg"></p>
<p>淡定如我，都不由得为此感到惊奇，这已经是明目张胆的抢钱了吧。罢了罢了。</p>
<p>直到这个时候，我才头一次为躺在棺材里的曾外祖母感到同情与痛心。</p>
<p>一辈子，活了快一个世纪了，身经百战见得多了之后，最后就特么是这样？就这样让自己的遗体被充满铜臭味的气氛环绕着？就这样走向人生的结末？</p>
<p>我有一句妈卖批，不知当讲不当讲。</p>
<p>古代守孝三年，现在简化了，应该也至少守到五七、七七，或者百天啊？尸骨未寒，甚至还未下葬，大家就围绕在棺材前兴奋的开party，真是66666。</p>
<p>我记得，母亲曾经说过，在她小时候，那里是一个充满文化气息的和谐村落，她家也算得上是个书香门第，和我父亲那里的“穷乡僻壤”不知道高到哪里去了。我也记得，舅舅曾经说过，现在不行了，大家全都只知道打牌赌钱混日子，农活基本也荒废了。</p>
<p>我能怎么办？我也很绝望啊？</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Steam游览记录：Eternal Senia（永恒的赛妮亚）</title>
    <url>/2016/12/17/Steam%E6%B8%B8%E8%A7%88%E8%AE%B0%E5%BD%95%EF%BC%9AEternal%20Senia%EF%BC%88%E6%B0%B8%E6%81%92%E7%9A%84%E8%B5%9B%E5%A6%AE%E4%BA%9A%EF%BC%89/</url>
    <content><![CDATA[<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99486:/VvuFk1lsjyEWmOQ.jpg?authkey=AIbyrqnS5z58phc" alt="senia-1.jpg"></p>
<p>台湾独立开发者做的免费ARPG，好顶赞！</p>
<p>鬼知道我是怎么看到这个游戏的，反正大概是因为被封面上的赛妮亚萌杀了戳进来的。</p>
<p>像素风ARPG，好评如潮，还免费【想起了手机上曾经玩过的《勇士的黎明》（神TM人物选择界面还有迷之东方梗）】，果断下载。仅仅300MB不到的体积，如果设置中文也只需数十MB的数据包，实在是个小游戏。</p>
<p>游戏开局强烈的魔塔既视感，主角带着神器冲进塔里救人，被套路之后神器损坏，从零开始。后面的剧情也比较狗血，三个大章节都是一个套路：刷怪，打小BOSS，疯狂收集材料，合成一套神器，顺便收集属性书，然后打大BOSS。</p>
<p>但是，不知道为什么就是这么带感啊！！！一口气刷过去根本停不下来啊！！！</p>
<p>大概我享受着这种见证赛妮亚从一个脆弱胆怯的少女逐渐成长为真正的勇者的过程吧。</p>
<p>我玩着感觉还是比较投入的。后期赛妮亚会觉醒R技能，爆发出“永（hei）恒（hua）”的力量，威力巨大，但是除非为了保命，我完全不愿意用这个技能。因为一旦使用，一段时间内赛妮亚都会黑化，在菜单里看着十分揪心。</p>
<span id="more"></span>
<p>这是赛妮亚正常的样子：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99487:/XWjeo37dDmVFc6O.jpg?authkey=AIbyrqnS5z58phc" alt="senia-2.jpg"></p>
<p>这是黑化之后的样子：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99488:/qBp75tYzHCF2msl.jpg?authkey=AIbyrqnS5z58phc" alt="senia-3.jpg"><br>
不！我不要赛妮亚被玩♀坏！！！</p>
<p>另外，BGM非常棒，时而轻松缓和，时而压抑恐怖，时而高雅圣洁，时而欢快激动，主题曲《悲伤的另一面》更是有味道啊。</p>
<p>BOSS房间前可以选择BOSS难度，我由于相信自己的“高超技术”，每次都作死地选“困难”，所幸前面的BOSS套路都不深，顶多用浪死的结果换来BOSS的所有技能情况，然后第二次打轻松过关。但是最终BOSS和前面的难度简直不在一个次元，让我想起了一度被魂魄妖梦支配的恐惧。</p>
<p>然而当我好不容易打到最后，才发现三种结局居然没有一个和谐美满，我的刀片饥渴难耐，<a href="http://xn--Trade-242hl8jqug46a858bc85grkcob22o709aw5tsmp.py">作者肯定和老虚共同编译过Trade.py</a>！<s>（直接证据：一周目通关后开放的特典房间里，作者的头像是掉头狂魔Charlotte）</s></p>
<p>三个不同程度的BAD ENDING之中好歹算是最好的结局：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99489:/iME7W6S9kbx5NCT.jpg?authkey=AIbyrqnS5z58phc" alt="senia-4.jpg"></p>
<p>不过作者说续作正在制作，看来最后大概还是能给我们一个完美结局……吧？</p>
<p>从赛妮亚的这句话看来，还是很有可能的：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99490:/lYds6XFNjHqaEMw.jpg?authkey=AIbyrqnS5z58phc" alt="senia-5.jpg"></p>
<iframe src="https://store.steampowered.com/widget/351640/?t=Steam%E8%AF%84%E8%AE%BA%EF%BC%9A%0A%E5%85%8D%E8%B4%B9%E6%B8%B8%E6%88%8F%E9%87%8C%E7%9A%84%E5%B0%8F%E7%B2%BE%E5%93%81%EF%BC%8C3-4%E4%B8%AA%E5%B0%8F%E6%97%B6%E9%80%9A%E5%85%B3%E6%B5%81%E7%A8%8B%E5%B9%B6%E4%B8%8D%E7%AE%97%E9%95%BF%E3%80%82%0A%E6%B4%97%E8%84%91%E7%9A%84BGM%E8%AE%A9%E6%88%91%E5%BE%AA%E7%8E%AF%E4%BA%86%E5%BE%88%E4%B9%85%E3%80%82%E6%9C%80%E5%90%8E%E7%9A%84%E5%87%A0%E5%B9%85CG%E7%9B%B8%E5%BD%93%E6%83%8A%E8%89%B3%E3%80%82%0A%E6%93%8D%E4%BD%9C%E7%AE%80%E5%8D%95%E3%80%81%E6%98%93%E4%B8%8A%E6%89%8B%EF%BC%8C%E4%BD%86%E6%98%AF%E6%89%93boss%E8%BF%98%E6%98%AF%E5%B0%8F%E5%B0%8F%E5%9C%B0%E8%80%83%E9%AA%8C%E6%8A%80%E6%9C%AF%EF%BC%8C%E6%9C%89%E8%B6%A3%E3%80%82%0A%E5%94%AF%E4%B8%80%E5%80%BC%E5%BE%97%E8%AF%9F%E7%97%85%E7%9A%84%E5%BA%94%E8%AF%A5%E6%98%AF%E5%8F%8D%E5%A4%8D%E5%88%B7%E5%B1%9E%E6%80%A7%E4%B9%A6%E4%BA%86%E3%80%82%0A%E7%8B%AC%E7%AB%8B%E4%BD%9C%E8%80%85%EF%BC%8C%E6%9C%9F%E5%BE%85%E5%85%B6%E7%BB%AD%E4%BD%9C%E3%80%82" frameborder="0" width="646" height="190"></iframe>
]]></content>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>161218</title>
    <url>/2016/12/18/161218/</url>
    <content><![CDATA[<p>祖国神仿的英梨梨终于在我的书桌上找到了自己的工作：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99491:/qLInJ2OEl1cspUT.jpg?authkey=AIbyrqnS5z58phc" alt="英梨梨.jpg"></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>一个不错的素材网站</title>
    <url>/2016/12/30/%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%94%99%E7%9A%84%E7%B4%A0%E6%9D%90%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99492:/TLnEIjlPvA8V6fe.jpg?authkey=AIbyrqnS5z58phc" alt="搞不定抠图.jpg"></p>
<p>今天有仙交同学在空间发自己抠图的苦逼经历</p>
<p>当时我就坐不住了，MDZZ，都什么年代了去个底还要手动PS？</p>
<p>之前为了做答辩PPT（没错，就是为了那次作业我才做了这个破站），是找过纯色图片去底的方法的，结果最简单易用的果然永远是在线工具！！</p>
<p>干货：<a href="http://www.aigei.com/bgremover">BgRemover - 在线图片去底工具</a></p>
<p>10秒后的成果：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99493:/DQq1RFeETnkP9or.jpg?authkey=AIbyrqnS5z58phc" alt="去底校徽.jpg"></p>
<p>这个工具所属的<a href="http://www.aigei.com/">爱给网</a>里还有大量的蜜汁素材和视频教程，相当实用。</p>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>图像</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World Again!</title>
    <url>/2019/10/20/Hello%20World%20Again!/</url>
    <content><![CDATA[<p>我又回来了。</p>
<blockquote>
<p>最早是为了交计算机基础作业而制作的网站，从此走上不归之路……</p>
<p>想到用WordPress很大程度上是受老司机<a href="https://www.saber.xn--6qq986b3xl"> @雪见仙尊（https://saber.我爱你）</a>影响。</p>
<p><em>↑这个站的域名已经改为 <a href="https://saber.love">saber.love</a></em></p>
<p>什么时候自己也能把网站建的那样好啊……</p>
<p>站长万年不变的QQ：624629073</p>
</blockquote>
<p>这是2016年末写在原网站<a href="http://macyrate.site">macyrate.site</a>的关于页面的话。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99504:/SGHbnmTzjqXRsDh.png?authkey=AIbyrqnS5z58phc" alt="WordPress旧站"></p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99503:/PkKrectW9o4GnAf.jpg?authkey=AIbyrqnS5z58phc" alt="当时用的Flash插件导致手机端出现问题"></p>
<p>由于后来有科学上网的需求，我在vultr租用了一台位于美帝的云虚拟机。为了统一管理，我作死地把站点也从阿里云迁移到了那里，结果没过多久，在一场腥风血雨的不知何故后，我的服务器当场白给，而我竟然没有备份源码，只在github上留了一份甚至还未调试完全的Hexo静态页面。</p>
<p>这太令人窒息了。</p>
<p>三年过去，当年没折腾完的Hexo，现在是时候好好用用了。</p>
<p>回想起来，我还真是什么都浅尝辄止：就连GitHub亦是。直到大四领悟到自己是个彩笔，这样混下去将会失学又失业的事实，我才开始老老实实系统地学习这些堪称“基础设施”的东西。</p>
<p>Hello World Again，希望这次我能坚持得久一点。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>为Hexo配置Gitalk，并更改主题颜色</title>
    <url>/2019/10/20/%E4%B8%BAHexo%E9%85%8D%E7%BD%AEGitalk%EF%BC%8C%E5%B9%B6%E6%9B%B4%E6%94%B9%E4%B8%BB%E9%A2%98%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<h1>配置Gitalk</h1>
<p>在重新搭建这个站点的过程中，碰到一个“小”问题：以前我的网站使用的是WordPress，内建了评论系统，而现在在Hexo站点中该如何引入评论系统？</p>
<p>当然，这根本就不是问题，Hexo最著名的主题NexT已经在配置文件中给出了多种可供选择的评论系统。Google搜索到的大部分人使用的是Disqus，然而当我按照他们的流程一通操作后，执行<code>hexo g</code>却永远都是：</p>
<pre><code>next disqus TypeError: Cannot read property 'replace' of null
</code></pre>
<p>在我感到阵阵窒息之后，我看到了这样的issue：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99494:/fkE8JSxeo4pjmu7.jpg?authkey=AIbyrqnS5z58phc" alt="不支持Disqus.jpg"></p>
<p>我人傻了，3月份就不支持了咋现在还在配置文件里？</p>
<blockquote>
<p>显然，当时匆匆扫过的我并没明白 <code>暂时的解决方案是 count: false </code> 是什么意思。</p>
</blockquote>
<p>于是我转而尝试其他的评论系统，好么，国内的一个赛一个麻烦，又是实名认证又是人脸信息的，还是别了。而国外的又时刻有被河蟹的风险。</p>
<p>终于我看到了Gitalk，它基于GitHub的issue，只要有GitHub账号就可以评论，看来同性交友网站不倒，这玩意就能用下去。</p>
<span id="more"></span>
<p>配置起来不算太麻烦，在NexT的配置文件里<strong>找到comments块，将gitalk给active上</strong>（这一步很重要），再去下面一点的gitalk块里按照文档一顿填，基本就完事了。</p>
<p>给出我的配置以供参考：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99495:/jPw6frglHAW52ME.jpg?authkey=AIbyrqnS5z58phc" alt="gitalk块配置"></p>
<p>到这里，理论上你基本就能看到和gitalk官网上一样的效果了。</p>
<p>然而，坑爹的事情不会就此停止，如果你在本地<code>hexo s</code>，然后打开一篇文章，你应该确实会看到“Gitalk加载中”，然后 * 噔  噔  咚 * ，出现了这样的场景：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99496:/VmbrWfpDMNute5O.jpg?authkey=AIbyrqnS5z58phc" alt="未找到相关的Issues"></p>
<p>你会试着点击<code>使用GitHub登录</code>，然而什么也没有发生，这大概是因为GitHub的登陆结果传不回本机的Hexo server。不必奇怪，尽管<code>hexo d</code>将它部署上去，访问你的站点再次点击它就好了。</p>
<p>需要注意，每篇文章下面的Gitalk都需要你戳上一下才能开始运行，这是因为刚刚说过的，Gitalk的原理是issue，你得以管理员的身份在repo里给每篇文章开上一个对应的issue，其他人才能在下面留言。</p>
<p>举个栗子，这是我用于测试Gitalk的几个留言在站点上的样子：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99497:/62GCSo1yZp3ixRW.jpg?authkey=AIbyrqnS5z58phc" alt="gitalk在站点上"></p>
<p>而这是repo里对应的issue：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99502:/l7pDt8vaf1gKdmk.jpg?authkey=AIbyrqnS5z58phc" alt="gitalk在issue中"></p>
<p>注意到红线标出的这一行，Gitalk就是用这两个标签来对应issue和文章的。</p>
<h1>更改Gitalk的主题颜色</h1>
<p>如果你足够细心，也许会注意到官方的gitalk是蓝色的，而我站点中的却是与页头一致的绯色。</p>
<p>这两种颜色差别太大，我想要保持网页配色的一致性，于是免不了多折腾两下。</p>
<p>要更改颜色，首先就得知道这是什么颜色。</p>
<p>F12，审查元素，可以看到默认的色号是<code>#6190E8</code>。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99498:/mjACFTl8et5hfwp.jpg?authkey=AIbyrqnS5z58phc" alt="默认配色"><br>
既然如此，我们去Gitalk的repo，找找这个色号出现在哪些地方。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99499:/EAkaJT7sGz8jcC1.jpg?authkey=AIbyrqnS5z58phc" alt="repo中的位置"></p>
<p>可以看到，这个色号出现在<code>dist/gitalk.css</code>和<code>src/style/index.styl</code>中。而真正决定Gitalk颜色的，应当是<code>dist</code>（Distribution，分发）中的<code>gitalk.css</code>。</p>
<p>明白了这一点，我们就可以整活了。首先将这个repo给fork过来，再将<code>dist/gitalk.css</code>中的色号全都改成想要的样子。我使用的绯色<code>#CC543A</code>取自<a href="http://nipponcolors.com">NIPPON COLORS - 日本の伝統色</a>。</p>
<p>康康初音浅葱色？</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99500:/rzUKvqA5SIT7tPG.jpg?authkey=AIbyrqnS5z58phc" alt="浅葱"></p>
<p>这套色彩也是锤子的坚果手机“文青版”那几个骚气配色名称：远州鼠、落栗、苏芳、石竹、枯草、柳煤竹茶、锖青磁、鸠羽紫的来源。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99510:/7p1J9MOtAChDqyi.jpg?authkey=AIbyrqnS5z58phc" alt="坚果手机文青版"></p>
<p>当然，这还不算完，我们得让NexT主题用上我们修改过的<code>gitalk.css</code>。</p>
<p>我们可以在next文件夹里搜索gitalk，看看它是如何被加载的。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99511:/UiRWDco3Tr6IAls.jpg?authkey=AIbyrqnS5z58phc" alt="gtalk搜索结果"></p>
<p>显然，第2、4行的<code>gitalk_css_uri</code>和<code>gitalk_js_uri</code>就是关键。它说明gitalk的文件可以从两个地方加载：一个是<code>theme.vendors</code>，也就是主题配置文件<code>_config.yml</code>的<code>vendors</code>块中的记录，一个是<code>jsdelivr</code>这个CDN。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99501:/FpBQKzJZhqjdtmY.jpg?authkey=AIbyrqnS5z58phc" alt="gitalk vendors"></p>
<p>以上两张截图里的CDN已经被我改成了我修改后的分支中对应的文件。关于这个CDN地址的格式，可以参看<a href="https://www.jsdelivr.com">jsDelivr官网</a>的说明。</p>
<p>地址修改完成后，<code>hexo g -d</code>走起，你的配色应该已经成了想要的样子，庆贺吧！</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>191024</title>
    <url>/2019/10/24/191024/</url>
    <content><![CDATA[<p>对于所谓“现充”，我一向是不屑一顾的。对于所谓人人趋之若鹜的“潮流”，我更是嗤之以鼻的。</p>
<p>毕竟这种东西，和他们自己说的一样，“流行是个圈”，有甚么意思呢？</p>
<p>是故在根本没有校服的高中时代，同学们——只要有条件的，个个汪洋恣肆泼洒青春时，我常常以和我心象般灰暗，似我体重般深沉的军夹克、牛仔裤、徒步鞋示人：一种自我麻痹式的超然放逐。那时的我只是一个丢不掉过去的失魂人，或者说，是过去的“什么”拉扯着我的魂魄，将它的一端钉在了2013年那个该死春季的墓碑上。</p>
<span id="more"></span>
<p>一晃七年，我日复一日，我得过且过；我浑浑噩噩，耗费了我已走过人生的三分之一——而其前三分之二，我甚至没有三两记忆。我学知识，忘得比学得更快；我记日记，终究又付之一炬；我结好友，“远走高飞难找寻”。</p>
<p>唯一可以确信的，居然是这六七年我对东方project有了不少了解，而且从对STG基本没有概念到全通e、若干通n的程度，以及知道了一些文化方面的皮毛，能让我在新作里认出一些个出典，但也仅此而已。</p>
<p>起初他们流行屌丝文化，我虽尚幼但仍然抵触；后来他们吹捧鲜肉韩星，我亦觉得怪异非常；现在他们搞起快手抖音，我只敢敬而远之。我脱离流行文化，不看电视、不听新歌，更叫不出明星们的名字，连英雄联盟也不曾打；即便是电影，也只是偶尔凑个热闹而已。</p>
<p>每天我都能看到做着意义不明的事，开着低级趣味玩笑的闲人；也能见到蒙昧无知，却依然妄自尊大咄咄逼人的蠢人。<strong>可气，可笑，可悲！</strong> 但这个世界依然前进得太快，好像只有我自己在退行：没有什么比这更令人恐惧和焦虑的了——我！我也是他们中的一员！</p>
<p>我实在是一个活在过去的人。曾经我以为这是我的特质，这是我的“格调”，但实际上是莫名其妙的自卑在驱使我不断加强自己的“AT力场”。</p>
<p>这是我和任天堂的“孽缘”：作为五线城市普通家庭的孩子，小学有幸在官二代同学那里玩到了Sony PSP，于是到了2011年我读初一之时，我想要一台游戏机。只不过，我决定要从任天堂的平台开始。和每个中国孩子一样，我不免需要靠成绩来证明自己足以配得上神的恩赐。我是幸运的，我拿了学生时代唯一的一个全校第一：至于这背后有怎样的阴谋阳谋、机缘巧合，已经不重要了。</p>
<p>其实3DS在那时已经发布，但之前只玩过4399和4399游戏盒的我，哪里敢想什么裸眼3D，更别提对没见过钱的初中生而言那天文数字般的价格。我想要一台2006年的NDSL，那红色外壳上的龙纹让我兴奋不已。然而父母那时承诺的礼物额度大抵只有300元而已，NDSL虽是上一世代，依然要价600；我只有退而求其次，在400元左右的2004年初代NDS中找寻，试图捡漏。但显然，这是不现实的，我只能再“退而求其次”，我看向了2003年的GBA SP，一台不带卡带的二手机器差不多就是300元了。至于卡带，只有之后“节衣缩食”来攒了，而且我甚至觉得这是一件很浪漫的事。</p>
<p>这时已经是2011年，我希望得到一台2003年的游戏机。然而这个愿望依旧不能满足，因为在中国基本不会有哪个父母会给孩子奖励游戏机，这是我后来才意识到的事实。我没有不开心，好像这一切本就是理所当然，唯一让我有点难过的，是次年的伦敦奥运会开幕式上，我看到英国的孩子们在玩着3DS。最后我来到了武汉，在东湖边享用了当时我们的城市里还没有的必胜客披萨。那一餐我吃得很开心也很满足，但之后至今的八年里，虽然必胜客已经遍地开花，我却再未走进任何一家的大门。</p>
<p>一直到了大学，到了2018年，这件小事才有了一点转机。其实在这之前，关于任天堂，关于掌机，乃至关于游戏还有许许多多记忆，不过这又是另一个故事了。2018年的暑假，我看完了《幸运星》，泉此方的NDSL唤起了我的记忆，和多年前一样，我打开淘宝，我输入了<code>NDSL</code>——不同的是，这一次我得以点下了购买按键。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99505:/TRwhQNn6WO3q1zC.jpg?authkey=AIbyrqnS5z58phc" alt="此方的NDSL"></p>
<p>与和善的老板商谈几句，我要了和此方同款的深蓝色。货到了，是2006年生产的批次。我很开心，虽然跨越了十多年，但我总算玩上了《逆转裁判4》。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99507:/9oXJrIUPlFSBqt1.jpg?authkey=AIbyrqnS5z58phc" alt="此方的NDSL in 现实"></p>
<p>可是，2018年了，早已经是Nintendo Switch的时代了，当年与NDSL同台竞技的索尼掌机也早已成了时代的眼泪。在这样的时代，来自十二年前的简单快乐让我投入且专注。现在，我认为这是我最为怪异的一点。</p>
<p>“这样的事，以后还多着呢。”但我不想这样下去。如果我还能被称为“少年”，那这个念头可能就是我唯一的“倔强”。</p>
<p>可是，要怎样做？</p>
<p>不知道。想到这里，我心里空空荡荡，能抓住的绳索只有EVA。我没有什么鉴赏水平，EVA览毕，只记得了一点：庵野秀明的“补完计划”，是让阿宅走出自己闭锁的AT力场，走向社会。</p>
<p>“那个东西”，它终究要死去。</p>
<blockquote>
<p>己亥霜降。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>游戏</tag>
        <tag>任天堂</tag>
      </tags>
  </entry>
  <entry>
    <title>191102</title>
    <url>/2019/11/02/191102/</url>
    <content><![CDATA[<p>这一周，我开始了在华科<a href="http://ifpr.hust.edu.cn/">聚变与等离子体研究所</a>的实习。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99506:/IGZg3wHjUOtp9TE.jpg?authkey=AIbyrqnS5z58phc" alt="J-TEXT"></p>
<p>其实我完全不明白自己应该干什么。八月底退出考研大军之后，我捡起大一没能坚持看下去的廖雪峰Python教程读了个大概（在这期间，Python 3甚至已经普及了），半懂不懂地接触了些之前所学的语言里没有讲过的“迭代器、生成器、装饰器”一类玩意，就去投秋招简历了。</p>
<p>可想而知，一个数据结构、算法、操作系统、计算机网络统统没复习，没有刷LeetCode，工程实践基本靠课程设计（甚至还有不少是东拼西凑）的学生，哪家公司会收留就有鬼了。何况，我投的岗位还是数据研发，但在这之前我对数据研发的了解还真的是仅限<code>Hadoop</code>和<code>Spark</code>的拼写……</p>
<p>因此，笔试直接挂是理所当然的了。可是投字节跳动实习的时候，我这个铁憨憨还是投了数据研发。好歹实习不用笔试，不过面试当然还是挂了——一个小时的面试里，全是灵魂拷问，“人，有实力，是不怕的”，但是没有实力的话就算冷静镇定也不会带来更好的结果。</p>
<span id="more"></span>
<p>那既然这样，就开始学吧。九月，在Python学习、实习扫尾和秋招投递的混乱中度过。月底，为了养生的规律作息，我搬出学校宿舍，和一群退休爹爹婆婆住在森林公园对面。静谧的午后，他们摇着轮椅去沐浴阳光。这确实是好的，我暂且告别了凌晨两点睡，上午十点醒的混沌生活，每天能在起床时看到楼下初中生们的早自习了。</p>
<p>剧情又恰似高中的落魄时刻，不过却相隔四年半了。十月，我和那个少女每天高强度对线（并不是），好歹不至于成为一瞬就能为未来的孩子找到无数上学地点的标准A岛肥肥。这时候我才开始真正使用<code>Git</code>，并且试着使用<code>GitHub</code>上那些我曾经从未碰过的功能——Fork，Pull Request，Issue，Review等等。我暂时完成了Python的基础学习；试着理清了之前一直没整明白的几种排序算法；经过好几天的折腾，这个网站也总算重新开了起来。这时候，我一边思虑着应该再找份实习，一边觉得该开始学习真正的“数据研发”了。</p>
<p>数据研发还没有学起来，我先去了<a href="https://github.com/RichardoML">保研室友</a>的实验室参观。这就是在聚变与等离子体研究所了。虽然靠近托卡马克装置（<a href="https://thwiki.cc/%E5%9C%B0%E7%8B%B1%E6%9E%81%E4%B9%90%E7%86%94%E6%AF%81">「Hell’s Tokamak」！</a>），但是这个实验室做的主要是计算机控制系统。我半开玩笑问实验室导师能否接收我去实习，结果这二次元浓度拉满的导师也就同意了。</p>
<p>行，我暂且不用思考去哪找份实习了。我把在实验室实习的时间限定在寒假之前，希望寒假还有机会去某个真正的企业混一混。</p>
<p>他们使用C#语言开发了一个用于构建物联网的好用系统：<a href="https://github.com/jtext-103/CFET2Core">CFET</a>。目前看来，我们的工作是将各种东西——硬件和软件，乃至抽象化的概念——编写成C#类，然后接入CFET系统，成为可以统一调遣的Resources。</p>
<p>C#！作为<code>M$</code>的脑残粉，会写C#本应该是基本素养，但是我曾懒得学——其实，是微软那一套乱七八糟的名字整蒙了我，很长一段时间里我都不明白C#、.NET Framework、.NET Core、Mono、Xamarin之间的关系，就像我搞不清Java SE、EE、ME和JDK、JVM之间的关系一样。Python就没那么麻烦，但是即使是Python 2和Python 3的区别那时都能让我放下教程，这只能用懒来形容了。</p>
<blockquote>
<p>“说到痛处就气急败坏，其实还是一条懒狗。”</p>
</blockquote>
<p>好，我不作懒狗了。既然还要写两个月的C#，那就学C#好了，而数据开发就此“刚起跑，就跌倒”（笑）。</p>
<p>不过C#最大的问题就是由于历史原因在国内太冷门了，专门面向它的工作机会少之又少，这可能并不太适合基础不牢，试图短短几个月突击一下拿到offer的我。唯一的路径就是再学学Unity，然后去做游戏开发了。在一分钟之前我还稍有不乐意，虽然自己终究是喜爱游戏的，但一方面当爱好变成职业，热情便可能渐渐衰减；另一方面游戏行业在国内目前依然是“臭老九”，而且单纯作为开发者参与一个项目基本上不会有什么决定权，不可避免地要亲自把翔端给玩家吃。难顶啊。除非能找到一群真正志同道合的人。但是在这一分钟里我想了想，拿游戏开发和数据开发相比，果然还是会选择游戏开发。</p>
<p>就像那时字节跳动HR问我：“你为什么要投数据开发岗？”是啊，为什么呢。明明也不是那么有兴趣，非要说的话可能是因为看上去比较简单，让我有种可以稍稍逃避的错觉。错觉到底是错觉，从舒适区里爬出来时的阵痛不可避免。</p>
<p>我觉得，我应当首先是个东方众（至少现在还是），然后才是个臭写代码的（其实根本不会写）。独立游戏乃至同人游戏，还是有它的魅力所在的。如果可以，我很希望自己未来能避开996和无偿加班的苦海，让自己在能靠自己挣的钱买下想读的书、想听的专辑、想玩的游戏的同时，也能有时间去欣赏它们。这是我对“自由”的诠释。</p>
<p>但是，在中华民族伟大复兴的中国梦实现之前，这样的自由能够有吗？虽然说是什么985大学的计算机专业学生，那都是简历上的漂亮话，真实的自己直到几个月乃至几分钟前都是没有目的、没有热情，对自己也没有要求的咸鱼。正是那时候的自己竟然在怀抱着远大理想，在风里畅想着<code>Project REI</code>。</p>
<p>愈是说，愈是有妄自菲薄的意思了。说什么呢，这里可是博丽的分社啊，博丽那快晴的巫女是不会如此阴郁的。换个思路，至少自退出考研以来的两个多月，我还是从真·什么都不会的铁five成为了会一点点东西的five，也许再过几个月甚至能摆脱five的头衔呢？</p>
<p>那么，现在的战略就是，为了手头的实习也为了春招，我需要先系统性地学习C#。在这之外，我还必须学习Unity和游戏设计的基本思想，再用实验室955之外的时间争取做出一个像模像样的游戏Demo——当然，这应当是个东方Project二次创作同人游戏。虽然这里就和本社一样不会有人造访，也没有任何一座神明的护佑，只有一个无名之辈的呓语，但这里可是博丽的分社啊。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity脚本开发学习笔记 壹</title>
    <url>/2019/11/17/Unity%E8%84%9A%E6%9C%AC%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A3%B9/</url>
    <content><![CDATA[<p>这两周，实验室并不是很忙，而且毕业设计也将要开始选题了，我终于开始如上次说的，开始学习C#和Unity。</p>
<p>这篇日志是在学习了Unity的官方视频教程之后记录的一些理解。</p>
<p>我所阅览的是由<a href="https://space.bilibili.com/7647261">风农</a>发布在bilibili的翻译版。</p>
<h2 id="Awake-和-Start"><a class="header-anchor" href="#Awake-和-Start">¶</a>Awake() 和 Start()</h2>
<p>这两个函数用于做一些前置性工作。</p>
<p>不同之处在于，<code>Awake()</code>只要脚本被加载就会执行，即使脚本没有被使能（也就是勾上）。而<code>Start()</code>则在<code>Awake()</code>之后执行，且脚本必须被使能。</p>
<h2 id="Update-和-FixedUpdate"><a class="header-anchor" href="#Update-和-FixedUpdate">¶</a>Update() 和 FixedUpdate()</h2>
<p><code>Update()</code>很简单，每一帧调用一次。但显然，每一帧的渲染时间不会是一致的，即调用<code>Update()</code>的间隔时间不确定，这就导致如果我们把物理效果放到<code>Update()</code>里，会导致物理效果不太流畅。</p>
<p>为了保证物理运动与时间之间的紧密联系，应该使用<code>FixedUpdate()</code>。顾名思义，这是“固定的”Update，即间隔时间可以保持一致。间隔时间由<code>Time.fixedDeltaTime</code>决定，默认的时间是<code>0.02s</code>，一秒钟调用50次。</p>
<h2 id="坐标与向量"><a class="header-anchor" href="#坐标与向量">¶</a>坐标与向量</h2>
<p>Unity使用左手坐标系，三轴的相对位置依照下图所示。与数学立体几何中的一般表示不同，在这里Z轴代表的是“深度”而不是“高度”。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99508:/Y3NegGcqRf1EUOM.jpg?authkey=AIbyrqnS5z58phc" alt="左手坐标系"></p>
<p>Unity包含了一些用于进行向量运算的方法，它们基本被放在<code>Vector2</code>和<code>Vector3</code>类里。</p>
<p><code>Vector3</code>里包含了一些常用向量，以(0,0,1)为<code>forward</code>（依照上面的坐标手势，中指指向前面），有<code>up</code>、<code>down</code>、<code>left</code>、<code>right</code>、<code>back</code>，以及(0,0,0)的<code>zero</code>和(1,1,1)的<code>one</code>。<code>Vector2</code>里没有z轴，故没有<code>forward</code>和<code>back</code>。</p>
<h2 id="游戏对象、组件，及其开关"><a class="header-anchor" href="#游戏对象、组件，及其开关">¶</a>游戏对象、组件，及其开关</h2>
<p>一个游戏对象（GameObject）可以拥有多个组件（Component）。</p>
<p>比如一个简单的点光源，其本身是一个<code>GameObject</code>。首先它有一个<code>Transform</code>组件标示其位置、旋转、缩放等信息，还得有一个<code>Light</code>组件让它发光。也许，还有若干用于控制这个点光源的脚本组件。</p>
<p>如果我们关闭这个游戏对象（我们把它叫做激活/停用），那么这个灯整个就从场景中消失了。用游戏对象的<code>SetActive(bool value)</code>方法来实现这一点。</p>
<p>需要注意的是，如果游戏对象有多层结构，将一个父对象停用并不会使其子对象停用（虽然效果上，子对象也消失了）。查看一个对象到底是在层级中被激活还是本身确实在场景里激活了，可以用游戏对象的activeInHierarchy()和activeSelf()方法来确定。</p>
<p>要关掉灯，除了让灯凭空消失，我们当然还有更正常的做法。每一个组件都有一个bool类型的<code>enabled</code>标志位，只要把这个标志位设为<code>false</code>，就能去使能（禁用）这个组件。如将点光源的<code>Light</code>组件禁用，光是没了，但灯依然还在原处。</p>
<blockquote>
<p>今天先记到这里好了。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Unity</tag>
        <tag>C Sharp</tag>
        <tag>游戏</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity脚本开发学习笔记 贰</title>
    <url>/2019/11/18/Unity%E8%84%9A%E6%9C%AC%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B4%B0/</url>
    <content><![CDATA[<p>书接上文。</p>
<h2 id="按键控制"><a class="header-anchor" href="#按键控制">¶</a>按键控制</h2>
<p><code>Input.GetKey</code>和<code>Input.GetButton</code>两种方法用于获取按键情况。</p>
<p>区别在于，Key有确定的KeyCode。KeyCode是Unity内置的枚举类，内含各种键盘、手柄按键，如空格键就由<code>KeyCode.Space</code>表示。</p>
<p>而Button是可以自定义详细配置的。在<code>Edit-ProjectSettings-Input</code>中可以对输入进行详细配置，为一种操作提供一个字符串别名。只要使用<code>GetBotton(string str)</code>就可以监测对应的输入了。</p>
<p>除了知道按键是否被按下之外，我们还需要确切地知道按键在哪一帧被按下，哪一帧被松开。 因此，这两个方法都有衍生的<code>GetxxxDown</code>和<code>GetxxxUp</code>。在对应按键被按下后的第一帧，<code>GetKeyDown</code>返回true，而到了第二帧，它就再次返回false了。同理，<code>GetKeyUp</code>也仅在松开按键后的第一帧返回true。</p>
<p>当然，这些方法都应该被放在Update()函数里，这样才能在每一帧对按键进行监测。</p>
<span id="more"></span>
<h2 id="摇杆控制"><a class="header-anchor" href="#摇杆控制">¶</a>摇杆控制</h2>
<p>确切地讲，这里应该是“轴”而不是摇杆。不过比起按键，摇杆更能体现“轴”的涵义，虽然按键确实也可以作为轴。</p>
<p>摇杆控制就比较麻烦了，因为按键只有按下与没按下两个状态，可以简单地用bool值表示，但摇杆有推移的距离，只能用浮点数表示。而且摇杆还有反向。</p>
<p>对于这些特性，GetKey之类的方法显然无法处理，所以需要使用<code>Input.GetAxis</code>。</p>
<p><code>Input.GetAxis</code>的参数是称为<code>axisName</code>的字符串，可以在<code>Edit-ProjectSettings-Input</code>中定义。其返回的是一个-1到1之间的浮点数，<code>Positive Botton</code>使其返回正值，而<code>Negative Botton</code>让其返回负值。</p>
<p><code>Sensitivity</code>和<code>Gravity</code>决定了按键触发/松开时返回值多快地上升/归零。</p>
<p>此外还有<code>Dead</code>值，这使得可以不对较小幅度的摇杆活动进行处理，一定程度上能够防止误触。<code>Snap</code>选项，其为true时如果同时触发了<code>Positive Botton</code>和<code>Negative Botton</code>，就返回0。</p>
<p>以上说的，是比较“完备”的摇杆控制，但是在很多时候我们并不需要这个“轴”返回浮点值。举个例子，《刺客信条：起源》中并没有以往的“奔跑”键，而是用摇杆推移的幅度决定移动速度，这就非常<code>GetAxis</code>。如果用键盘操作，WASD控制方向，是没有推移幅度这一说的，我们就当按下按键就是摇杆直接推到底，这就是<code>Type</code>属性为<code>Key or Mouse Button</code>而不是<code>Joystick Axis</code>的轴。无论如何，巴耶克并不是弹射起步，而是有gravity和sensitivity的作用。</p>
<p>但是，在东方的STG里就没有这些玩意，大家的运动都像加速度不存在一样。这种情况下，应当使用<code>Input.GetAxisRaw</code>方法，按键后返回的是1和-1这两个整数而非浮点数。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99509:/DIymHzGMqFd2kUu.png?authkey=AIbyrqnS5z58phc" alt="不可思议的幻想乡"></p>
<h2 id="重写和成员隐藏"><a class="header-anchor" href="#重写和成员隐藏">¶</a>重写和成员隐藏</h2>
<p>关于这一点，可以看看微软文档：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords">了解何时使用 Override 和 New 关键字</a>。</p>
<p>以前我以为“重写覆盖”是一个词，但今天发现似乎并非如此。</p>
<p>重写（Overriding，有人称为覆盖）是在派生类中重新实现基类中已有的方法和属性等，为了安全，基类中被重写的方法/属性需要有<code>virtual</code>修饰符（或者abstract、override），派生类重写的方法/属性需要有<code>override</code>修饰符。由于是重新“实现”，重写的方法签名/属性类型和名称必须和之前保持一致，也不能改变访问性，重写方法相当于只是重新编写了方法的函数体。</p>
<p>我的理解是，<strong>在派生类中重写之后，从基类继承下来的方法/属性就相当于不存在了</strong>。因此，不管我们把派生类的对象当成该类的对象还是其基类的对象，在直接调用方法时调用的都是重写之后的方法。</p>
<p>而成员隐藏则完全不同（Member Hiding，虽然也有人称其为覆盖），它虽然看上去是在派生类中用<code>new</code>修饰符重新定义了基类中已有的成员，<strong>但！是！</strong> 从基类继承下来的成员并没有消失，而是被<strong>隐藏</strong>了。如果我们把派生类的对象作为其基类的对象（Upcasting，向上转型），那调用到的就是被隐藏的基类成员。</p>
<p>总而言之，“覆盖”这个翻译是谁发明的？出来挨打！</p>
<h2 id="委托和事件"><a class="header-anchor" href="#委托和事件">¶</a>委托和事件</h2>
<p>委托（delegate）可以被当作函数指针。要定义委托，首先需要用<code>delegate</code>关键字声明一个模板，模板展示了这种委托应该存放怎样的函数——用其返回类型以及参数列表来限定。</p>
<p>可以把委托名直接当成函数名来用。</p>
<p>委托支持“多播”，这使得我们可以把同一类型的函数集中放到一个委托里，只要调用这个委托，就是依次调用委托中函数列表里的函数。用<code>+=</code>和<code>-=</code>运算符把函数加入委托或从委托中删除。</p>
<p>最初看到多播委托这里，我还没有领会这个机制的用处，但很快我就看到了“事件”。</p>
<p>事件就是一种特殊的委托，或者说它非常类似于公共的多播委托。我们在定义委托的基础上使用<code>event</code>关键字定义一个事件。</p>
<p>对于同一个事件，不同的对象可能有不同的反应，也就有不同的处理函数。如果把唤起事件视作调用委托，那么一系列的事件处理函数就是委托的函数列表，要订阅或取消订阅事件的话，用<code>+=</code>和<code>-=</code>就好了。</p>
<h2 id="协程和生成器"><a class="header-anchor" href="#协程和生成器">¶</a>协程和生成器</h2>
<p>看到C#协程（Coroutine）里熟悉的<code>yield</code>，我想到的是此前在Python中学到过的生成器（Generator）。简直是一个套路，运行到yield时，函数返回，但下次调用该函数时不会再从头执行，而是从上次退出的地方之后开始执行。</p>
<p>实际上生成器就是协程的一种，称为半协程（Semi-coroutine），这是一种受限制的协程实现。</p>
<p>在这里面学问很深，我才疏学浅暂且接触不到，这里就贴个知乎专栏链接吧：</p>
<p><a href="https://zhuanlan.zhihu.com/p/25513336">Coroutine从入门到劝退 - 王迅的文章 - 知乎</a></p>
<blockquote>
<p>暂时就记到这里了。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Unity</tag>
        <tag>C Sharp</tag>
        <tag>游戏</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏分析框架学习笔记 壹</title>
    <url>/2019/11/20/%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A3%B9/</url>
    <content><![CDATA[<h1>游戏学的常用框架</h1>
<h2 id="MDA"><a class="header-anchor" href="#MDA">¶</a>MDA</h2>
<blockquote>
<p>M：Mechanics，机制——数据层面上的组件与算法。<br>
D：Dynamics ，动态——对输入输出的实时响应。<br>
A：Aethetics，美学——交互唤起的情绪反应。</p>
</blockquote>
<p>需要注意的是，由于游戏机制上的一点点变化就会在动态上引发动态上的大变化，进而在美学上引发巨大变化，因此游戏机制的调整是应该慎之又慎的。</p>
<p>对于设计者，<strong>首先应该敲定想要玩家体会到的美学，据此来创造动态和机制。</strong> 怎样的动态能展现这样的美学？怎样的机制能产生这样的动态？</p>
<p>而对于玩家，首先接触到的是机制，即游戏的规则，由此产生动态，在动态中体会到设计者预想的美学。</p>
<span id="more"></span>
<h2 id="形式、戏剧和动态元素"><a class="header-anchor" href="#形式、戏剧和动态元素">¶</a>形式、戏剧和动态元素</h2>
<blockquote>
<p>形式：与媒体和互动无关的游戏的骨架，包括规则、资源和界限。<br>
戏剧：剧情、叙事、设定。这使得游戏成型，使玩家理解规则，产生共鸣。<br>
动态：游戏运行的状态，包括决策、行为、游戏实体间的联系。这里的动态范畴比MDA中的更大。</p>
</blockquote>
<h3 id="形式元素"><a class="header-anchor" href="#形式元素">¶</a>形式元素</h3>
<p>形式元素是不可或缺的部分，如果移除了若干形式元素，可能就无法被称得上是游戏。</p>
<p>形式元素有以下几种：</p>
<ul>
<li>玩家交互模式：单人？团队？乱斗？合作？……</li>
<li>目标：目的是什么？如何获取胜利？</li>
<li>规则：玩家能做些什么？</li>
<li>过程：在规则之下玩家做了什么？</li>
<li>资源：哪些东西是有价值的？</li>
<li>边界：游戏与现实的界限在哪里？</li>
<li>结局：游戏如何结束？</li>
</ul>
<h3 id="戏剧元素"><a class="header-anchor" href="#戏剧元素">¶</a>戏剧元素</h3>
<ul>
<li>前提：游戏世界的背景故事。</li>
<li>角色：故事中的人物。是角色为玩家代言？还是玩家遵从角色意志？</li>
<li>戏剧：游戏的情节，包含所有的叙事。</li>
</ul>
<h3 id="动态元素"><a class="header-anchor" href="#动态元素">¶</a>动态元素</h3>
<ul>
<li>涌现：简单的规则带来动态的游戏体验。要充分理解规则的内涵。</li>
<li>涌现叙事：玩法本身可能催生动态的叙事。</li>
<li>试玩：多多试玩才能理解游戏的动态运行。</li>
</ul>
<h2 id="四元法"><a class="header-anchor" href="#四元法">¶</a>四元法</h2>
<h3 id="机制"><a class="header-anchor" href="#机制">¶</a>机制</h3>
<p>四元法中的“机制”不同于MDA所说的机制，它指的基本上是上文提到的“形式元素”。</p>
<h3 id="美学"><a class="header-anchor" href="#美学">¶</a>美学</h3>
<p>四元法的“美学”是能被五感直接感受到的艺术部分，这一点也与MDA中的美学不同（后者指的是游戏触动的情绪）。这是四元中最为明显的一个。</p>
<h3 id="技术"><a class="header-anchor" href="#技术">¶</a>技术</h3>
<p>游戏使用的所有技术都包含于此——硬件、软件、渲染管线等等。桌面游戏的骰子、卡组、表格等等按照四元法角度也算在技术之中，而不是机制。这是四元中最隐蔽的一个。</p>
<h3 id="剧情"><a class="header-anchor" href="#剧情">¶</a>剧情</h3>
<p>四元法的剧情即是上文提到的“动态元素”。</p>
<h2 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h2>
<p>看到这里，我几乎是一脸懵逼，这三种分析方法都让我感到各有道理却又混乱不堪。尤其是四元法，初看总觉得哪里不太对？</p>
<p>但是实际上，这就是把一个游戏拆分成几个职位各自的负责部分——分属于设计师，艺术家，程序员和编剧。</p>
<p>最后我看到一句话：</p>
<blockquote>
<p>分层四元法结合并扩展了上述的所有框架。</p>
</blockquote>
<p><strong>所以既然这么好用，为什么不早点说！！</strong></p>
<h1>分层四元法</h1>
<p>分层四元法分为三层——内嵌层、动态层和文化层。每一层都由上面四元法的四种元素构成。但我们把“剧情”改称为“叙事”，这一概念更加广泛，可以涵盖背景、角色、情节。</p>
<p>我的理解是，内嵌层上思考的重点是“游戏应该是怎样的？”；动态层上则是“玩家会怎样进行游戏？”；文化层上是“游戏能否具有某种现实意义？”。</p>
<blockquote>
<p>至于分层四元法的详细阐释与分析，明天再写吧。</p>
</blockquote>
]]></content>
      <tags>
        <tag>游戏</tag>
        <tag>笔记</tag>
        <tag>游戏学</tag>
      </tags>
  </entry>
  <entry>
    <title>收集东方Alphes风立绘素材</title>
    <url>/2019/11/21/%E6%94%B6%E9%9B%86%E4%B8%9C%E6%96%B9Alphes%E9%A3%8E%E7%AB%8B%E7%BB%98%E7%B4%A0%E6%9D%90/</url>
    <content><![CDATA[<p>策划着要制作游戏的时候，就想着大概需要弄一些立绘。对于东方同人游戏，最好的立绘莫过于<s>ZUN绘</s>黄昏风了。黄昏边境的立绘画师早为Alphes，后为春河萌，现在又拉出了TOKIAME，不过由于非想天则的巅峰，资源最多的应该还是Alphes风格，这也是长期以来俗称的“黄昏风”。</p>
<p>《东方萃梦想》的Alphes妖梦：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99512:/h7VEtAqfgsz1YkC.png?authkey=AIbyrqnS5z58phc" alt="Alphes妖梦"></p>
<p>《东方深秘录》的春河萌秦心：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99513:/MCnbfwBgiDke3ur.png?authkey=AIbyrqnS5z58phc" alt="春河萌秦心"></p>
<p>TOKIAME绘制的蓬莱山辉夜：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99514:/UyJcEqauVIt28C5.jpg?authkey=AIbyrqnS5z58phc" alt="纯米大吟酿 蓬莱泉辉夜"></p>
<p>为了寻找Alphes风立绘，我最初是在Pixiv搜索<code>東方　立ち絵</code>，然后就发现了<a href="https://www.pixiv.net/member_illust.php?id=743845">kaoru</a>这个作者，他绘制了大量不错的Alphes风格立绘，并且全都可以自由进行非商业使用。依照说明我来到了他的站点<a href="http://gensoukyou.1000.tv/">幻想幽玄庵</a>，这里有几乎所有正作角色的立绘素材，绝大部分还带有<code>.psd</code>文件，这可太有用了。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99515:/8mSVtWT4jq5vEaY.jpg?authkey=AIbyrqnS5z58phc" alt="kaoru id=743845"></p>
<p>依照幻想幽玄庵这个大概是社团名的名称，我又在THBWiki上找到了<a href="https://thwiki.cc/Alphes%E9%A3%8E%E7%AB%8B%E7%BB%98%E7%B4%A0%E6%9D%90">Alphes风立绘素材</a>页面，这里给出了<code>CharacterNentoka机</code>这个软件，可以在不用PS的情况下更加方便地生成立绘。我暂时就不用这个了，虽然没有Photoshop，但我装了Krita，试着熟悉一下操作好了。</p>
<p>另外，Pixiv还有一位大量绘制Alphes风立绘的画师<a href="https://www.pixiv.net/member_illust.php?id=4920496">dairi</a>，甚至其画风更加精致，也有更多的新人物素材（看得出来他的画技是在逐步提高的）。结合这两位dalao的资源，凑齐一套立绘应该是不成问题的了。</p>
<p>目前暂时想到要使用的角色有这么几位，立绘都已经能够找齐了：</p>
<ul>
<li>魂魄妖梦</li>
<li>鬼人正邪</li>
<li>秦心</li>
<li>西行寺幽幽子</li>
<li>博丽灵梦</li>
<li>魂魄妖忌</li>
<li>……</li>
</ul>
<blockquote>
<p>啊——社区这种东西果然还是便利啊。</p>
</blockquote>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>图像</tag>
        <tag>东方Project</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏分析框架学习笔记 贰</title>
    <url>/2019/11/21/%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%B4%B0-%E5%88%86%E5%B1%82%E5%9B%9B%E5%85%83%E6%B3%95/</url>
    <content><![CDATA[<p>本节讲述<code>分层四元法</code>框架。</p>
<p>从这里开始，内容十分庞杂，我只将值得记录的部分记下来。</p>
<h1>内嵌层</h1>
<p>游戏的最终目标也许是“为了赢”，但这是最“长期”的目标，为了实现长期目标，许多个短期、中期目标必不可少。这些目标有轻重缓急，其间也许还会有互相冲突。</p>
<p>游戏的视觉与听觉是最能被直观感受到的美学内嵌，也比机制对情绪的影响力有效得多。</p>
<p>叙事内嵌需要着重讲讲。</p>
<h2 id="叙事内嵌"><a class="header-anchor" href="#叙事内嵌">¶</a>叙事内嵌</h2>
<h3 id="传统戏剧"><a class="header-anchor" href="#传统戏剧">¶</a>传统戏剧</h3>
<p><strong>五幕结构：</strong></p>
<ol>
<li>铺垫：介绍前情、设置、重要角色</li>
<li>情节上行：发生故事，使重要角色与戏剧间的张力上升</li>
<li>高潮：汇集前面的所有剧情，矛盾达到顶点</li>
<li>情节下行：高潮引发的后果，剧情向结尾发展</li>
<li>结局：故事的结末</li>
</ol>
<p><strong>三幕结构：</strong></p>
<ol>
<li>第一幕：铺垫<br>
首先以“钩子”开头，足够刺激以迅速勾起观众注意；<br>
然后引发事件，让事件进入主角生活，主角开始启程；<br>
第一幕与第二幕之间是第一戏剧点，自此真正的故事开始。</li>
<li>第二幕：对抗<br>
第二幕是故事的主要发展，主角经历一系列坎坷，情节推进到第二戏剧点。<br>
第二戏剧点使主角作出重大决定，由此走向结局。</li>
<li>第三幕：结局<br>
故事的高潮往往接近尾声，所有冲突汇集，悬念落下之后不久，故事即结束。</li>
</ol>
<span id="more"></span>
<h3 id="互动叙事与线性叙事的区别"><a class="header-anchor" href="#互动叙事与线性叙事的区别">¶</a>互动叙事与线性叙事的区别</h3>
<p>互动叙事基本上不可能是完全的自由，本质上依然限制着可能性。支线、伏笔、NPC，都是可以在玩家的选择之外影响剧情走向，控制情节的元素。</p>
<p>互动叙事中的主角是玩家的化身，因此不可避免地，玩家的真实性格也许会与角色的性格错位。这种分歧有时却是可以被妥善利用的。</p>
<blockquote>
<p>内嵌层的要素是静态的，也是开发者唯一可以完全掌控的部分。而到了动态层，游戏就成为了涌现。</p>
</blockquote>
<h1>动态层</h1>
<p>玩家使游戏从内嵌层走向动态层，从一系列要素转变为一种体验。</p>
<p>这之中，最重要的概念就是<code>涌现</code>。它能使简单的规则产生复杂的动态行为，即多种多样的玩法和游戏体验。但涌现也有大致的规律，可以部分为开发者所预测并引导。</p>
<p>动态机制的思考应该<strong>让游戏能够倾向于策略性</strong>，为玩家提供多种获胜选择。游戏的机制会逐渐将玩家导向“最优策略”指引下的行动，这一点是可以用于展现美学设计的。</p>
<p>动态美学在游戏进行时产生，其中“过程美学”是用代码逻辑生成的，可以被开发者控制；而“环境美学”与游戏在玩家手中运行的物理环境（分辨率、音质，乃至光敏性癫痫）有关，基本不受控制。因此，主要讲过程美学。<strong>过程美学是随着游戏的进行，根据玩家的行为动态产生的音乐与美术等。</strong> 动态的音乐和音效、粒子系统、过程动画，乃至Minecraft中随机生成的世界地貌都属于过程美学。</p>
<p>真正的动态叙事是难以在电子游戏中实现的，可能只有在龙与地下城中才能见到。它是更高级的涌现形式，甚至能涌现出在内嵌层的设计之外，却在情理之中的行为。</p>
<p>动态技术，可以将它理解为涌现的各种行为对软硬件的影响，这一点几乎与游戏设计不沾边了。</p>
<h1>文化层</h1>
<p>文化层已经走向了游戏之外，几乎脱离了游戏本身的互动体验。</p>
<p>这个层面的元素基本上由社区、MOD、同人展现。</p>
<p>需要注意的是，由开发者授权的跨媒体不属于文化层，而是具有其本身的内嵌层。</p>
<hr>
<blockquote>
<p>今天实在摸了些鱼，进度不多。</p>
</blockquote>
]]></content>
      <tags>
        <tag>游戏</tag>
        <tag>笔记</tag>
        <tag>游戏学</tag>
      </tags>
  </entry>
  <entry>
    <title>191122</title>
    <url>/2019/11/22/191122/</url>
    <content><![CDATA[<p>10月24日之后又过了快一个月，这一个月我干了些什么？</p>
<ul>
<li>进入IFPR研究所实习，写了一点点代码；</li>
<li>从完全不会C#到现在理解了基本概念的水平；</li>
<li>对Unity有了初步的了解；</li>
<li>Markdown的写作进一步熟练；</li>
<li>联系到了不错的毕业设计导师；</li>
<li>拿到了感兴趣的毕业设计课题；</li>
<li>开始学习游戏设计理论；</li>
<li>同人ARPG「東方珀露澗 ~ Aurora of Dragon Lore.」立项。（就在刚才）</li>
</ul>
<p>最重要的是没那么丧了，因为得以去实验室搬搬砖，看到自己的代码在体量庞大的系统里运转还是略有成就感的。也正是因为这里曾经热衷于独立游戏开发，如今只以“巨神”之号流传江湖的实验室导师，让我开始走上这条邪路。</p>
<p>下午着实是焦虑不堪，乃至去空间发了条动态。</p>
<blockquote>
<p>log_191122<br>
焦虑，焦虑永远是学习路上最大的障碍。<br>
得知身边的人一个个已经或即将上岸，得到了飞升一般的进化，而自己还在走一条看不到还有多远，更不知通向何处的道路，想不焦虑都难！<br>
我可太需要休息和放空思想了，但光阴似箭，deadline不我待，停下来的一时一刻都是愧疚的煎熬。<br>
功不唐捐…功不唐捐！为何要妄自菲薄呢？<br>
明明要吃饱穿暖，在这个时代还并不是那么难。<br>
我又在胡乱分析些什么呢。真正的进取之人会有无病呻吟的闲情逸致吗？喝口水，Keep Calm and Carry On。</p>
</blockquote>
<p>今天虽然没有设计理论上的学习进度，但经过一整天的查文献和开脑洞，总算是有了个大致的背景设计思路，然后又“咬文嚼字”地定了个标题。万事开头难，这算是开了个头？不过这个标题现在看来总感觉过于直白，甚至一下就能看出许多端倪——果然ZUN的“起名字程度的能力”令人无法望其项背。</p>
<p>这几年为了“考据”陆陆续续购买的民俗学资料，如今也能派上一点用场了。</p>
<p>那么明天就继续学习游戏设计理论，接下来仔细打磨我的构想，能在十二月到来前正式开工就太好了。然后在寒假前弄出基本的框架……害，越说越远了，开发计划应该等理论基础充实一点再订。</p>
<p>再过两个节气即是冬至，一个我似乎有很多印象又似乎没有的时间点。那时我能不能有更现实的进步呢？</p>
<blockquote>
<p>己亥小雪。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>关于“涌现”的思考</title>
    <url>/2019/11/23/%E5%85%B3%E4%BA%8E%E2%80%9C%E6%B6%8C%E7%8E%B0%E2%80%9D%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>“涌现”可以说是相当重要，我认为它是一个与重复游玩密切相关的概念。涌现导致不同的游戏体验，而单个玩家感受不同游戏体验的方法就是换种思路重复游玩。这可以说是游戏可玩性的一种代表。</p>
<p>我需要着重参考的非东方游戏中有《Enter the Gungeon》和《元气骑士》。想到这里我发现了一个共同点，它们都用多样的自机天赋、武器、技能、Buff实现了“涌现”。</p>
<p>但我是否需要这样做呢？以上两个游戏都是Roguelike类型，甚至连随机生成的地图都高度体现着“涌现”，具有高度的重复游玩性，但我想要做的是一个拥有线性叙事的游戏。</p>
<p>枪牢用“杀死过去的枪”这个线索巧妙地把重复的游玩变成一定程度上的线性叙事，元气骑士则完全不在意这个，剧情只是随口一说，花式推地牢才是其核心。</p>
<p>其他游戏是怎么做的呢？如果是自由度高的大型游戏，极长的主线首先就无须让人进行重复游玩。如果要体现“涌现”，无数的支线任务、收集要素、角色养成就能体现作用。</p>
<p>《战地1》这种游戏，其单人模式根本就是多人竞技模式的新手教学，而多人竞技模式中的涌现是由多名玩家的行为共同构建的。</p>
<p>还有《黑暗之魂》、《只狼》这样的，虽然剧情趋于线性，但提供多结局且难度极高，多周目还能继续提高难度，专供想要挑战自己的玩家食用。</p>
<p>想来想去，我要做的游戏可能在内嵌层上更接近于STG游戏（或者说，和STG一样古老的形式？）。STG是怎么做的呢？</p>
<span id="more"></span>
<p>就拿东方正作来说：</p>
<p><strong>提供了多种自机</strong>——比起枪牢那种自机选择只影响天赋的机制，STG中的自机还与其攻击手段对应，这使得不同机体的游玩体验可能大大不同。</p>
<p><strong>固定的少量资源</strong>——在奖残吃满的情况下，能够使用的雷与残的总量基本固定，如何合理分配这些资源来提高通关可能？由于设计上基本不会能让人仅靠拼资源就能顺利通过每一个难点，所以策略是因人而异的，这也是一种涌现。</p>
<p><strong>不同的难度等级</strong>——但是对于没有游玩经验的玩家，即使是Easy难度可能都需要多次游玩进行反复练习。要求不续关完整通关（甚至必须是Normal及以上难度）才能到达Good Ending，这种机制也在增加玩家的游玩时间。</p>
<p><strong>额外的Extra关卡</strong>——完整通关之后才能够解锁的Extra关卡。长度较长，难度较高且有大量初见杀，需要反复练习。这个部分不怎么体现“涌现”，基本是用于补充说明剧情以及延长游戏时间。</p>
<p>这时候，查到一篇讲涌现式游戏设计的文章：</p>
<p><a href="https://www.chuapp.com/?c=Article&amp;a=index&amp;id=285949">涌现式游戏设计：《荒野大镖客：救赎2》和开放世界的未来</a></p>
<p>看来，涌现式的游戏设计固然好，但是并不适合刚刚起步的我。</p>
<p>买了份华彩乱战玩了玩，“就这？就这？就这？”之声充斥我的脑海，不过细细一想，工程量还是不小，毕竟我才打到二面。不过基本的风味还是懂了，一言蔽之——**没内味儿！**说到东方，我印象里最棒的就是永夜抄和风神录那种匠气打造的爽快感了吧……关于这个可能需要另外的分析。</p>
<p>不过买还是要买的，玩还是要接着玩的，支持天朝同人嘛。</p>
<iframe src="https://store.steampowered.com/widget/1124830/" frameborder="0" width="646" height="190"></iframe>
<p>好像又和“涌现”没啥关系了。我想到导师给我报错了的课题，写的是“DBG游戏”，这让我有点联想到非想天则那几款FTG，符卡不亦是卡吗？符卡的组合不也是Deck Building吗？也许这个方向可以有更多的想法。</p>
]]></content>
      <tags>
        <tag>游戏</tag>
        <tag>游戏学</tag>
      </tags>
  </entry>
  <entry>
    <title>游戏设计理论学习笔记 壹</title>
    <url>/2019/11/24/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E7%90%86%E8%AE%BA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A3%B9/</url>
    <content><![CDATA[<h1>迭代设计</h1>
<p><strong>游戏设计由1%的灵感和99%的重复组成。</strong></p>
<p>分析-&gt;设计-&gt;实现-&gt;测试-&gt;分析……</p>
<p>这就是迭代设计的流程。</p>
<h2 id="分析"><a class="header-anchor" href="#分析">¶</a>分析</h2>
<p><strong>面向的玩家群体？</strong> 这决定了游戏里应该有哪些要素。无论，做这个游戏的目的是毕业设计，面向的群体就是<s>评审老师</s>我自己了。如果能有些弹幕爱好者玩就更好了。</p>
<p>这么一想，应该像STG一样有多难度级别，还要有计分系统给人刷。但是我向来都不在意分数。或者像《东方梦想曲》那样做得极难但不限重试次数，这就很亲民——其实更符合的应该是绀珠传。</p>
<p><strong>我有什么资源？</strong> 当然，只有我自己的一百天左右时间，以及网络上配布的相关素材。</p>
<p><strong>现有技术有什么？</strong> 现有技术指与要设计的作品相关联的<strong>现存游戏及其他媒介</strong>。对我来讲，具体的是Unity引擎，东方Project的大量官方以及同人游戏。同人游戏中可以着重参考的是登陆steam的几部作品，《东方红辉心》、《永远消失的幻想乡》、《东方华彩乱战》。还有些不属于东方但类型相似的游戏，比如《Enter the Gungeon》和其模仿者《元气骑士》等。</p>
<p><strong>如何尽快制作原型？</strong> 高效利用时间，优先开发<strong>核心机制</strong>并进行测试。美工、音乐等外观要素可以在后期进行处理。</p>
<p>设计、实现和测试，此处不必多讲。</p>
<span id="more"></span>
<h1>创新：头脑风暴</h1>
<blockquote>
<p>尽可能的多想点子，再扔掉那些不好的。</p>
</blockquote>
<ol>
<li>拓展阶段，围绕一个主题，任意联想发散。</li>
<li>收集阶段，将所有的想法依次写到卡片上。</li>
<li>碰撞阶段，任取两张卡片用来思考。</li>
<li>评分阶段，筛选出一些最好的点子。</li>
</ol>
<h1>开发阶段</h1>
<p>设计与开发是非常曲折的过程。几乎没可能在不对原本想法进行任何变化的情况下直接实现成品，而是一个初始原型激发更多灵感，促使制作出第二个原型，然后逐步演化为一部优秀的作品。</p>
<p>标准的游戏开发分为以下阶段：</p>
<ol>
<li>制作前：试验不同原型，最终制作出一个简短但能表现预期成品的整体样貌的Demo。</li>
<li>制作：及早确定游戏机制等系统设计，然后是关卡设计、美学要素等。以Demo为核心作出相应的高完成度内容。</li>
<li>内部测试：系统设计已经100%确定，针对测试中出现的问题和Bug进行修改。</li>
<li>Beta测试：作品基本完成，只对找出的余下Bug进行修复，而不作出任何更改。</li>
<li>黄金阶段：CD-ROM时代，压制盘碟的母盘是黄金制的。这个阶段代表游戏已经完全可以发布。</li>
<li>发售后：修改、调整、开发DLC……</li>
</ol>
<p><strong>过多的内容是游戏项目的第一杀手！</strong> 裁剪！裁剪！裁剪！</p>
<h1>以玩家为中心的目标</h1>
<h2 id="趣味性"><a class="header-anchor" href="#趣味性">¶</a>趣味性</h2>
<p>游戏的趣味性由<strong>乐趣性、吸引力和满足感</strong>组成。</p>
<p>乐趣性是让人愉快的要素，包括竞争、赌博（概率性）、感知与模仿。</p>
<p>吸引力是抓住玩家注意力，使玩家沉浸的要素。</p>
<p>满足感是指作品的游玩过程需要满足玩家的一些愿望。</p>
<h2 id="游戏性态度"><a class="header-anchor" href="#游戏性态度">¶</a>游戏性态度</h2>
<p>游戏性态度是指<strong>玩家愿意全身心投入到游戏中去的态度</strong>。只有玩家愿意全身心投入，才会保持良好的心态并遵守规则。从这个角度，应该注重<strong>尊重玩家而非利用他们</strong>。</p>
<h2 id="心流"><a class="header-anchor" href="#心流">¶</a>心流</h2>
<p>对于玩家的能力，如果游戏难度一直太高，会导致挫败感；难度一直太低，就会无聊。</p>
<p>需要让玩家感受到游戏的难度和<strong>获胜的机会</strong>。具有一定的挑战性让玩家刚刚好能够不断进步，并且要有明确的最优目标，让玩家的每次进步立刻能得到反馈（进步会让玩家更靠近最优目标，从而感受到自身的进步）。</p>
<p>在这种<strong>挑战——提高——反馈——新一轮挑战</strong>的循环波动中，玩家能集中投入，进入“心流”，带来难以忘怀的体验。要注意的是，虽然心流是非常理想的状态，但其<strong>难以持续15-20分钟以上</strong>。因此，更好的做法是间断性地营造心流，其他时间可以降低些许难度，让玩家感受自己能力的提升与强大。这也许就是为什么高难度的BOSS战之后往往安排简单的关卡。</p>
<h2 id="冲突对抗"><a class="header-anchor" href="#冲突对抗">¶</a>冲突对抗</h2>
<p>冲突是玩家的需求之一。可以是玩家之间的竞争，也可以是玩家与游戏系统之间的对抗。</p>
<h2 id="力量感"><a class="header-anchor" href="#力量感">¶</a>力量感</h2>
<p>拥有内在动力（即自己设立目标的自由）的时候，玩家可以在心流中获得更大的愉悦。可以给玩家选择的机会，并且用多变的游戏机制让选择的多样性成为可能，这是具有一定自由度的游戏设计。</p>
<p>给玩家提供“表演”的权力，也是力量感的体现。</p>
<h2 id="关注和投入"><a class="header-anchor" href="#关注和投入">¶</a>关注和投入</h2>
<p>这个部分的原则和戏剧的三幕结构是基本吻合的。一个良好的兴趣曲线应该是以下的形式：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99516:/XEby5FwUW4Bs2QK.jpg?authkey=AIbyrqnS5z58phc" alt="兴趣曲线"></p>
<p>大型的游戏里设立结构性的任务，任务本身具有相应的兴趣曲线，并且从整个游戏的视野看也有相似的兴趣曲线，这就是理想的设计。</p>
<p><strong>这里试按照此兴趣曲线分析东方STG正作：</strong></p>
<p><strong>对于单独的一面</strong>，B是关卡开始而尚没有报关卡名的那一段，许多时候在这里会安排一些代表性的敌人来揭示这一关的主要内容，如辉针城4面开头的的阴阳玉☯激光中玉自机狙+大蝴蝶🦋竖直米弹，这一段简直紧张至极；还有永夜抄五面、六面开头突然蹦出的兔子🐇，会把四处乱飞的玩家打个措手不及。</p>
<p>接下来是C，短暂休息，出现关卡标题、BGM名称，音乐与场景随之进入正题，关卡正式开始。D是道中前半段，一般较有规律，稳扎稳打。随即进入E，道中BOSS出现。之后的F是道中后半段，可能较为混乱，也比较困难。最后短暂清空，到达G的关底BOSS处，开始激烈的符卡对决。</p>
<p><strong>从全盘来看</strong>，不包括Extra关卡的话，一面到六面则正好对应这里的B~G。虽然“自古三面出神曲”，但是二三面其实都没有在游戏的主题核心上更进一步，而是到了四面才真正进入主题。红魔乡、地灵殿四面进入馆中；绀珠传四面抵达月球；风神录里甚至到了四面关底才得知守矢神社的存在。因此除终盘外兴趣最高的一面是四面也就很显然了。</p>
<blockquote>
<p>嗯，这是设计剧情的良好参考。</p>
</blockquote>
<h2 id="令人感兴趣的决定"><a class="header-anchor" href="#令人感兴趣的决定">¶</a>令人感兴趣的决定</h2>
<blockquote>
<p>游戏应该是一系列有意义的决定组成的。<br>
—— Sid Meier</p>
</blockquote>
<p>怎样的决定是“有意义的”？以下是设计选项的一些原则。</p>
<ol>
<li><strong>辨别性。</strong> 系统要能领会玩家的意图。</li>
<li><strong>完整性。</strong> 玩家认为自己的决定能够造成长期影响。</li>
<li><strong>含糊不清。</strong> 玩家并不能完全确定决定造成的影响，只能作出猜想。</li>
<li><strong>清晰。</strong> 这与上一条并不冲突，清晰指的是选项表达的意思应该清晰明白，让玩家能凭直觉感受到选择可能带来的结果。</li>
<li><strong>双重效果。</strong> 决定带来的结果有积极的一面，也有消极的一面。</li>
<li><strong>新颖。</strong> 如果选项与玩家最近做出的决定有很大不同，那么选择就是新颖的。新颖的选择更能够吸引玩家的注意。</li>
</ol>
]]></content>
      <tags>
        <tag>游戏</tag>
        <tag>笔记</tag>
        <tag>游戏学</tag>
      </tags>
  </entry>
  <entry>
    <title>为Hexo博客添加全局APlayer播放器</title>
    <url>/2019/11/25/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80APlayer%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    <content><![CDATA[<div class="note info"><p>如果你只是想要在自己站点的左下角加一个极其Stable的音乐播放器，而不想听我废话自己踩的坑，请直接跳转：<br>
<a href="/2019/11/25/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80APlayer%E6%92%AD%E6%94%BE%E5%99%A8/#Show-me-the-CODE">“Show me the CODE!”</a></p>
</div>
<h1>早期尝试</h1>
<h2 id="网易云iframe"><a class="header-anchor" href="#网易云iframe">¶</a>网易云iframe</h2>
<p>今天，我试图解决一个历史遗留问题。</p>
<p>之前我博客上的音乐播放器一直都是网易云的外链iframe，就这个样式的：</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1384318412&auto=0&height=66"></iframe>
<p>我一直把这个玩意放在sidebar里。但是问题是，移动版视图下sidebar是不展示的，只有header能够显示出来，而且还需要用toggle展开。我使用的主题是<code>NexT</code>，试验了一下，需要修改的地方是：</p>
<p><code>\themes\next\layout\_partials\header\index.swig</code></p>
<p>由于toggle展开的是<code>site-nav</code>，将源码修改如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;&#123; partial(&#x27;_partials/header/brand.swig&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;site-nav&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; partial(&#x27;_partials/header/menu.swig&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;</span><br><span class="line">  <span class="comment">&lt;!--网易云iframe--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">marginwidth</span>=<span class="string">&quot;0&quot;</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">marginheight</span>=<span class="string">&quot;0&quot;</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">src</span>=<span class="string">&quot;//music.163.com/outchain/player?type=2&amp;id=1384318412&amp;auto=0&amp;height=66&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--网易云iframe end--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;%- if theme.algolia_search.enable or theme.local_search.enable %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;site-search&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; partial(&#x27;_partials/search/index.swig&#x27;, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;- next_inject(&#x27;header&#x27;) &#125;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99517:/Dmhzxi8XFIQK7np.jpg?authkey=AIbyrqnS5z58phc" alt="site-nav中的iframe.jpg"></p>
<p>这个效果属实🍔🍔。并且在桌面版视图下还会把sidebar压下去，不太理想。</p>
<span id="more"></span>
<h2 id="明月浩空音乐"><a class="header-anchor" href="#明月浩空音乐">¶</a>明月浩空音乐</h2>
<p>有没有悬浮式的播放器呢？有的。随便查一查就看到了这篇文章：<a href="https://leafjame.github.io/posts/2636059693.html">一款炫丽的网页播放器插件</a>，这里介绍了<code>绚丽彩虹播放器</code>，确实是够绚丽的，点进去一看还是个东方二次元，连域名都叫<code>badapple.top</code>，爱了。</p>
<p>一阵操作之后，预览的效果确实挺理想的，可是到我网站上就只能播放第一首曲子了，和上面那篇文章的评论区里一位老哥说的一模一样：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99518:/Sb8tgk2FZLrnu3i.jpg?authkey=AIbyrqnS5z58phc" alt="出现了绚丽的问题"></p>
<p>在我试图解决这个问题的时候，<code>badapple.top</code>突然就503了，回想起上面最后的更新日期是2018年，我就感到一阵不妙。不一会儿我就发现了和这绚丽播放器几乎<code> 完 全 一 致 </code>的替代品<a href="https://music.ain19.com/">AIP播放器</a>，并且找出了前面问题的解决方案。可是，这两个东西相似度怎么能够这么高？？</p>
<p>原来它们都是从<a href="https://player.lmih.cn/">明月浩空音乐</a>改来的，而这个原版是需要收费的。这明月浩空又是何许人也？传闻其名乃“李明浩”，这里有他不知真假的黑历史：<a href="https://www.chinasuc.cn/?thread-151.htm">关于Colorful2.6(明月浩空模板)后门剖析</a>。</p>
<p>本来如果我不太在意这个插件的安全性，折腾播放器的经历到这里就应该结束了。可是AIP播放器它不能自由修改主题色，而默认的颜色偏偏还是绿的，强迫症让我不能忍。看了看它的加载方式，是用<code>\theme\next\layout\_layout.swig</code>中插入的JS脚本加载远端服务器上的CSS，JS、CSS、播放列表都在远端，这可没法随便改了。</p>
<p>当然，也许我可以自己写一个CSS（在NexT里用的是Stylus）来覆盖它的设定——可惜我不会。</p>
<p>那咋办嘛，只能再看看有没有其他选择了。如此“简单”的需求难道会没有对应的开源软件吗？</p>
<h1>APlayer</h1>
<p>在寻找替代品的过程中，我曾看到过这篇文章：<a href="https://diygod.me/best-players-in-hexo/">可能是目前最好用的两个 Hexo 播放器插件</a>，讲的是开源的<a href="https://github.com/MoePlayer/hexo-tag-aplayer">hexo-tag-aplayer</a>，这是一个给hexo使用的<a href="https://github.com/MoePlayer/APlayer">APlayer</a>。</p>
<p>然而在看了它的文档之后，我没有第一时间get到它的点，特别是不知道要咋用。README.md里关于用法仅有一句：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name">aplayer</span> title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %&#125;</span></span><br></pre></td></tr></table></figure>
<p>这是个啥？当时我虽然知道Hexo的<code>Tag Plugins</code>，准确地说是NexT带来的<a href="https://theme-next.org/docs/tag-plugins/note">Bootstrap Callout</a>——不得不说，<code>Tag Plugins</code>这个名字起得真是沙雕，它太容易和<code>tags</code>混淆了——但是我因为没什么机会用到，并没有细看过它的格式，所以也并不明白这<code>&#123;% %&#125;</code>是个什么操作。</p>
<p>现在必须得找其他方法的话，那就只好研究一下了。看了些Issues才搞明白原来是写在md文件里的，这与我的想法背道而驰——我希望能放在所有页面的固定位置，如果能做到网易云音乐网页版那样跳转页面而播放进度不变就再好不过了。</p>
<p>经过一段时间的测试之后，我发现如果使用<code>hexo-tag-aplayer</code>最好的解决方案就是如这个<a href="https://github.com/MoePlayer/hexo-tag-aplayer/issues/58">issue</a>所言，在md里插入播放器后，再把生成的html文件里对应部分复制到header的<code>index.swig</code>里。可是这不就是个威力加强版的网易云iframe了吗？！</p>
<p>其实如果不是因为另一个问题，也还勉强能用。它的<code>fixed</code>模式（文档里翻译为“固定模式”）总让人感觉不太对劲，播放列表竟然是向上展开，如果放在header里，本来位置就很靠上，向上展开之后有一部分会伸出页面之外。虽然有一个默认值为<code>340px</code>的参数<code>listmaxheight</code>表示播放列表展开的高度，但我将其调为负值时，不但没有变成向下展开，而且还把播放列表倒过来了……</p>
<blockquote><p>当你感到迷惑，就应该去查Issues，大概率会有人和你遇到同样的迷惑问题。</p>
<footer><strong>沃兹·吉硕德</strong></footer></blockquote>
<p>所以我又查到一个<a href="https://github.com/MoePlayer/hexo-tag-aplayer/issues/79">issue</a>，什么？<code>吸底</code>？这正是我想要的——这说的不就是<strong>原版</strong>APlayer吗？！</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99523:/Rm4tpK1sBMrdcyT.jpg?authkey=AIbyrqnS5z58phc" alt="APlayer吸底模式"></p>
<p>在APlayer的文档里，对<code>fixed</code>模式的描述是<code>吸底</code>，这才是我所期望的功能，前面被“固定模式”这个沙雕翻译给整蒙了。那么，原版APlayer又是怎么用的呢？</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99519:/CBPWNdEnRqrUoHs.jpg?authkey=AIbyrqnS5z58phc" alt="APlayer入门"></p>
<p>看到这里，我的迷惑更上一层楼，有一定前端知识的人应该很快就能看懂这里在说什么，但是我显然不是……</p>
<p>好在这时看到这篇文章：<a href="https://cloud.tencent.com/developer/article/1157669">添加全站 APlayer 播放器</a>，看起来把这段代码加到<code>_layout.swig</code>的body里就OK了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aplayer&quot;</span> <span class="attr">data-id</span>=<span class="string">&quot;534542404&quot;</span> <span class="attr">data-server</span>=<span class="string">&quot;netease&quot;</span> <span class="attr">data-type</span>=<span class="string">&quot;song&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>但是依然不行：</p>
<blockquote>
<p>这里的外部调用链接没有包含版本号，默认加载最新 release 版本；正常来说不会出什么问题，但是如果需要 100% 稳定运行，建议自行加上版本号。</p>
</blockquote>
<p>事后发现这里加载的最新版本MetingJS是<code>2.0.0</code>，但实际上这个版本和APlayer根本不兼容，而MetingJS的文档却给人一种稳得一批的感觉：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99520:/tmUfeSh5KFILic7.jpg?authkey=AIbyrqnS5z58phc" alt="虚假的MetingJS文档"></p>
<p>（都不Supported你贴个啥APLAYER啊！！）</p>
<p>好，那就自己加上版本号。这里从<code>jsDelivr</code>引用了三个文件，APlayer的CSS和JS，Meting的JS。最新的（截至2019年11月25日）稳定版本使用如下，你也可以去<code>jsDelivr</code>自行查找。</p>
<h1>Show me the CODE!</h1>
<p>如果你和我一样使用<code>NexT</code>主题，请复制以下代码，定位到<code>\theme\next\layout\_layout.swig</code>，将其粘贴到body体内即可。如果是其他情况，<strong>大同小异！大同小异！</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引用依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/meting@1.2.0/dist/Meting.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 我使用的APlayer本体 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aplayer&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-id</span>=<span class="string">&quot;2465890057&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-server</span>=<span class="string">&quot;netease&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-type</span>=<span class="string">&quot;playlist&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-fixed</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-autoplay</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-order</span>=<span class="string">&quot;random&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-volume</span>=<span class="string">&quot;0.55&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-theme</span>=<span class="string">&quot;#cc543a&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-preload</span>=<span class="string">&quot;auto&quot;</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--如果将本体放在body里面导致页面加载出现问题，请尝试放到body体后面--&gt;</span></span><br></pre></td></tr></table></figure>
<p>APlayer的属性设置，请查阅<a href="https://aplayer.js.org/#/zh-Hans/?id=%E5%8F%82%E6%95%B0">APlayer中文文档-参数</a>以及能让你使用音乐平台的<a href="https://github.com/metowolf/MetingJS">MetingJS</a>。</p>
<blockquote>
<p><strong>注意：</strong> 如果你使用上述代码，请以<code>data-xxx</code>格式书写参数名！</p>
</blockquote>
<h1>Bonus：使用pjax，页面跳转不重新播放</h1>
<p><strong>最后一步！</strong></p>
<p><a href="https://music.163.com/">网易云音乐网页版</a>底部的播放器，无论在网易云里如何跳转页面，只要还在当前标签页都是不重新加载的，这样就可以使正在播放中的音乐不随页面跳转中断。怎样实现这个功能呢？</p>
<p><a href="https://www.zhihu.com/question/23720144">知乎-网易云音乐网页版底部的播放器是如何实现在切换网页时不停止播放音乐的？</a></p>
<p>这篇文章讲述了pjax的使用：<a href="https://cloud.tencent.com/developer/article/1096366">迷你音乐播放器及实现全站pjax无刷新加载</a></p>
<p>虽然不是专讲APlayer，但是大同小异，大同小异！我作为对前端没什么了解的人，就跟着这个路子踩坑吧。</p>
<p>需要添加pjax和<code>1.7.0</code>以上版本的jquery，我这里依然从<code>jsDelivr</code>引用，最好放在body体结束前：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- require JQuery --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- require pjax --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/pjax@0.2.8/index.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后按照以下方法使用pjax:</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99521:/gsN2MBVqIzCW9Uf.jpg?authkey=AIbyrqnS5z58phc" alt="使用pjax"></p>
<p><strong>然而，全部木大！</strong> 该跳还是跳了，也许是我姿势不对。</p>
<p>我转念一想，<code>NexT</code>这种历史悠久的主题，<code>pjax</code>这么好用的技术，岂有不内置的道理？鬼使神差之下，我打开主题的<code>_config.yml</code>一搜，还真的有：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Easily enable fast Ajax navigation on your website.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-pjax</span></span><br><span class="line"><span class="comment"># For moreinformation: https://github.com/MoOx/pjax</span></span><br><span class="line"><span class="attr">pjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>仅仅直接在这里把选项置为<code>true</code>是不行的，因为虽然配置文件里已经写了选项，但其实并没有安装对应的插件。关于如何使用，<a href="https://github.com/theme-next/theme-next-pjax">Dependencies</a>的文档里说得极为清楚，在此就不赘述了。</p>
<p>开启之后，全站都实现了无刷新加载，接下来你就随便戳吧，音乐始终会在左下角播放的。</p>
<p>至此，一整天的折腾之旅才算是终于告一段落了。</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>前端</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>Aseprite和Photoshop入门成果</title>
    <url>/2019/12/03/Aseprite%E5%92%8CPhotoshop%E5%85%A5%E9%97%A8%E6%88%90%E6%9E%9C/</url>
    <content><![CDATA[<p>由于准备solo操作，美工大部分就得自己搞定了。</p>
<h1>Aseprite</h1>
<p>Pixel Art其实很早就想玩一玩，不过之前一直没有找到合适的工具。如今因为要做游戏的任务驱动，终于开始尝试了。也因此，认真搜索资料之下就知道了<code>Aseprite</code>这个🐂🍺到爆炸的像素画制作软件，Steam售价38元，非常划算。</p>
<iframe src="https://store.steampowered.com/widget/431730/" frameborder="0" width="646" height="190"></iframe>
<p>我学习的是Youtube上MortMort这位小哥的教学视频，讲得非常清晰：</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/videoseries?list=PLR3Ra9cf8aV06i2jKmgKvcYVHI86-4K_b" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>如果没有代理，可以在bilibili观看该系列视频的<a href="https://www.bilibili.com/video/av14603015">第一部分</a>：</p>
<iframe src="//player.bilibili.com/player.html?aid=14603015&cid=23810173&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<p>这是我在还没有看教学视频之前，自己胡乱尝试下摸索了将近一整天完成的<a href="https://www.pixiv.net/artworks/78095634">第一幅作品</a>：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99522:/rWmnCw9V1uBeDH6.gif?authkey=AIbyrqnS5z58phc" alt="youmu"></p>
<span id="more"></span>
<p>虽然看起来比较憨憨，但是基本上熟悉了Aseprita的大部分功能。甚至，还进了Pixiv动图日榜？（说明一天根本没几张动图投稿嘛）</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99524:/SCUkuMRXxmgA5Yz.png?authkey=AIbyrqnS5z58phc" alt="进了排行榜？"></p>
<p>最大的感受就是，和制作了《幻想乡萃夜祭》的<a href="https://www.pixiv.net/member.php?id=205166">煮茶</a>julao相比，我画的就是个🔨！这种像素数少的画反而极其考验抽象思维能力和绘画功底，因为每一个像素都有其表现作用。如果精打细算充分利用的话，完全可以在极为有限的像素中表现出大量的细节，令人赏心悦目：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99525:/vmK8GTFi9q2QkVj.png?authkey=AIbyrqnS5z58phc" alt="煮茶NB！"></p>
<p>不过，我暂且还是程序员，不是专业像素艺术家，这边的技能树还是慢慢点吧……</p>
<h1>Photoshop</h1>
<p>Photoshop可谓是博大精深，我目前仅仅学习了PS CC自带的教程，能把它当作Windows画图高级版使用了……</p>
<p>这是今晚试着作出的東方project传统艺能启动页面：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99526:/u4XcFYiphUo8WS9.png?authkey=AIbyrqnS5z58phc" alt="启动页面"></p>
<p>其中使用的字体<code>汉仪昌黎宋刻本(原版)W</code>和<code>Mithril</code>来自<a href="http://www.hanyi.com.cn/font-list">汉仪字库</a>，汉仪确实是个非常nice的厂。</p>
<p>说到字体，就还有一个不错的网站：<a href="https://www.likefont.com/">识字体 - www.likefont.com</a>，顾名思义这就是个用图片识别字体的网站，准确度相当高。</p>
<p>那么明天试着把<code>少女祈祷中</code>弄上，再去Unity里做个游戏主界面？有了主界面怎能没有音乐……？得想法子整个活，把<code>623532 623532 623532 7175</code>的ZUN节传统艺能搞起来。</p>
<blockquote>
<p>所以说这一个星期我也太摸了吧……</p>
</blockquote>
]]></content>
      <tags>
        <tag>游戏</tag>
        <tag>动画</tag>
        <tag>图像</tag>
      </tags>
  </entry>
  <entry>
    <title>191207</title>
    <url>/2019/12/07/191207/</url>
    <content><![CDATA[<p>12月4日中午，腾讯代理的国行版Nintendo Switch发布，这也是我所一直等待的。</p>
<p>果不其然，锁服不锁区，eshop只能用国服，外区游戏能用实体卡但无法联机，并没能在索尼和微软之上更进一步，和当年的神游相比倒是略有放开。</p>
<p>虽然将来可能会爆出“后门”，但没个一年半载很难说。对我而言，虽然错过了双十一和黑五，但已经没有再等下去的必要了。未来的游戏从业者没有一台本世代的家用机，成何体统？于是当天下午，就以1888+310元的价格入手了日版续航增强Switch以及《宝可梦 剑》。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99528:/M2IrfnixCdL4TRj.jpg?authkey=AIbyrqnS5z58phc" alt="Switch开箱"></p>
<p>其实本来准备遵照传统从荒野之息开始，奈何店主没有，就买了宝可梦。说起来，虽然“神奇宝贝、宠物小精灵、口袋妖怪、精灵宝可梦”地过了这么多年，我却没有完整通关过任何一作，也算是童年一桩憾事。去年买到NDSL之后，也有一小段时间曾试着玩过著名的同人作品《口袋妖怪 漆黑的魅影》，不过也只打过两个道馆，然后就去《大航海时代》里开船了。因此，这次从拿到卡带的第一刻起，我就开始了近乎废寝忘食的攻略。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99527:/qnLSlNHK9fYB1Jj.jpg?authkey=AIbyrqnS5z58phc" alt="漆黑的魅影 剑"></p>
<span id="more"></span>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99529:/dI5v27siMfJt6Uz.jpg?authkey=AIbyrqnS5z58phc" alt="馆主"></p>
<p>三天时间里，我屡次错过饭点，两回凌晨三点才放下手柄，洗漱也是草草了事。每到一个新的地点，我就迫不及待去寻找时装店，在试衣间反复横跳试图弄出好看的搭配；我骑着自行车在旷野游荡，向训练家们掠夺食材；道馆挑战中期，某位仁兄用“魔法交换”送来Lv60的铜镜怪，让我顺风顺水地打过妖精和岩石道馆；草路镇外的麦田里间，我不知吹了多少次口哨，才得以遇到一只皮卡丘；极巨化团体战里，我带着波克基斯在一众大佬的无极汰那、苍响、藏玛然特之间瑟瑟发抖……</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99530:/NITFwGcpgqt8YOl.jpg?authkey=AIbyrqnS5z58phc" alt="伽勒尔的黎明"></p>
<p>据说这一作砍掉了不少东西，以至于让许多老玩家感到不满，但倒是很适合我这个宝可梦初心者。与“剑/盾”好像没啥关系的小学生作文剧情也可以说是“平平淡淡才是真”——毕竟露璃娜才是本作的精髓（不）。也许玩过六七世代之后我会觉得剑盾是什么“臭鱼烂虾”，但是在这几天里，我玩得确实很开心。</p>
<p>最终，我也有了自己的苍响：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99531:/IZCwoyAxi4R8ua7.jpg?authkey=AIbyrqnS5z58phc" alt="苍响"></p>
<p><strong>真有你的啊，游戏富力克！</strong></p>
<p>花了可能有三十个小时，我终于完全通关了《宝可梦 剑》。本来在今天凌晨这一“壮举”就已经完成，白天我应该再次投入到紧张的工作学习中去，毕竟我现在也没有其他卡带了……但是Nintendo Online会员的FC游戏合集又吸引了我，许多古老的经典游戏现在可以方便地“鉴赏”了。</p>
<p>作为姑且算是的STG玩家，首先游玩的就是早已多次听闻的《太空巡航机》（Gradius）。一开始真是没整明白它的武器升级系统，用单发子弹打到一面后半段，上中下全方位围追堵截，差点直接把我劝退。弄懂了系统之后，这30年前的游戏玩起来也是爽快得很。掉残就武器清空的设计依然不太亲民，好在如今有即时存档，乃至TAS般的“时间倒流”功能，不大功夫我就成功通关。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99532:/xj4VoHQew68MtEd.jpg?authkey=AIbyrqnS5z58phc" alt="太空巡航机"></p>
<p>可是这玩意它果然不止有一周目。在打过难度有所提高的二周目之后，面对逐渐丧心病狂的三周目，我果断选择了存档退出——再打下去恐怕该是无尽模式了。之后又了解到原来它的续作就是如雷贯耳的《沙罗曼蛇》，难怪感觉自机的形态十分相似。</p>
<p>接下来就是《双截龙2》，我曾玩过GameBoy版本的《双截龙》，当时就感到颇有难度，主要是出招十分玄学，打击感也不是那么好。这次玩2代，打人倒是感觉简单了些，可是后期各种地形杀和卡位简直恶心至极，第六关的一大堆跳台让我无数次落命，一气之下Quit。</p>
<p>然后是从i wanna和FGO知道的，要人命的《魔界村》。这里我没有注意说明，点开了摆在最上面的一个，谁知它竟然是直接从第六关开始的版本，游戏一开始我还没意识到自己在哪就暴毙了。试了几次果断退出，然后看到了下面的“正常”版本——正常个鬼啊！还是那么的难，我连第一关都过不了，不过多少了解了操作方法。于是我再次作死地进入第六关，千辛万苦上了两层楼，然后被卡死在一条被我打得只剩个头，却怎么也打不死的龙那里。这龙四处乱飞，判定奇大，一挨就死，我使出浑身解数操纵这个愚笨的骑士闪转腾挪，始终还是化作了一具沙雕的骷髅。</p>
<p>那就来点相对亲民的吧，《忍者龙剑传》。初次玩到这个游戏还是在小学的时候，大抵当初接触的是FC忍龙2，我就记得那个标志性的橙红色手里剑图标了。忍龙不愧为FC动作游戏楷模，手感真的是好，打谁都是一刀可太忍者了。唯一令我难受的就是那个抓墙跳，只能抓住却不能攀爬，判定也很是神秘，这一点都不蔚蓝！</p>
<p>忍龙的电影式过场动画在FC时代也是一大特色。我玩的时候字幕蹦得比较快，而且受限于分辨率，笔划稍多的汉字都代以假名，我只能读个半懂不懂。前面的几关虽然略有难度，但比起刚刚体验过的《魔界村》实在是不值一提，许多次我其实是因为爬墙不熟练让时间耗尽而失败。</p>
<p>可是，在爬上这座山之后，一切都变了！</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99533:/EomCKcdkyxGagJ2.jpg?authkey=AIbyrqnS5z58phc" alt="忍者龙剑传"></p>
<p>我从来没有像今天这样憎恨鸟！这些鸟正如魔界村的那条该死的龙，绕着曲线来撞你，一下就是两格血，跟挨了一发炮弹一样。要命的是，往往是面前一个端着蓝火加特林的士兵，前后钻出两只豹子，墙头还站着一个丢十字架的迷之牧师，手忙脚乱之际，两只鸟从天而降，你唯一能做的就是乱打一气，交给天命。</p>
<p>在可能有上千次的“时间倒流”之后，我还是卡在了放闪电的BOSS那里。蹲也好跳也好，电球总是以超高速追踪的形式命中，就连《只狼》里的雷电奉还也使不出来。不查攻略，我是想不到该怎样打了，而且我也不愿再回档了，就留到以后吧。</p>
<p>“鉴赏”了这么些FC游戏之后，我意识到它们之所以难，大抵是因为FC的游戏从街机演化，而街机的第一目的就是尽可能多且快地从玩家那里抢夺硬币。这样的设计理念实在是相当罪恶，对于普通玩家而言，这不过是较为精美的“贪玩蓝月”罢了——在用充钱带给人快乐这方面，甚至还不如贪玩蓝月。</p>
<p>写了这么多，明天可真的该再次投入到紧张的工作学习中去了。</p>
<blockquote>
<p>己亥大雪。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>游戏</tag>
        <tag>任天堂</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity异步场景加载</title>
    <url>/2019/12/15/Unity%E5%BC%82%E6%AD%A5%E5%9C%BA%E6%99%AF%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p>在游戏中，场景加载是很常用的功能。如果要在加载的时候让当前的场景还能正常运行，或者加载时能有一个包含进度条之类组件的加载界面，就应该采取异步的场景加载方式。</p>
<h1>同步加载</h1>
<p>在讲异步加载以前，先说同步加载。</p>
<p>当执行同步加载时，正在运行的场景会被阻塞，产生卡顿，这种方法适合小型的、不怎么需要获取读取进度的场景的加载。如在地牢中切换到另一个房间，读取完成之前当前房间中的一切都静止不动，这种情况应该是用同步加载实现的。</p>
<p>Unity使用<code>SceneManager</code>类的静态方法<a href="https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadScene.html">LoadScene</a>实现同步的场景加载。由于是静态方法，不需要对<code>SceneManager</code>类进行实例化，只要使用命名空间<code>using UnityEngine.SceneManagement;</code>就可直接通过<code>SceneManager.LoadSceneAsync</code>访问。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法原型：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadScene</span>(<span class="params"><span class="built_in">int</span> sceneBuildIndex, SceneManagement.LoadSceneMode mode = LoadSceneMode.Single</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LoadScene</span>(<span class="params"><span class="built_in">string</span> sceneName, SceneManagement.LoadSceneMode mode = LoadSceneMode.Single</span>)</span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>其中，第一个参数可以是场景的编号<code>sceneBuildIndex</code>，也可以是场景的名称<code>sceneName</code>。</p>
<div class="note info"><p><strong>什么是场景编号？</strong></p>
<p>场景编号是工程中每个场景唯一的<code>int</code>型编号，记录在Unity的<code>File-&gt;Build Settings-&gt;Scenes in Build</code>中。如果没有看到你想要的场景，可以通过Build Settings中的<code>Add Open Scenes</code>加入场景。</p>
</div>
<p>第二个参数所说的<code>LoadSceneMode</code>是一个枚举类，包含<code>Addtive</code>和<code>Single</code>两种加载方法。前者是在保留当前场景的基础上加载其他场景，如果是临时打开一个全屏的设置界面，就可以使用这种加载方式；而后者在加载完新场景之后就不保留原来的场景，适合进行关卡的切换等。</p>
<h1>异步加载</h1>
<p>异步加载和同步加载大同小异，但是它通过C#的“协程”使得加载过程看起来是在后台运行。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法原型：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncOperation <span class="title">LoadSceneAsync</span>(<span class="params"><span class="built_in">string</span> sceneName, SceneManagement.LoadSceneMode mode = LoadSceneMode.Single</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncOperation <span class="title">LoadSceneAsync</span>(<span class="params"><span class="built_in">int</span> sceneBuildIndex, SceneManagement.LoadSceneMode mode = LoadSceneMode.Single</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncOperation <span class="title">LoadSceneAsync</span>(<span class="params"><span class="built_in">string</span> sceneName, SceneManagement.LoadSceneParameters parameters</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AsyncOperation <span class="title">LoadSceneAsync</span>(<span class="params"><span class="built_in">int</span> sceneBuildIndex, SceneManagement.LoadSceneParameters parameters</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>方法原型与同步加载非常相似，方法名也只是加了一个“Async”。但最大的不同是，<code>LoadSceneAsync</code>返回的是一个<code>AsyncOperation</code>类对象，用于对后台的加载过程进行监测，其中有一个比较有意思的<code>bool</code>型属性<code>allowSceneActivation</code>，如果将其设置为<code>false</code>，加载进度<code>public float progress</code>会在0.9处暂停，直到将<code>allowSceneActivation</code>设置为<code>true</code>时再继续加载剩下的10%。</p>
<p>需要注意，<strong>Unity并不支持多线程</strong>，这里使用的协程实际上是一种Unity主线程上的伪线程。在VS的线程调试窗口里也可以看到协程启动后其实仍然在原来的线程里，<strong>我认为</strong>它大概和传说中的<strong>纤程</strong>就是一种东西，而后面的几个工作线程应当是C#的CLR开辟的。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99534:/YavnLJtRl5qicGF.png?authkey=AIbyrqnS5z58phc" alt="纤程？"></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//这里给出一个简单的例子：</span></span><br><span class="line"><span class="function">IEnumerator <span class="title">AsyncLoading</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">yield</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title">WaitForSeconds</span>(<span class="params"><span class="number">3</span></span>)</span>;     <span class="comment">//加载太快了，先播上3s的加载动画</span></span><br><span class="line">    operation = SceneManager.LoadSceneAsync(<span class="string">&quot;StartMenuScene&quot;</span>, mode: LoadSceneMode.Single);</span><br><span class="line">    <span class="keyword">while</span> (!operation.isDone)</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(operation.progress);</span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1>参考资料</h1>
<ol>
<li><a href="https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadScene.html">Unity - SceneManager.LoadScene</a></li>
<li><a href="https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html">Unity - SceneManager.LoadSceneAsync</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/46859738">知乎 - Unity 的多线程、协程、纤程</a></li>
<li><a href="https://blog.csdn.net/ksgt00629518/article/details/53894892">CSDN - Unity多线程、线程池的使用</a></li>
<li><a href="https://blog.csdn.net/qq_42462109/article/details/83096135">CSDN - Unity异步加载场景SceneManager.LoadSceneAsync与AsyncOperation的使用</a></li>
</ol>
<blockquote>
<p>虽然是个很简单的需求，但是涉及的东西不少也不简单，我至今也没完全搞明白……</p>
</blockquote>
]]></content>
      <tags>
        <tag>Unity</tag>
        <tag>C Sharp</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>191226</title>
    <url>/2019/12/26/191226/</url>
    <content><![CDATA[<p>冬至已经过了好几天，这次我没能在节气当天写随笔了——也许是一个危险的信号，象征着“持之以恒”依然不存在于我的字典中？</p>
<p>近期在做本科阶段最后的课程设计：综合能力培养。选择的是数据库方向（这算是几个月前“大数据开发”的历史遗留），三人一组用C++编写一个数据库系统。C++对我几乎是“未曾设想的道路”了。</p>
<p>啊，思绪繁杂。不过既然叫随笔，也不该讲求甚么“章法”，就依照“随笔”其名，想一出是一出地写吧。</p>
<p>首先还是在做数据库系统时遇到了海量的问题。这回是不怎么能“倚靠大佬”，相互借鉴交融并包了，所以基本上除了在一筹莫展时从GitHub上稍微看看往届学长的思路之外，都是自己老老实实写出来的东西。这个时候就能体现出“亲力亲为”太少的问题了，功夫是真的不行：一天可能摸不出50行代码，而且逻辑混乱，调试痛苦，维护困难。要说这水平是大二时候的我，倒也勉强可以接受，但是大学四年差不多就剩一个学期了，就连差强人意都算不上。</p>
<blockquote>
<p>“我并不想变强，也并不想解决问题，只是想表达自己并非坐以待毙，想表达自己在努力，只是摆出这样一个明显的姿态将自己正当化。我想说自己没办法，我想说自己束手无策，只是为了放弃，我才会做出拼命努力的表象……”<br>
——《Re：从零开始的异世界生活》 第18话</p>
</blockquote>
<p>这是我觉得十分危险的一种状态，这段话也时常被我用来反省。实际上这几个月，乃至这几年我还真有点这个意思，表面看起来并不算是“堕落”，却也说不上是在真正“努力”。</p>
<p>努力……难道人必须要努力才能存在吗？显然不是，往往带恶人活得同样滋润。</p>
<p>成年以后，年龄似乎就失去了意义，特别是知识爆炸的这个年代。我们往往把自己与年长自己许多岁的人，或者同龄人中抛头露脸的最顶尖的那一小撮进行比较，然后得出自己一无是处的结论。也许这结论有一半是真，但另一半大抵是十余年“挫折教育”的延续。</p>
<p>内卷，内卷，依然是内卷——东亚几乎要在这梦魇下失去未来。如今不会有人幻想“皇帝的金锄头”，天国和地狱一样空空荡荡，因它们都降临到了地上。成功了的人总是相似，仰视他们的人则各有各的痛处，并且知道自己几乎不可摆脱。些许人已经淡漠，但多数人仍要挣扎，他们的结果并没有太大不同。</p>
<p>我憎恶冬天。冬天总是阴云密布的，却总不下雨——下雨亦是一阵寒过一阵。偶然见了太阳，也是如同吸干了血的尸体，连同被这阳光照射的人物，都成了干尸了。寒冷麻痹思考，逐渐放弃思考。</p>
<p>极简。极简并非以致无欲。与其说是降低饱和度，不如说是增高对比度。</p>
<p>小小寰球。“我们并不孤独。”让我在天文台倒下！</p>
<blockquote>
<p>己亥腊月朔日。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>从C++里的一大堆字符串说起</title>
    <url>/2019/12/30/%E4%BB%8EC-%E9%87%8C%E7%9A%84%E4%B8%80%E5%A4%A7%E5%A0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%B4%E8%B5%B7/</url>
    <content><![CDATA[<p>写数据库管理系统时遇到了不少关于C++字符串的问题，要命的是C++的字符串种类实在是太多了，今天试着搜集一些资料总结一下。</p>
<h1>char foo[bar] 和 char* foo</h1>
<p><code>char foo[bar]</code>这种形式被称为“C风格字符串”，它是从C语言中流传下来的。它实际上完全就是char型的数组，只是你可以用这样的方式来给它赋值，看上去比较像“字符串”：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这两行都定义了相同的字符串&quot;Hello&quot;</span></span><br><span class="line"><span class="type">char</span> foo1[] = <span class="string">&quot;Hello&quot;</span>;      <span class="comment">//末尾有隐藏的&#x27;\0&#x27;</span></span><br><span class="line"><span class="type">char</span> foo2[<span class="number">6</span>] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p><code>char* foo</code>是声明了一个字符指针，指向单个字符，可以将其当作以<code>'\0'</code>为末尾的字符串的首字符地址。如果要把字符串赋给它，需要先申请内存空间，再使用<code>memcpy()</code>或<code>strcpy()</code>。当然，也可以不分配空间，直接用<strong>十分危险的指针赋值</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* foo1 = (<span class="type">char</span>*)<span class="built_in">calloc</span>(<span class="number">6</span>, <span class="built_in">sizeof</span>(<span class="type">char</span>));</span><br><span class="line"><span class="built_in">strcpy</span>(foo1, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* foo2 = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1>CString</h1>
<p><code>CString</code>是<code>MFC</code>的类，使用它需要包含<code>afx.h</code>。</p>
<p><strong>什么是MFC？</strong></p>
<blockquote>
<p>微软基础类库（英语：<strong>M</strong>icrosoft <strong>F</strong>oundation <strong>C</strong>lasses，简称<strong>MFC</strong>）是一个微软公司提供的类库（class libraries），以C++类的形式封装了Windows API，并且包含一个（也是微软产品的唯一一个）应用程序框架，以减少应用程序开发人员的工作量。其中包含的类包含大量Windows句柄封装类和很多Windows的内建控件和组件的封装类。</p>
</blockquote>
<p>总之，作为Visual C++的一部分，这是一个上古遗留之物。不愧是十年前的课设……</p>
<p>CString是MFC中最常用的字符串类。其数据成员只有一个，那就是字符串在内存中的起始地址。它还有许多方法，如多种构造函数、用于连接和比较的运算符重载、用于格式化的<code>Format</code>，以及各种用于对字符串进行替换、查找、删除的方法。这个类将C++中极为复杂、包含大量内存操作的字符串操作简化了不少。</p>
<h1>string</h1>
<p>string之前一直弄不太明白。这明明是每个语言都应该有的基本东西，但是鉴于C和C++之间乱七八糟的关系以及错综复杂的各种标准，就连这种“基本”也轮廓模糊到让人难以提起兴趣探索。</p>
<p>需要知道的是，**string是C++标准库中的类。**确切地说，string类定义于C++标准库的<code>&lt;string&gt;</code>头文件。</p>
<p>关键的问题是，什么是<a href="https://zh.cppreference.com/w/cpp/header">C++标准库</a>？这个名字很容易和标准模板库（Standard Template Libraries, STL）混淆，但实际上它们最开始是不同的东西。C++被标准化最早是1998年的<code>ISO/IEC 14882:1998</code>，即所谓的C++98。而STL始于C++尚未被标准化的1993年，它很大程度上影响了几年后C++标准中标准库的制定，因此其内容与C++标准库有非常大的重合。但需要注意的是，<strong>STL不完全是C++标准库的一部分</strong>，C++标准里也从来没有“STL”这一说法。C++标准库中的“STL”可以说是STL的一个“Fork”。</p>
<p>C++标准库包含一系列不带<code>.h</code>后缀的头文件，用尖括号引用。其中除宏定义以外的内容包含在名称空间<code>std</code>中，这也是许多C++程序都有一句<code>using namespace std;</code>的原因。</p>
<p>这是<a href="https://en.cppreference.com/w/cpp/algorithm/qsort">cppreference</a>上对<code>std::qsort</code>的一段示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">//C++输入/输出流标准头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>      <span class="comment">//C++标准库中来自C标准库的部分，去掉.h并在前面加c</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span>      <span class="comment">//同上</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">-2</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="number">-743</span>, <span class="number">2</span>, INT_MIN, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> std::<span class="type">size_t</span> size = <span class="keyword">sizeof</span> a / <span class="keyword">sizeof</span> *a;</span><br><span class="line"> </span><br><span class="line">    std::<span class="built_in">qsort</span>(a, size, <span class="keyword">sizeof</span> *a, [](<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)     <span class="comment">//指定名称空间std</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> arg1 = *<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>*&gt;(a);</span><br><span class="line">        <span class="type">int</span> arg2 = *<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>*&gt;(b);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(arg1 &lt; arg2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arg1 &gt; arg2) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//  return (arg1 &gt; arg2) - (arg1 &lt; arg2); // possible shortcut</span></span><br><span class="line">    <span class="comment">//  return arg1 - arg2; // erroneous shortcut (fails if INT_MIN is present)</span></span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> ai : a)</span><br><span class="line">        std::cout &lt;&lt; ai &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>LPSTR，以及各种乱七八糟的</h1>
<p>这就是较为难以理解的东西了，名字让人一头雾水。<code>LPSTR</code>算是最简单的形式，还有什么<code>LPCTSTR</code>,<code>PCTSTR</code>等等，这都是些啥？</p>
<p>其实这些全大写的神秘数据类型依然来自MFC，它们都是Windows特色数据类型。STR显然代表的是字符串，重要的是它们的前缀。</p>
<p>前缀中主要包含这么几个字母：</p>
<ul>
<li>LP：长指针Long Pointer，代表这是一个32位指针。说是Long是因为上古Windows中的Pointer还是16位。</li>
<li>C：常量Const，代表这是一个常量。</li>
<li>T：代表使用<code>_T</code>宏，这个宏是用于动态支持Unicode这样的宽字节编码（即用多个字节代表一个字符）的。如果Unicode有定义，那么带T前缀的字符串就是Unicode编码的，否则依然是窄字节编码ANSI。</li>
<li>W：宽Wide，代表使用宽字节编码，如Unicode。</li>
</ul>
<p>此外，MFC中还有神秘的<code>BYTE</code>、<code>WORD</code>、<code>DWORD</code>，其实就是分别对应<code>unsigned char</code>、<code>unsigned short</code>、<code>unsigned long</code>。</p>
<blockquote>
<p>关于ANSI和Unicode，另外再开一篇文章讲好了。</p>
</blockquote>
]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>标准</tag>
        <tag>考古</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>HustBase完成</title>
    <url>/2020/01/05/HustBase%E5%AE%8C%E6%88%90/</url>
    <content><![CDATA[<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99535:/PgJko6yGmOHnYqW.png?authkey=AIbyrqnS5z58phc" alt="HustBase结构"></p>
<p>经过一个月的胡乱操作，这个数据库总算是按照预期地跑了起来。</p>
<h1>主要工作</h1>
<ol>
<li>提供了数据定义功能：定义数据库、系统表、数据表、索引。</li>
<li>提供了数据库操作功能：创建、打开、关闭、删除数据库。</li>
<li>提供了数据表操作功能：创建、删除数据表。</li>
<li>提供了索引操作功能：（部分）创建、删除索引。</li>
<li>提供了按条件记录操作功能：插入、修改、删除数据表中的记录。</li>
<li>为查询模块提供部分语义分析功能。</li>
<li>编写部分用户界面模块功能。</li>
</ol>
<h1>遇到的问题</h1>
<p>编写模块的过程中，主要出现了以下几个问题：</p>
<ol>
<li>
<p>对MFC、Windows API的不熟悉</p>
<p>MFC实在是极其古老的东西，可以说早就停止支持，但本沿袭了十年的工程中仍然大量使用，尤其是HustBase.cpp中不得不使用。关于MFC的文档缺乏系统性和本地化，阅读起来较为困难。</p>
<p><a href="http://xn--Windows-mw3kp9c65yz8keseqqwywxnmdwt1fw2e.NET">如今的Windows开发基本上是用.NET</a> Framework和C#进行的，C++的实现非常佶屈聱牙，仅仅是启动一个选择路径的窗口就要耗去一整天时间搜集资料。类似的过程，加上对C++遗忘较多，让我在开发初期花费了大量时间。</p>
</li>
</ol>
<span id="more"></span>
<ol start="2">
<li>
<p>稳健性的缺失</p>
<p>数据库管理系统需要考虑的东西是比较多的，各种奇怪的情况层出不穷，这就需要在编程之前充分考虑。另外由于C++语言本身既有严格性又有不安全性，导致许多细小而严重的错误难以被快速检出，造成匪夷所思的执行结果。这也引发了最严重的下一个问题。</p>
</li>
<li>
<p>内存分配的错误</p>
<p>在对系统管理模块进行的测试过程中，我们常常遇到极为“神秘”的问题：所有的功能都能按照预期实现，但在一个随机的时间节点，或是对<code>RM_FileScan*</code>等进行free操作时会引发“堆损坏”错误，即<strong>HEAP CORRUPTION DETECTED</strong>。</p>
<p>一开始我以为这是HustBase框架本身的问题，因为任务书中指定的开发环境应为VS2010，而我使用的是VS2019。但其他同样使用VS2019进行开发的小组并没有出现同样问题，于是我们认为这是由某处访问越界造成的，尤其是早期版本中我使用了大量的<code>memcpy( )</code>函数，这很容易造成访问越界。但当我逐渐用<code>strcpy( )</code>或严谨的指针操作取代<code>memcpy( )</code>，并且对所有写内存操作进行检查后，该问题仍然存在。</p>
<p>最后我们发现，这个问题出现在内存分配时：</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">FileScan = (RM_FileScan*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(FileScan));</span><br></pre></td></tr></table></figure>
<p>在<code>sizeof( )</code>中，我错误地填写了<code>FileScan</code>，而非其作为指针指向的<code>RM_FileScan</code>结构体。因此，这一语句为指针分配了一个指针本身长度的内存空间，即4字节。但后面我将一个结构体填入了这块内存空间，这造成了越界。</p>
<p>由于对<code>FileScan</code>的内存分配几乎在系统管理模块的每个功能函数中都需要使用，这才使无论使用什么功能，都会随机出现该错误。对内存进行操作时，看清楚自己在写什么东西太重要了！</p>
</li>
</ol>
<h1>总结</h1>
<p>本次综合能力培养实验时间跨度较长，任务较为复杂繁重。</p>
<p>实验开始时，我们野心勃勃，觉得数据库很简单，特别是由于已经有了较为全面的代码框架，我们认为可能只需要一两个“良好的夜晚”就能实现大部分功能。但显然这是不现实的，实际的开发过程远比想象中“痛苦”。分小组开发的方式让我进一步熟悉了使用Git进行协作的流程，也让我体会到了何谓“1 + 1 &lt; 2”。组员<a href="https://github.com/LLGZONE">LLGZONE</a>由于还有实习工作在身，压力更是巨大，这使得我们的工作进度常常难以对接。</p>
<p>最终我们度过了艰难的一个月，开发出了一个具有一定“鲁棒性”，但功能还不太完善，没有多表连接查询，也没有完善地接入索引的数据库管理系统。好歹，It works，我们看这是好的，并且没有任何坏处。</p>
<p>这次我们没有使用GitHub，而是使用了国内的Gitee码云进行版本控制，由此也感受到了“另一种选择”——其用户体验确实非常良好。</p>
<p>总之，这里应该引用Linus Torvalds所说的名言：</p>
<p><strong>（* 咏 唱 开 始 *）</strong></p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99536:/DtoulHzyZFSndYg.png?authkey=AIbyrqnS5z58phc" alt="Linus名言"></p>
<p>所以，如果以后数据库综合能力培养实验还要做下去，并且想要做得好，请不要再使用目前沿用了十年的MFC代码框架了。</p>
<h1>梦想封印 Enterprise v0.0.1-alpha</h1>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99537:/tg3QhfeB9cOGaHz.jpg?authkey=AIbyrqnS5z58phc" alt="HustBaseScreenshot.jpg"></p>
<p>基于<code>HustBase</code>的<s>大型民用</s>数据库管理系统<code>梦想封印 Enterprise</code>的第1个技术预览发行版。</p>
<p><strong>注意：</strong></p>
<p>此版本尚不支持有条件多表查询和索引操作。</p>
<p><a href="https://github.com/Macyrate/hustbase/releases">Release(GitHub)</a></p>
<p><a href="https://gitee.com/strangenamebc/hustbase/releases">Release(Gitee)</a></p>
]]></content>
      <tags>
        <tag>C</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>为小米手环4制作自定义表盘</title>
    <url>/2020/01/11/%E4%B8%BA%E5%B0%8F%E7%B1%B3%E6%89%8B%E7%8E%AF4%E5%88%B6%E4%BD%9C%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A1%A8%E7%9B%98/</url>
    <content><![CDATA[<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99538:/uMehFaU86boClZL.jpg?authkey=AIbyrqnS5z58phc" alt="小米手环4"></p>
<p>在以100元的低价将Pebble Time转让给同学之后，今天买到了小米手环4NFC版。说实话Pebble是真的好用，可惜反射屏带来的续航依旧不是那么完美，而且人在国内，这些东西还是与国内的“生态”接轨比较好。</p>
<p>拿到新电子产品，当然得瞎折腾一阵。首先就得换个表盘。但可惜，小米运动APP里的自定义表盘仅仅支持3种预置布局下的背景图自定义，这显然不够酷。</p>
<p>不过，在<a href="https://www.bandbbs.cn/">米坛</a>这个网站我找到了真正意义上自定义表盘的方法，而且<a href="https://amazfitwatchfaces.com/">amazfitwatchfaces</a>上已经有了相当多的自定义表盘。但是我想要继续使用曾经在Pebble上用的<a href="https://apps.rebble.io/zh_CN/application/529ab1b6d17b5033ba000033">EVA表盘</a>，发现网上并没有现成资源后我决定自己制作。</p>
<p>简单地说，小米手环4的表盘是由一个<code>json</code>文件控制布局的一系列图片构成的。这个<a href="https://www.bandbbs.cn/threads/533/">注释版万能json</a>展示了该json文件的形式。将自定义的json文件与资源文件，即要显示的一系列图片，经过<a href="https://geekdoing.com/threads/mb4-resource-pack-unpack.1383/">MB4 Resource pack/unpack</a>工具打包后就能生成表盘<code>bin</code>文件了。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="attr">&quot;Time&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Hours&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Tens&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;X&quot;</span><span class="punctuation">:</span> <span class="number">70</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Y&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ImageIndex&quot;</span><span class="punctuation">:</span> <span class="number">23</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ImagesCount&quot;</span><span class="punctuation">:</span> <span class="number">3</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Ones&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;X&quot;</span><span class="punctuation">:</span> <span class="number">70</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Y&quot;</span><span class="punctuation">:</span> <span class="number">60</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ImageIndex&quot;</span><span class="punctuation">:</span> <span class="number">11</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;ImagesCount&quot;</span><span class="punctuation">:</span> <span class="number">10</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>以这段json代码为例，它控制表盘中时间部分的小时显示。</p>
<p>X和Y是图片左上角的坐标。这里的<code>ImageIndex</code>是指资源图片的起始编号，是其4位数字的文件名。而<code>ImageCount</code>是从起始图片开始向后有多少张图片被此处使用。由于是24小时制——12小时制也许也可以，但我不知道如何设置——小时需要用到表示<code>0</code>、<code>1</code>、<code>2</code>的3张图片。需要注意的是，资源图片的编号必须从<code>0000</code>开始连续，且所有的图片都要在json中被使用到，否则无法正常生成。</p>
<p>最后的效果：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99539:/lPeLST9Rt4iHQr7.gif?authkey=AIbyrqnS5z58phc" alt=""></p>
<blockquote>
<p>发布地址：<br>
<a href="https://amazfitwatchfaces.com/mi-band-4/view/11723">amazfitwatchfaces</a><br>
<a href="https://github.com/Macyrate/EVA_font_watchface">GitHub</a><br>
<a href="http://watchface.pingx.tech/h5/#/pages/detail/detail?id=1058400">米坛</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>200207：绿叶，月，细毛顶端</title>
    <url>/2020/02/07/200207/</url>
    <content><![CDATA[<p>也很有些时间没更新博客了。在我没反应过来的时候，时间依旧飞速地流逝。</p>
<p>这近一个月来发生的事太多又太少，无非绕不开“新型冠状病毒感染的肺炎疫情”一事。截至今日我已经有半个多月未尝出过门了，站在阳台上看着除了人以外什么都还存在着的大街，感到有些荒诞。“末日之后”的感觉却又不是那么浓烈，也许是我度过几次独自在寝室的大学假期，已经习惯了在杳无人烟的氛围里，抬头看着漏下日光的翠绿梧桐叶子发呆的生活吧。</p>
<p>大学的最后一个假期也将要过去，我大抵是不会再有体验这种生活的机会了——这种莫名有点感慨的心态，就像当年高考前最后的一次晚自习——以后不会再有晚自习了，也不会再有晚自习上小心回避着老师而听的歌、看的闲书了。“大学四年顶个球”，留下的东西实在不多，而我才刚刚开始认识这个世界。</p>
<p>身边参加了考研的朋友们，面对前途大多迷茫，苦笑着一年努力八成喂了狗。往往是越学越了解自己的浅薄，就像现在看看6年前入宅不久时自己写的、自己得意的东西，显得与2020年的网络那么格格不入，像mikufans时期的弹幕乃至古早时期猫扑大杂烩里的帖子，没有经过思考的吐槽、没有经过考证的论调中，真挚与弱智三七分成。</p>
<p>不过网络变化其实不大，至少真挚与弱智的三七分成还是没变。谁都没有上帝视角，哪一方都太容易被现实愚弄，绕来绕去才发现大家其实都有同一种病，没有谁就高人一等。</p>
<span id="more"></span>
<p>要说高中的基调是怎样，我想起来的就是大一时初次在华科见到的——其实直到如今也一样——在黑糊糊树影的簇拥之上那个圆月。只是高中所见的月被“黄冈中学”的明亮红色灯牌和教学楼上缠着的黄色灯带烘托着，再被些许我可能叫得出名字的星点围绕着，似乎要黯淡些。说来也怪，这么些年，每有了要去观察月亮的心时，偏偏就是“天心月圆”。或者，就是在远远的远方，薄薄的渐变色里浮着的一勾新月。新月，它总让我想起伊斯兰世界，那个世界似乎比这新月还要遥远。</p>
<p>新月，新月沃地，那里的印象就是天方、阿萨辛和游侠纳斯列金。文化与瘟疫最早的起源之一在这里。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99540:/CRgwvaHt1qonkpN.jpg?authkey=AIbyrqnS5z58phc" alt="新月"></p>
<p>说回瘟疫，短短半个多月的肺炎时期见到的荒诞比过去几年加起来还多。元旦八勇士之后，那由于湖北“两会”而消失的半个月且不说，之后的封城，武汉病毒所，上海药物所，N95口罩，双黄连，无人机，唱国歌，红十字会，火神山，雷神山，方舱，一直到今天以自己的逝去让全国人民更加地哀痛的李文亮医生，这个阵仗早已比2003年的非典高了许多等级。那时候我应该还在上学前班，记忆尤其模糊，只记得曾造访过江家巷的筒子楼，还怎的学习过英语，那一带的炸酱面相当不错。唯一可以确信的，就是没有像如今这样严格的隔离，大家的生活似乎照常。</p>
<p>隔离之前，好在为了预备不发快递的新年，我预先购入了《塞尔达传说：旷野之息》。这看来是极为英明的决定，这段时间若没有这张卡带作我随时跳到海拉鲁大陆的传送门，世界就太过于枯燥了。50多个小时的跋山涉水，好像是我自己在经历，也许这就是21世纪最伟大的游戏吧。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99554:/P5poIKaDeCj8mSt.jpg?authkey=AIbyrqnS5z58phc" alt="米法"></p>
<p>就这么玩下去当然不是办法，虽然原定2月16日的开学时间肯定是推迟了，春招想必也是推迟了，可我要做的事情是一点也没有减少。前几天Unity发来一封电邮，为了大家在家有学可上，给大中华区用户送来了4个月的Unity Learn Premium会员，我可真是谢谢您（诚挚）。跟着弄了几天，写出一个与自己的毕设没啥关联的Demo，对Unity的了解是从兔毛顶端摸到了兔子皮。今天是成功Deploy出来的快乐日子，倒是不想多学了。</p>
<p>明天呢？明天做什么？总得迎来明天的，不管怎么“Ready perfectly”，「東方珀露澗 ~ Aurora of Dragon Lore.」它总得继续动笔。</p>
<p>翻翻To Do？哦，我的ANSI编码还没讲呢。就连已经写完一个多月的C++字符串也还留在待办里没划掉，我是有多久没打开这玩意了？这个主界面的待办创建于去年12月10日，我的毕设积了两个月的灰啊。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99541:/hwvXZ6KmbzTtA4k.jpg?authkey=AIbyrqnS5z58phc" alt="主界面ToDo"></p>
<p>好，明天就先花一点时间来写ANSI编码吧，这个应该挺快的。主界面……我想基本UI也许可以弄出来，至于AudioClip，我想还得了解了解同人音乐方面的利用规约，总不能真就靠自己作曲吧——如果我勤奋一点，其实现在应该已经学会做Arrange了，懒狗要不得啊。</p>
<p>啊，还有八字没一撇的开题报告呢。我不应该继续上微博跟着他们群情激愤或者痛哭流涕了，我的人生是自己的。春招的命运都暂且不谈了，我如今最想做的就是完成《東方珀露澗》，然后顺利毕业。</p>
<blockquote>
<p>庚子正月几望。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>被禁锢的自由——对中国动漫的几点看法</title>
    <url>/2020/02/07/%E8%A2%AB%E7%A6%81%E9%94%A2%E7%9A%84%E8%87%AA%E7%94%B1-%E5%AF%B9%E4%B8%AD%E5%9B%BD%E5%8A%A8%E6%BC%AB%E7%9A%84%E5%87%A0%E7%82%B9%E7%9C%8B%E6%B3%95/</url>
    <content><![CDATA[<p>谈到动漫，世界上比较有权威的大概只有三个国家：日本、美国和中国。然而当动漫在国外蓬勃发展时，我国动漫却总不受观众待见。在我们看来，中国动漫所遭遇的窘境，根本原因是我国广电总局长期以来所施加的压力以及大部分制作人的庸俗思想。</p>
<p>在美国 ，动漫寄托的是天马行空的想象、美利坚人民独特的冒险精神；在日本，动漫早已成为这个国家新型文化中的重要组成部分，在任何地方都能看到它的影子，这种文化的浪潮席卷世界……中国与它们的不同在于，美日都称动漫为“文化”，或者干脆是“艺术”，而我国一直将动漫作为“产业”对待。这就是我们在政府态度上的差异。广电总局还一再说为了大力促进国产动漫“产业”发展，在各种时段禁播境外动漫作品，实在是恶性循环！</p>
<p>动漫，它的存在意义在于使未成年人更明晰地了解这个世界，或者让成年人从中也有所感悟，所以它理应是面向所有年龄段观众的，然而既然这样，就不可避免地要含有一些所谓“成人世界”的元素，就是广电总局所说的“恐怖、暴力、色情、凶杀、犯罪”等等。因此，为了“创建和谐社会”，“还孩子们一片纯净的天空”，许多好作品都不受光电待见，最典型的就是《秦时明月》，这部被民众广泛认为“冲出国门，走向世界”的诚意之作，曾经差点被禁播，现在也不怎么受电视台的追捧，只是在网络上一直受人关注。《秦时明月》讲的是战国时代的故事，它有点征伐、武侠、爱恨交织的元素怎么了？光电却曾认为它“血腥暴力内容不健康”。什么居心？那么，日本的作品《日在校园》中女主角之一杀死男主角和女主角其二并分尸的情节（其原因还是由于男主角乱搞男女关系）真可谓是和谐社会的“毒草”了。</p>
<span id="more"></span>
<p>日本动漫可能在广电看来“不健康”，然则它们往往蕴涵着深刻的思想。比如《Date A Live》，开头就说“30年前的一场‘空间震’，使三千万人命丧黄泉”，这时广电就会说“小孩子看了多不好啊，禁播！”但《Date A Live》的主要情节是用爱改变引发“空间震”的精灵的暴戾性格，使其融入人类社会，宣扬的是“兼爱”、“非攻”的思想，展现的是世界的美好，但这样的情节放到国内可能会被认为是“鼓动未成年人早恋”云云。据我们的判断，广电对于“教唆未成年人早恋”的作品极其反感，甚至连广电最喜欢的“动物世界”类型动漫（角色全都是各种动物）也逃脱不了这样的“铁律”，导致一代经典（“动物世界”中的经典）《虹猫蓝兔七侠传》被禁播。广电，你也太小看现在的孩子们的心理承受能力了吧。</p>
<p>在《名侦探柯南》情节越来越高智商的同时，我国作品陷入了“低龄化”的圈子，真正适合全年龄段的国产作品，就只有以《秦时明月》为代表的一小批作品。许多在网络上受人追捧的作品的制作者叹道：“像我们《十万个冷笑话》这样‘和谐’的作品绝对上不了电视！”能上电视的，总是以《喜羊羊与灰太狼》为代表的大批“低龄化”、“低智商”的作品。我们不否认这些作品对低龄人群的作用，但我们作为青少年，也理应拥有适合我们年龄段的优秀国产作品。</p>
<p>国产作品存在一个严重的架构问题。许多作品有很强的的“未来感”，讲什么星际航行或者时间旅行之类，为了渲染还不惜重金非要做成三维的，然则情节实在不与其华丽的外表匹配，绝大多数都是好人一路刷怪，逢怪必胜，然后偶尔出几个拽一点的就多打一两集还是必胜，最后一路杀到最终Boss，一场惊天动地的大战之后好人重伤，坏人被打死，世界解放；或者“复杂”一点，最终大战中Boss放了个阴招杀了女主角，男主角痛不欲生小宇宙爆发用不科学的超必杀技秒杀Boss，最后女主角又不知怎么回事地复活，然后，还是大团圆结局……这类作品的开山鼻祖大概是当年的《神兵小将》，实在是逢怪必胜啊。只有一些有节操的作品能脱离这一情节，比如《葫芦娃》中“小蝴蝶”死后就没有复活，然则最后还是“葫芦小金刚”一路刷怪，一般是秒杀，于是又“正义战胜了邪恶”，蛇精再次被封印。只有含金量高，世界观宏大的作品才能冲击“经典”，如《火影忍者》、《海贼王》、《死神》等 ，这样的作品才能催生出“文化”。这种超长篇作品，情节复杂，可能分好几条明线暗线，但又十分严谨，所以经过冷静的推理剖析甚至可以知道角色们在同一时间里大概在做什么……这样才具有研究价值，令人回味无穷。由于大部分改编自漫画或小说，它们拥有了如此强的故事性，而我国作品，据我所知，没有任何一部由漫画或小说改编，从来只有由动漫改编为漫画（如《魁拔》）或小说改编为漫画（如《盗墓笔记》、《斗破苍穹》等），这就大大限制了动漫的剧情，因为做动漫的设计剧情必然胜不过专业作家、漫画家。然而这条路在中国走起来似乎很困难，中央对于这个貌似的确很反感，《新闻联播》曾有两则报道，令我等实在无语。</p>
<p>其一：一位记者走向书摊（“非正常拍摄”又一次神秘地出现在屏幕右上角），拿起漫画《斗破苍穹》单行本1翻阅，询问店主销售情况。这倒没什么，CCTV的一贯作风而已。然而当记者翻到退婚情节里萧炎被刺时，说了一句经典的话：“啊，一刀下去血就出来了，小孩子看了多吓人啊！”在此我只能默默吐槽一句你这句话让那些尸横遍野血流成河灭绝人性的抗日神剧好不容易积攒的存在感瞬间付诸东流了啊！难道“小孩子”在动漫作品里看不到这种“血腥”，在电视里就看不到吗？这和“掩耳盗铃”不知为何有几分相似。</p>
<p>其二：有条新闻说“同性交友网站在中国兴起”，然而其背景却是国内著名动漫网站“哔哩哔哩”，于是许多网友纷纷戏谑地表示“妈妈对不起我是那儿的会员还是高级的！”如果不是CCTV的工作人员太二（估计不会），那我们就能从这则新闻里看到深深的恶意。“哔哩哔哩”在这件事后甚至更改了域名。</p>
<p>从这两则报道中，我们看出中国的动漫发展是被禁锢的，《我叫MT》甚至登上了英国的报纸，但要打进电视，总会被以“狗肉上不了正席”一类的理由毙掉，那敢问一句什么才不是“狗肉”？难道是《喜羊羊与灰太狼》这样的作品才能上“正席”？中国从来不缺人才，从来不缺好的创意，然而佳作却总是被简单粗暴地拒之门外，可能国家机关早就习惯了这样做，奇怪的是那些官僚却还在奇怪中国动漫投入了那么多资金怎么就走不出国门成不了经典，他们有反省过自己的行为吗？一颗种子被锁在铁盒子里，再怎么努力它也冲不破牢笼，因为笼罩着它的是不负责任的黑幕。就像中国足球，无论怎么请外教请外援都改变不了非专业的现状，而且现在的学生越来越厌恶体育课了，他们到底被给过多少自由？又有多少真正有才能的人，只是因为没有“后门”可走，就被庸才取而代之？这简直像一个杀人凶手伏尸大哭：“我亲爱的朋友，你死得好惨哪！到底是哪个混蛋害死了你……”这就是某些人的丑恶嘴脸。</p>
<p>限制中国动漫发展的另一方面就是制作者普遍的庸俗思想，一切都以盈利为中心，于是造就了大批所谓的“动画电影”。《喜羊羊与灰太狼》每年出一部贺岁片，不知道从孩子们身上赚了多少钱；连一些游戏，如《赛尔号》等也竞相模仿。然而却没有任何一部称得上经典，能与美国的Pixar、Disney，日本的吉卜力相提并论——《千与千寻》、《玩具总动员》、《冰雪奇缘》……哪一个不是一上映就引发轩然大波，风靡全球？中国的作品做到过吗？如今的制作者甚至早已摒弃了中国瑰丽的传统文化，可外国人却视若珍宝，让《功夫熊猫》、《成龙历险记》在异乡生根发芽，实在是讽刺！与中国制作者相比，我们的邻邦日本，情况就大不相同了。作家写出小说，画师为其作画、设计人物形象，出版社整理成书，制作方严格按照化石的设计改编出动画，电视台安排放送，所有的人都是怀着神圣、肃穆、庄严、激动的心态做自己的工作。《Date A Live》动画第一季的制作方，在公司陷入困窘之中时仍然一丝不苟地制作，终于做出了登峰造极的作品。而这家公司却在这部千古绝唱上映后不久由于种种原因破产倒闭，但他们的敬业专注执着成功地使这12集动漫成为璀璨的经典。这令我国浮躁的制作者汗颜。</p>
<p>搞动漫是为了什么？那是一种梦想，是希望，是使命感。是为了成功的喜悦，看到自己的作品像自己的孩子一样在世上诞生，这些都不是金钱所能衡量的。可惜在中国，这样有艺术家情怀的制作者还是太少，许多人都在求新求异的路上迷失了方向，忽略了那来源于心灵深处的感动。动漫带给我们快乐，温暖，羁绊，教会我们怎样去爱自己，爱别人——即使二次元的世界里有再多的邪恶力量，也比一个用甜言蜜语堆砌起的“太平盛世”要好得多。</p>
<p>突然想到了著名AV女优苍井空的一句名言：“我脱下衣服躺在镜头前，是为了生存；而有的人衣冠楚楚地坐在镜头前，嘴里却满是赤裸裸的欺骗。”</p>
<blockquote>
<p>此文撰于2014年4月16日，趁原稿尚未损毁，整理于此。<br>
由于知识水平与时代背景的局限，如今看来是相当野蛮。<br>
日光之下并无新事，以史为鉴！</p>
</blockquote>
]]></content>
      <tags>
        <tag>遗产</tag>
        <tag>国事</tag>
      </tags>
  </entry>
  <entry>
    <title>200208：瘟疫，党，怎样说话</title>
    <url>/2020/02/08/200208/</url>
    <content><![CDATA[<p>昨天说今天该讲讲ANSI编码，并且不再去微博乱逛了，但早上习惯性地点开翻几页，又感觉那根弦紧了一紧。有一些话想说，但在境内当然是没办法开口的，无论说得多么谨小慎微也避不过全体人民“群防群控”的自我审查。GitHub Pages上这块无人造访的IP就算作是互联网的“法外之地”，让我在这里信口开河，“反动”几下吧。</p>
<p>我早年从知乎结识的网友<a href="https://www.zhihu.com/people/jingujisuzuka">神宫寺铃香</a>发了这么一段：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99542:/CRmJTiBnxeSjaVZ.jpg?authkey=AIbyrqnS5z58phc" alt="路易十六一文不值"></p>
<p>这段话出自法国大革命时期吉伦特派的皮埃尔·韦鸠尼昂·韦尼奥之口。这样的言辞是如何得以出现的？当中国的某个掌权者的做法与宪法背道而驰之时，我们能够像这样大胆斥责吗？</p>
<p>显然是不能的。“得道者多助，失道者寡助”，受到这样批判的当然是寡助者——多助者在被这样批判的时候，发出批判的人立刻就会被口水淹没。不幸的是，政治的发展和技术的变革让得道者不一定多助，失道者也不一定寡助了，或者至少将他们多助、寡助的时间点大大延后，使得许多事物可以被扼杀于摇篮。</p>
<p>这些天，肺炎疫情把武汉政府的虚伪面具撕得稀烂，官僚主义、形式主义的败絮化为血的火焰，烧穿包装纸让魔幻的现实在全世界面前光彩夺目。因此，舆论的战斗被推到自习近平同志就任以来所未有的高度，甚至有人表示“上一次有这么多人觉醒，还是1989年”，品葱的反共分子和连登的香港废青们弹冠相庆，似乎民智将开，马上就要十月革命一声炮响，共产党就要被打倒了。</p>
<span id="more"></span>
<p>但从大体上看，中国共产党经历九十九年仍然是得道者。多助寡助自不必说，光是党员就有9000万之巨，假如将其看作一种有具体名头的宗教，那也是世界第五大教了。得道就在于，无论当年是通过机缘巧合还是苏联援助，还是中共声称的历史必然性，即“没有共产党就没有新中国”的阐释，中共最终是成功在中国建立了较为稳定的社会主义政权，使中国摆脱了半殖民地半封建社会的性质，这一点无论怎么抹黑都是不可否认的。而且经过七十年的“艰难探索”，在集中力量办大事，杀了许多好人和坏人之后，在让懒惰的人穷下去，勤劳的人富起来之后，成为了“第三世界”中有头有脸的一员，甚至让一部分狂妄的人提前敢于和曾经骑在祖先头上的“西方列强”掰掰手腕。</p>
<p>但是哪个政权是可以永远存在的呢？古代的帝王号称受命于天，但嫡传几代就免不了“天数有变”的历史周期律；“资本主义社会”以资本为中心，政权怎么更迭都是服务于资本，本质上没有多少区别；中国的马克思主义者认为建设社会主义并逐渐发展到共产主义的究极形态是破除周期律的方法——毕竟那时就根本没有政权了。</p>
<p><strong>可是我们并不能很自信地声称我们的国家是一个社会主义国家，朋友们。</strong> 尽管习近平同志鼓励我们要自信，要有“道路自信、理论自信、制度自信、文化自信”，我们依然没有自信。中国人失掉自信力了吗？</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99543:/ilGZPOxw13Me97R.jpg?authkey=AIbyrqnS5z58phc" alt=""></p>
<p>“我对社会主义没有概念”，这是一个迷惘的青年人的话语，也是时代的缩影。他成长在远离战争与革命的21世纪中国，至少他从日常生活中体会不到我们和我们曾经的敌人到底有什么不同，也许区别仅仅在我们的限制比他们更多。</p>
<blockquote>
<p>我们从古以来，就有埋头苦干的人，有拼命硬干的人，有为民请命的人，有舍身求法的人，……虽是等于为帝王将相作家谱的所谓“正史”，也往往掩不住他们的光耀，这就是中国的脊梁。</p>
<p>——鲁迅</p>
</blockquote>
<p>我们看到，至今仍然有埋头苦干的人和拼命硬干的人，但为民请命、舍身求法的人去了哪里？他们虽有的在发光发热，甚至在主席之位孤军奋战，却也有许多人成了“404”，那些人里有的收到了训诫书，有的在监狱，有的亡命天涯，有的已经死去。</p>
<p>人民万岁！但人民即将失败，他们不知道自己的故乡到底是不是恶之花绽放的土地，他们今天可以高唱“我和我的祖国”，明天就可以对整个世界绝望。因为他们是无知的。这并不能怪罪他们，我们一方面把民主作为核心价值观，另一方面却希望所有的民都做同样的主，到头来他们仍然一无所知，把个人的命运交给国家，甚至把国家偶像化，好像自己并非是国家的主人，并非是时代的铸造者。</p>
<p>当小布尔乔亚们的“韭菜”论大行其道的时候，我想就算我会被人称为下一茬“韭菜”，我也应保持一定的乐观：虫子虽然是虫子，却也不妨害它们成为世界生物之林中的佼佼者。但浅薄的我听到那些被称为公知的智者的悲观言论，乃至“诸夏”这种极度绝望的观点，又不免要动摇了。</p>
<p>其实我所期望的、人们所期望的哪有那么复杂。我希望那些被写在《中华人民共和国宪法》上的东西能被那些声称“依法治国”的人好好执行。如果做不到当初就不应该写下来，就算临时反悔把一些什么从宪法上抹掉也没关系，但承诺过的事情没能做到，性质是很恶劣的。但是这点小小的愿望，在几乎不允许讨论《宪法》的国度，连用《宪法》赋予我的“言论自由”说出来的机会也很难有。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99544:/EtUHdcrPWOQGp5Z.jpg?authkey=AIbyrqnS5z58phc" alt="不存在的宪法"></p>
<p>因此我逐渐走向中立，这是绝大多数中国人最擅长的：“我就什么话也不说。这是最好的。”把世界交给那些象牙塔中经天纬地的学究吧！他们比我们这些什么都没经历过的臭小子们强太多太多，在他们眼中任何超脱飞扬的思想都是老掉牙的笑话，任何激情澎湃的斗争都是大棋中必然的一步。哈哈！</p>
<p>那些有话想说的人，他们依然秘密集结在社会之光照不到的阴暗角落，战战兢兢或者大义凛然。“这个社会就是这样”、“别人说只是那么说”、“真话是不能乱讲的”、“所谓的规则和正义只是感动自己”——沉重而颠倒黑白的话语却在共和国的每一处角落，与染血的悲壮国歌一同飘扬：“起来，不愿做奴隶的人们……”</p>
<blockquote>
<p>庚子元宵。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>国事</tag>
      </tags>
  </entry>
  <entry>
    <title>200223：890 Errors创立</title>
    <url>/2020/02/23/200223/</url>
    <content><![CDATA[<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99553:/VmI4h6RczwKMXfE.png?authkey=AIbyrqnS5z58phc" alt="890 Errors"></p>
<p>用一个小时画了这张图，作为同人社团<code>890 Errors</code>的Logo。现在，我也是社团主催了（</p>
<p>尚未发布作品的社团是不能创建THBWiki页面的，所以其实也说不上已经创立。不过饼总是要提前画的，至少现在已经<a href="https://github.com/890-Errors">在GitHub上成立了Organization</a>……</p>
<p>使用的依然是<code>Aseprite</code>，在我有机会认真学习绘画之前大概要有很长一段时间使用它了。</p>
<p>设计的时候，首先想到的就是阴阳玉，把阴阳玉挂在未来要做的社团Logo上是长期以来的夙愿了。</p>
<p>然后受<a href="https://thwiki.cc/%E6%81%92%E8%90%83%E5%B7%A5%E5%9D%8A">恆萃工坊</a>Logo的影响，也想把某个卦象用进去。看了看六十四卦有哪些之后，又无从挑起了。索性直接卜上一卦，得到的结果就是这个<code>风山渐 ䷴</code>。</p>
<blockquote>
<p>象曰：<br>
俊鸟幸得出笼中，脱离灾难显威风。<br>
一朝得意福力至，东西南北任意行。</p>
</blockquote>
<p>是“稳步发展”的一卦，挺不错的，那就决定是它了（如果不好？那就再Roll一个）。但我岂能期盼什么“福力至”呢？</p>
<p>只用三种颜色未免有些过于单调，于是我把阴阳玉的右半和渐卦的阳爻用“混乱”工具处理了一下，变成了这种好像打上了马赛克的样子——而且这样的六爻不是有点扫描线内味了吗？加上边框和下面的banner之后，阴阳玉又像是陈列在带有“腰封”的盒子里了。<em>（妙啊，妙啊）</em></p>
<p>社团的名称来源于大家喜闻乐见的“0 Errors, 0 Warnings”，但由于我菜得真实，写出0 Error的东西怕是在梦里，就改成了与<code>博麗</code>谐音的<code>890</code>。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99555:/8HGD52OgfMP9mzp.jpg?authkey=AIbyrqnS5z58phc" alt="0 errors"></p>
<p>我发现，自己对于设计实在没有什么储备，喜欢用的元素无非是五行八卦一类的玄学，更别说对红白蓝黑四色的过分偏执，这对我的限制太大了。</p>
<p>很长一段时间里我都没有所谓“偶像”，如今我可以肯定地说ZUN就是我的偶像。在一步一步做着这些的时候，我一方面感叹ZUN的天才，毕竟那是初入大学就全靠自学地开发了《东方灵异传》的人；另一方面痛恨自己的无能，如果我能在有念头的时候就作出行动，一切就不会显得像现在这样晚了。假如现在还是2018年那该多好——这么说着的时候，我应当为之“作出行动”的念头又快要被覆写掉了。</p>
<p>我必须永远与矛盾共生下去。</p>
<blockquote>
<p>庚子二月朔日。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>图像</tag>
        <tag>东方Project</tag>
      </tags>
  </entry>
  <entry>
    <title>从ANSI编码是啥说起</title>
    <url>/2020/02/09/%E4%BB%8EANSI%E7%BC%96%E7%A0%81%E6%98%AF%E5%95%A5%E8%AF%B4%E8%B5%B7/</url>
    <content><![CDATA[<blockquote>
<p>在 Windows 记事本的语境中：<br>
所谓的「ANSI」指的是对应当前系统 locale 的遗留（legacy）编码。<br>
<a href="https://www.zhihu.com/question/20650946/answer/15745831">梁海的回答 - 知乎</a></p>
</blockquote>
<h1>所谓编码</h1>
<p>也许你曾试着购买东方Project正作游戏，或别的什么非英语内容：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99546:/SOd1FeGDNHx9iLt.jpg?authkey=AIbyrqnS5z58phc" alt="东方正作"></p>
<p>扔进光驱，兴冲冲安装之后，点开附带的<code>omake.txt</code>文档，你会发现和安装时就遇到的一样，大部分成了乱码：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99545:/UV9Pzu8rQFtSHMj.jpg?authkey=AIbyrqnS5z58phc" alt="omake原文"></p>
<p>奇怪的是，英文、数字、以及一些符号部分并没有变成乱码，这时你就明白，该死的编码问题又出现了。一直到几年前，Windows记事本的默认编码都是写在右下角的<code>ANSI</code>（现在已经是UTF-8），这是什么编码呢？</p>
<span id="more"></span>
<p>当你在简体中文Windows环境下用记事本写一个ANSI编码的文件，再用VS Code这种对各种编码都支持良好的编辑器打开它，编辑器所识别的编码是中国的国标码<code>GB 2312</code>。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99547:/swLx1GrgF7zpRJC.jpg?authkey=AIbyrqnS5z58phc" alt="动画观览记录GB2312.jpg"></p>
<p>而日本的“国标码”是<code>Shift JIS</code>编码，前面提到的<code>omake.txt</code>是不是用这个编码写成的呢？</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99548:/xIrod8ZvL7cnO1U.jpg?authkey=AIbyrqnS5z58phc" alt="omake Shift JIS"></p>
<p>答案是肯定的。</p>
<p><strong>为什么同样写着ANSI，实际上却是不同的编码？</strong></p>
<p>花了一上午搜集了些资料，发现这个问题背后的故事远比想象中复杂，接下来就整理整理。</p>
<h1>梦回1963</h1>
<h2 id="ASCII"><a class="header-anchor" href="#ASCII">¶</a>ASCII</h2>
<p>这段历史故事要从计算机的“蛮荒”年代1963年开始说起。</p>
<p>ANSI指的是美国国家标准学会。1963年时的ANSI还叫作ASA（美国标准协会），以电报码为基础制定了大名鼎鼎的ASCII（美国信息交换标准代码）编码。这套编码共有128个字符，由7位二进制进行编号。ASCII的0~31号，再加上最后的127号“Delete字符”是33个不被显示的“控制字符”，其余95个字符正好与标准键盘符合。</p>
<p>可以对着键盘计算一下：数字行有10个数字键和3个符号键，字母行有26个字母键和8个符号键。而每个键都可以用Shift表示两个字符：</p>
<blockquote>
<p>(10+3+8+26)*2 = 94</p>
</blockquote>
<p>怎么还少一个？因为010 0000的“空格”也是一个字符，与000 0000的“空字符”并不等同，所以一共就是ASCII中的95个可显示字符。</p>
<h2 id="EASCII"><a class="header-anchor" href="#EASCII">¶</a>EASCII</h2>
<p>ASCII虽短小精悍，符号可能足够美国的电报系统使用，但要在计算机世界推行开来就有两个问题（我口胡的）：</p>
<ul>
<li>计算机的存储需要“对齐”，编码位数如果是2的整数幂，如8位会更方便、效率更高。而ASCII只有7位；</li>
<li>ASCII没有法语德语等所包含的衍生拉丁字母，难以在欧洲实行，符号也不够全。</li>
</ul>
<p>因此在70、80年代，<code>EASCII</code>（延伸美国标准信息交换码）应运而生，通过把ASCII扩展到8位，就又可以加入128个字符。但EASCII没有形成统一的标准，而是有数种互不兼容的方案，这里讲两个影响力较大的：</p>
<h3 id="Code-page-437"><a class="header-anchor" href="#Code-page-437">¶</a>Code page 437</h3>
<p>这是由IBM制定的标准，在1981年发布的原始IBM PC上采用。它扩展了衍生拉丁字母、希腊字母和一些表格符号等，还将ASCII中那些已被弃用却无法显示的控制字符做成了一些特殊符号，如很具有标志性的两个笑脸——0x01和0x02。设计思路基本来自于当时与IBM分庭抗礼的<a href="https://www.huxiu.com/article/292306.html">王安电脑</a>。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99549:/So1JBGPuDcv3ekX.png?authkey=AIbyrqnS5z58phc" alt="Code page 437"></p>
<p>由于后来IBM PC的巨大成功以及微软和IBM之间的渊源，这套标准在MS-DOS里流传下来，这也就是我们在使用DOSBox的汇编实验里，在Borland Turbo Debugger中所见到的：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99550:/EoOatu1m9DdIgLB.png?authkey=AIbyrqnS5z58phc" alt=""></p>
<h3 id="ISO-IEC-8859"><a class="header-anchor" href="#ISO-IEC-8859">¶</a>ISO/IEC 8859</h3>
<p>这个8位字符集标准由ISO（国际标准化组织）及IEC（国际电工委员会）联合制定，其中包含<code>ISO/IEC 8859-1</code>到<code>ISO/IEC 8859-16</code>，但没有12号的15套扩展方案。而每一套方案就是扩展了一个地区的语言符号。这里贴出扩展了西里尔字母的<code>ISO/IEC 8859-5</code>：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99551:/psfVuZoHL2ST1Oc.jpg?authkey=AIbyrqnS5z58phc" alt="ISO/IEC 8859-5"></p>
<p>这项工作最早并不是由ISO和IEC启动的，而是由ANSI和ECMA（欧洲计算机制造商协会）。他们于1985年公布<code>ECMA-94</code>，即后来的ISO/IEC 8859 parts 1, 2, 3, 4。</p>
<p>80年代雄霸西方，如今却只能在<a href="https://www.bilibili.com/video/av5953981">敖厂长的视频</a>里见到的Commandore 64使用的就是ISO/IEC 8859，这也见证了那个IBM、苹果、Commandore、雅达利群雄并起的时代。</p>
<p>另外需要提及的是<code>Windows-1252</code>，即Code page 1252，这是西方文字版本Windows（而不是MS-DOS）中默认的字符集，是ISO/IEC 8859-1的超集。虽然并非是真正的ANSI标准或ISO标准，但却是最流行的。在微软投向国际标准化、Windows普及开来之后，Code page 437也就逐渐消失了。</p>
<h2 id="东方宽字符"><a class="header-anchor" href="#东方宽字符">¶</a>东方宽字符</h2>
<p>80年代计算机在汉字文化圈逐渐流行时，情况又不妙了起来：汉字数量太多，一个字节的8位也不够用了。那么就用两个甚至多个字节来表示一个字符吧，这就是所谓的“宽字符”。不过东方世界的剧情稍有变化，因为此时已有<code>ISO/IEC 2022</code>这一技术规范指导东方文字的编码。中国大陆由此制定了包含6763个汉字的国标码<code>GB 2312</code>，覆盖了绝大多数使用环境。许多生僻字没法处理，于是后来又制定了加入更多汉字的<code>GBK</code>，即国标扩展。但GB 2312留下来的坑一直遗留到最近几年，让名字里有生僻字的人乘飞机或办手续都麻烦不少。</p>
<p>日本产业标准调查会JISC也根据ISO/IEC 2022进行了一系列骚操作，最终形成了<code>Shift JIS</code>。通行于港澳台的<code>Big5</code>也于此时诞生。</p>
<p>微软要在系统里支持这么多种编码，只好使用<code>Windows code page</code>这个值（可以用<code>chcp</code>命令查看）来代表当前系统的编码标准。可能这些五花八门的编码基本都发源于ISO/IEC，往上再追溯一下就到了ANSI的ASCII，于是微软模糊地用<strong>ANSI</strong>来概括了这一切，即我们在Windows中所看到的ANSI并不是某种特定的编码，而是当前区域所使用的编码标准。Windows简体中文系统的Code page是936，早期对应的是GB 2312，在Windows 95之后成为了GBK。而前面所见的Code page 437和Code page 1252也都是这套玩意的一部分。</p>
<p>Code page代码页的机制也体现在Linux中，只是Linux没有“ANSI”这种不科学不严谨的Windows特色表述。而且Linux诞生于1991年的近代，许多历史包袱大可以免去，很快也就支持了Unicode。</p>
<p>啊，Unicode当然才是最重要的一页。</p>
<h1>Unicode拯救世界</h1>
<p>这种乱七八糟的情况持续到80年代末，无论是ISO还是业界都看不下去了。ISO于1988年开始制定<code>ISO 10646</code>通用字符集；几乎与此同时，Apple和Xerox等软件制造商组成Unicode联盟，开始制定<code>Unicode</code>。但他们发现如果两边各自为政，世界又会再次分裂，就像已经对立了几十年的美苏冷战；于是他们开始合作，ISO 10646和Unicode最终基本成了同一样东西——所有的字符都在相同的位置并且有相同的名字。</p>
<p>Unicode编码点分为17个平面（plane），每个平面包含2^16（即65536）个码位（code point）。17个平面的码位可表示为从U+xx0000到U+xxFFFF，其中xx表示十六进制值从0x00到0x10，共计17个平面。</p>
<p>1991年，Unicode 1.0.0横空出世，几乎整合了所有西方字母文字；</p>
<p>1992年，中日韩统一表意文字（<strong>CJK</strong> Unified Ideographs）被定义并加入Unicode。</p>
<p>此后，开放合作、兼容并包成为天下大势，几乎所有能被形容为“现代”的计算机世界物体都支持了Unicode，Unicode本身也在不断发展，不再是一个单纯的“编码”，而是一种标准，包含了Unicode编码方式和多种实现方式，即所谓的Unicode转换格式UTF。你现在所看到的这个网页，使用的就是<code>UTF-8</code>编码实现方式。</p>
<p>关于Unicode的更多内容，这里有一篇讲的很清晰的文章：</p>
<p><a href="https://www.cnblogs.com/malecrab/p/5300503.html">细说：Unicode, UTF-8, UTF-16, UTF-32, UCS-2, UCS-4</a></p>
<h1>“字符集”与“编码”</h1>
<p>前面说了这么多，表述中又有“字符集”（character set），又有“编码”（character encoding），它们到底区别在哪？</p>
<p><strong>“字符集”</strong> 当然是字符的“集”，是各种文字和符号的总称。这指明了有哪些字符是被需要的，以及它们长什么样（字形）。不少汉字在不同区域有不同的写法，字形不统一的情况下如何取舍，就属于字符集的范畴。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99552:/SXHxidJQBRwMWqt.png?authkey=AIbyrqnS5z58phc" alt="次的五种写法：台陆朝越日"></p>
<p><strong>“字符编码”</strong> 是将字符集中的每一个字符都用一串二进制数表示的方法。当我们谈论GB 2312时，我们所说的其实是GB 2312字符集，以及用于对其进行编码的EUC-CN编码方案，这两个事物组合起来才是所谓的“GB 2312编码”。Unicode最“正统”的编码方案是UTF-32，但结合二八定律还是UTF-8更加实用，因此“Unicode编码”的说法是不准确的，所谓的Unicode更像是字符集。</p>
<h1>U+5F41 <strong>彁</strong></h1>
<p>最后，又要首尾呼应地回到东方Project。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1414037312&auto=0&height=66"></iframe>
<p><strong>彁</strong>，这是前面所说的Shift JIS形成的早期，被1978年通商产业省制定的<code>JIS C 6226</code>错误收录的29个不存在的“幽灵汉字”之一。这些汉字一时不知读音、含义也不知具体出典，令人迷惑。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">幽灵汉字</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">垉（52区21点）</td>
<td style="text-align:center">垈（52区18点）</td>
<td style="text-align:center">墸（52区55点）</td>
</tr>
<tr>
<td style="text-align:center">壥（52区63点）</td>
<td style="text-align:center">妛（54区12点）</td>
<td style="text-align:center">岾（54区19点）</td>
</tr>
<tr>
<td style="text-align:center">彁（55区27点）</td>
<td style="text-align:center">恷（55区78点）</td>
<td style="text-align:center">挧（57区43点）</td>
</tr>
<tr>
<td style="text-align:center">暃（58区83点）</td>
<td style="text-align:center">椦（59区91点）</td>
<td style="text-align:center">橸（60区81点）</td>
</tr>
<tr>
<td style="text-align:center">汢（61区73点）</td>
<td style="text-align:center">熕（63区80点）</td>
<td style="text-align:center">碵（66区83点）</td>
</tr>
<tr>
<td style="text-align:center">穃（67区46点）</td>
<td style="text-align:center">粐（68区68点）</td>
<td style="text-align:center">粭（68区70点）</td>
</tr>
<tr>
<td style="text-align:center">粫（68区72点）</td>
<td style="text-align:center">糘（68区84点）</td>
<td style="text-align:center">膤（71区19点）</td>
</tr>
<tr>
<td style="text-align:center">蟐（74区12点）</td>
<td style="text-align:center">袮（74区57点）</td>
<td style="text-align:center">軅（77区32点）</td>
</tr>
<tr>
<td style="text-align:center">鍄（78区93点）</td>
<td style="text-align:center">閠（79区64点）</td>
<td style="text-align:center">靹（80区56点）</td>
</tr>
<tr>
<td style="text-align:center">駲（81区50点）</td>
<td style="text-align:center">鵈（82区94点）</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>1997年，日本对这29个字进行了深入的调查。他们发现其中一些字来自名字极生僻的地名，如静冈县的石橸（いしだる），另一些是被误写、误认的错别字，如“𡚴”被记成了“妛”……最终，29个幽灵汉字中有28个成功找到了来源，“成佛得脱”。</p>
<p>唯独<strong>彁</strong>字，跨越不知多少年，仍然是个谜。</p>
<p>但它就此被保留下来，从JIS C 6226到Shift JIS，到CJK，最后成为Unicode中的“U+5F41”，成为全世界计算机中不可分割的一部分。</p>
<p>也许这个字确实存在其出处，但在这数十年间终于连其最后的出典也散佚。如今留下的只有这永存的痕迹，作为描绘“现实”的字符集中唯一的“幻想”，与相信着车库中有喷火龙的人类一起迈向宇宙的终焉。</p>
]]></content>
      <tags>
        <tag>标准</tag>
        <tag>考古</tag>
        <tag>东方Project</tag>
      </tags>
  </entry>
  <entry>
    <title>C#杂记之壹：委托与事件</title>
    <url>/2020/02/27/C-%E6%9D%82%E8%AE%B0%E4%B9%8B%E5%A3%B9/</url>
    <content><![CDATA[<p>此前虽然接触过C#中的一些较为高级的操作，但基本是只知其有，不知在哪些场景下可以应用。这几天写着代码就顿觉冗杂不堪，虽然能跑但看起来十分难受，希望寻求一些函数式编程之类的魔法来简化流程。</p>
<p>那首先要理解的还是委托和事件。虽然学完了也不一定会用，但看懂一点总是好的。</p>
<h1>委托</h1>
<h2 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h2>
<p>如之前所说，委托类似于函数指针。或者说，委托/是/一种/存储/函数引用/的/<strong>类型</strong>(注意断句)。由于函数的参数须是变量、常量、表达式，只要把函数变成一种<strong>引用类型</strong>的变量，就可以让一个函数作为其它函数的参数了。同样，也可以通过直接调用委托变量来调用委托变量所引用的函数。</p>
<p>为什么要把<strong>类型</strong>加粗？因为声明一个委托类型并不是声明一个委托变量，而是一类委托的<strong>模板</strong>，说明了这类委托应具有的的返回值类型与参数列表。委托类型与具体的委托变量之关系，类似于“类”和“对象”的关系。</p>
<p>委托类型声明和函数类似，拥有返回值类型和参数列表，但没有函数体，并且在前面用<code>delegate</code>关键字声明这是一个委托类型。然后我们再声明这个委托类型的变量：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明委托类型和委托变量</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">double</span> <span class="title">ProcessDelegate</span>(<span class="params"><span class="built_in">double</span> param1, <span class="built_in">double</span> param2</span>)</span>;</span><br><span class="line">ProcessDelegate process;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将函数Multiply注册到ProcessDelegate类型的委托变量process</span></span><br><span class="line">process = <span class="keyword">new</span> ProcessDelegate(Multiply);</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以简写</span></span><br><span class="line">process = Multiply;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多播委托(虽然这里没什么用)</span></span><br><span class="line">process += Divide;</span><br><span class="line">process += Add;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用委托</span></span><br><span class="line">System.Console.WriteLine(<span class="string">$&quot;Result:<span class="subst">&#123;process(<span class="number">12.1</span>, <span class="number">22.4</span>)&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>实际上，委托确实是一种“类”。上面所展示的委托变量声明，其形式就和类的实例化完全一致。在委托变量后面打个点，你甚至能看到一堆委托类型包含的方法和属性：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99556:/xVONQiE1hJIrWf2.jpg?authkey=AIbyrqnS5z58phc" alt="委托也是类"></p>
<span id="more"></span>
<h2 id="何时用委托？"><a class="header-anchor" href="#何时用委托？">¶</a>何时用委托？</h2>
<p><strong>委托的一个有趣且有用的属性是，它不知道也不关心所引用的方法属于哪个类；只关心引用的方法是否具有与委托相同的参数和返回类型。</strong></p>
<p>这就像是当你饿了的时候，并不是非得去哪家特定的饭店吃饭，而是只要你给钱（参数）能得到食物（返回类型）就行了。这样，就无需先通过继承<code>建筑</code>类来构建一个<code>店铺</code>类，再实现一个<code>厨房</code>接口之类的东西，让其成为<code>饭店</code>——而是就算是大街上一个路人你能从TA那买到吃的，也算是能满足你的需求。</p>
<p>因此，委托的大用处在于<strong>解耦</strong>。一个典型的例子是用在<code>LINQ</code>中。下面的示例选取numbers中小于10的数：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> smallNumbers = numbers.Where(n =&gt; n &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>LINQ的详细介绍留至以后，这可以说是C#中最为变态的武器之一，这里只说说Where方法。</p>
<p>Where方法是接口<code>IEnumerable</code>和<code>IEnumerable&lt;T&gt;</code>中的方法，也只有实现了这两个接口之一或它们的派生接口（如<code>IQueryable&lt;T&gt;</code>）的类可以使用LINQ，这种类被称为<strong>可查询类型</strong>。Where方法的原型：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">IEnumerable</span>&lt;<span class="title">TSource</span>&gt; <span class="title">Where</span>&lt;<span class="title">TSource</span>&gt; (<span class="params"><span class="keyword">this</span> IEnumerable&lt;TSource&gt; source, Func&lt;TSource, <span class="built_in">bool</span>&gt; predicate</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>分析一下。</p>
<p>首先，这个方法是一个<code>static</code>方法，并且参数列表的第一个参数被<code>this</code>修饰，这是<strong>扩展方法</strong>的特征。这是因为Where方法之类的LINQ操作并不是直接定义在<code>IEnumerable&lt;T&gt;</code>接口里，而是在<code>System.Linq</code>命名空间中定义的扩展方法。扩展方法的第一个，被<code>this</code>所修饰的参数指明了这个扩展方法扩展的是什么类型。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99557:/yb6g3GTIoA1rB4R.jpg?authkey=AIbyrqnS5z58phc" alt="Where是扩展方法.jpg"></p>
<p>可以看到，如果注释掉<code>using System.Linq</code>，虽然<code>List&lt;int&gt;</code>实现了<code>IEnumerable&lt;T&gt;</code>接口，但其中是无法查找到Where方法的。因此，方法原型中的<code>this IEnumerable&lt;TSource&gt; source</code>，指的就是“Where方法所扩展的是<code>IEnumerable&lt;TSource&gt;</code>接口”。</p>
<p>而后面的<code>Func&lt;TSource, bool&gt; predicate</code>就是一个委托，并且是<a href="#%E6%B3%9B%E5%9E%8B%E5%A7%94%E6%89%98">泛型委托</a>。其中关系到“协变和逆变”之类的高深操作留待<a href="https://hakurei.red/2020/03/02/C-%E6%9D%82%E8%AE%B0%E4%B9%8B%E8%B4%B0/">下次再说</a>。</p>
<p>这个委托用于对每个元素进行测试，看它们是否满足条件。自然，如果满足条件，这个委托将返回bool型的<code>true</code>。泛型委托的泛型类型参数中，最后一个即为委托的返回类型，故而是bool型。而前面的<code>TSource</code>指示了所封装的方法的参数类型。</p>
<p>因此，这个<code>Func&lt;TSource, bool&gt; predicate</code>可以看作是：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">bool</span> <span class="title">FooDelegate</span>(<span class="params">TSource foo</span>)</span>;     <span class="comment">//这里的TSource是某个类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">bool</span> <span class="title">FooFunc</span>(<span class="params">TSource foo</span>)</span>&#123;      <span class="comment">//接收TSource，返回bool的函数</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FooDelegate predicate = <span class="keyword">new</span> FooDelegate(FooFunc);</span><br></pre></td></tr></table></figure>
<h2 id="泛型委托"><a class="header-anchor" href="#泛型委托">¶</a>泛型委托</h2>
<p>除了用<code>delegate</code>关键字声明传统委托之外，还有两种泛型委托：即上面提到过的<code>Func&lt;&gt;</code>和另一种<code>Action&lt;&gt;</code>泛型委托。</p>
<p>使用泛型委托，可以避免传统委托在使用前必须定义委托类型才能用委托变量引用函数的麻烦。</p>
<h3 id="Func-泛型委托"><a class="header-anchor" href="#Func-泛型委托">¶</a>Func&lt;&gt;泛型委托</h3>
<p><code>Func&lt;&gt;</code>泛型委托适用于引用那些返回类型非<code>void</code>的函数。其泛型类型参数的个数可从1-17个不等，其中最后的泛型类型参数代表返回类型，前面的0-16个泛型类型参数代表委托的参数列表。</p>
<p>以下示例用两个泛型委托分别输出List中大于5和小于10的数：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">static</span> System.Console;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">PlayGround</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//定义两个函数</span></span><br><span class="line">            <span class="function"><span class="built_in">bool</span> <span class="title">Foo1</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> num &gt; <span class="number">5</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="built_in">bool</span> <span class="title">Foo2</span>(<span class="params"><span class="built_in">int</span> num</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> num &lt; <span class="number">10</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//定义两个泛型委托</span></span><br><span class="line">            Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt; foo1 = Foo1;</span><br><span class="line">            Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt; foo2 = Foo2;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span>[] input = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">37</span>, <span class="number">256</span> &#125;;</span><br><span class="line">            List&lt;<span class="built_in">int</span>&gt; numsList = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;(input);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> numsList.Where(foo1).ToList())  <span class="comment">//用委托调用函数Foo1</span></span><br><span class="line">                Write(<span class="string">$&quot;<span class="subst">&#123;num&#125;</span> &quot;</span>);   <span class="comment">//Print: 6 10 37 256</span></span><br><span class="line"></span><br><span class="line">            WriteLine();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> numsList.Where(foo2).ToList())  <span class="comment">//用委托调用函数Foo2</span></span><br><span class="line">                Write(<span class="string">$&quot;<span class="subst">&#123;num&#125;</span> &quot;</span>);   <span class="comment">//Print: 1 2 4 5 6</span></span><br><span class="line"></span><br><span class="line">            ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用泛型委托之后，声明委托类型、声明委托变量、引用函数的步骤被结合到了一步：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt; foo1 = Foo1;</span><br></pre></td></tr></table></figure>
<p>当然，上述这个例子用Lambda表达式作为委托还会简单得多：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> numsList.Where(n =&gt; n &gt; <span class="number">5</span>).ToList())    <span class="comment">//用Lambda表达式表示大于5</span></span><br><span class="line">    Write(<span class="string">$&quot;<span class="subst">&#123;num&#125;</span> &quot;</span>);   <span class="comment">//Print: 6 10 37 256</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> numsList.Where(n =&gt; n &lt; <span class="number">10</span>).ToList())   <span class="comment">//用Lambda表达式表示小于10</span></span><br><span class="line">    Write(<span class="string">$&quot;<span class="subst">&#123;num&#125;</span> &quot;</span>);   <span class="comment">//Print: 6 10 37 256</span></span><br></pre></td></tr></table></figure>
<p>实际上，Lambda表达式它完全就是一种委托，属于匿名委托的更简写法。</p>
<h3 id="Action-泛型委托"><a class="header-anchor" href="#Action-泛型委托">¶</a>Action&lt;&gt;泛型委托</h3>
<p>和<code>Func&lt;&gt;</code>的区别在于，<code>Action&lt;&gt;</code>的返回类型是void。因此，泛型类型参数的个数从0~16个不等，全部代表委托的参数列表。这也非常“Action”：传统意义上的“函数”感觉就是得返回点什么（函数值），而什么也不返回的更像是一个“动作”。这个就不再举例了。</p>
<h1>事件</h1>
<h2 id="定义-v2"><a class="header-anchor" href="#定义-v2">¶</a>定义</h2>
<p>事件是在委托的基础上实现的，同样也是解耦利器。</p>
<p>在委托变量的声明前加<code>event</code>关键字就是声明了一个事件。<strong>需要注意，用于事件的委托其返回值一般是void</strong>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个委托类型，接收string，返回void</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">BoilerLogHandler</span>(<span class="params"><span class="built_in">string</span> status</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基于上面的委托类型定义BoilerLogHandler类型的事件BoilerEventLog</span></span><br><span class="line"><span class="comment">//这要求事件处理函数接受string返回void</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> BoilerLogHandler BoilerEventLog;</span><br></pre></td></tr></table></figure>
<p>包含了事件声明定义的类被称为<strong>发布器（publisher）类</strong>；接收事件，并提供事件处理函数的类被称为<strong>订阅器（subscriber）类</strong>。所谓订阅事件的过程，就是将订阅器类的处理函数注册到发布器类那里，当发布器发现事件被引发时，就通知订阅器类去执行相应的处理函数。发布器类有可能同时也是订阅器类之一，而引发事件的类可能既不是发布器类也不是订阅器类。</p>
<p>上面的那段就是发布器类的一部分，定义了事件<code>BoilerEventLog</code>。接下来展示一个相符的订阅器类内容：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//满足BoilerEventLog事件对参数和返回类型要求的函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span> =&gt; Console.WriteLine(<span class="string">$&quot;Message arrived: <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>订阅事件和引发事件：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实例化发布器类和订阅器类</span></span><br><span class="line">Logger myLogger = <span class="keyword">new</span> Logger();</span><br><span class="line">Display myDisplay = <span class="keyword">new</span> Display();</span><br><span class="line"></span><br><span class="line"><span class="comment">//订阅事件</span></span><br><span class="line">myLogger.BoilerEventLog += <span class="keyword">new</span> BoilerLogHandler(myDisplay.DispalyMessage);</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者和委托一样，简化写法：</span></span><br><span class="line">myLogger.BoilerEventLog += myDisplay.DisplayMessage;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引发事件：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用?. 运算符可以轻松确保在事件没有订阅器时不引发事件</span></span><br><span class="line"><span class="comment">//当?. 左侧为null时返回null，非空才访问右侧。没有被订阅的事件就是空的。</span></span><br><span class="line">myLogger.BoilerEventLog?.Invoke(<span class="string">&quot;This is a message.&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>接下来，<code>myLogger</code>对象对<code>BoilerEventLog</code>事件中是否有被注册的事件处理函数进行检查，发现有来自<code>myDisplay</code>的处理函数<code>DisplayMessage()</code>，于是传入的参数<code>&quot;This is a message.&quot;</code>被送给处理函数进行处理。</p>
<h2 id="与多播委托的区别？"><a class="header-anchor" href="#与多播委托的区别？">¶</a>与多播委托的区别？</h2>
<p>目前看来，区别就是没什么太大区别，以至于C#文档里都有这么一篇：<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/distinguish-delegates-events">区别委托和事件</a>。</p>
<p>如<a href="/2020/02/27/C-%E6%9D%82%E8%AE%B0%E4%B9%8B%E5%A3%B9/%E5%A7%94%E6%89%98/%E5%AE%9A%E4%B9%89">委托/定义</a>所言，委托其实也是类，定义的每一种委托都继承自<code>Delegate</code>类。而<code>Delegate</code>类拥有一个静态的<code>Delegate.Combine()</code>方法，用于将同类型多个委托变量的调用列表进行连接合并。这个方法可以由C#编译器对运算符<code>+</code>转译而来（并不是运算符重载）。这和<code>String</code>类的字符串连接是一样的。</p>
<p>多播委托的执行顺序是固定的，按照<code>GetInvocationList()</code>方法所得数组的逆序执行；事件则是不可预测顺序的（据称）。</p>
<p>不过，接下来就有区别了，这个才是重点。</p>
<h2 id="EventHandler"><a class="header-anchor" href="#EventHandler">¶</a>EventHandler</h2>
<p>C#预定义了委托<code>EventHandler</code>和泛型委托<code>EventHandler&lt;TEventArgs&gt;</code>用来写发布器。事实上，考虑到事件引发时通常需要传入不少各种各样的参数，相比前面与多播委托基本没区别的语法，使用这种预定义的事件要更多。</p>
<p>原型：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">EventHandler</span>&lt;<span class="title">TEventArgs</span>&gt;(<span class="params"><span class="built_in">object</span> sender, TEventArgs e</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>这两个参数，第一个是事件源，在引发事件时填写<code>this</code>即可；第二个参数的类型派生自<code>System.EventArgs</code>，包含任意个事件参数。派生自<code>System.EventArgs</code>的类有很多很多，其中都是C#预先定义的事件形参。</p>
<p>而泛型委托<code>EventHandler&lt;TEventArgs&gt;</code>的区别在于，第二项参数可以不派生自<code>System.EventArgs</code>，而是泛型类型<code>TEventArgs</code>。这意味着，假如希望在引发事件时传入10种参数，你可以写一个类作为<code>TEventArgs</code>，在里面定义10项属性。引发事件时，实例化这个类，把构造出的对象传到第二项参数里。</p>
<p>这个过程相当于是引发事件的类填了一张表格寄出去。表格的格式是预先设计好的，无论是派生自<code>System.EventArgs</code>的类，还是泛型委托里根据泛型类型参数自己写的那个类，其属性是在填写表格之前就确定了的。寄出去的除了填写完整的表格<code>e</code>之外，信封上还有你的联系方式<code>sender</code>。这样，收件人（发布器类）才能知道信是谁寄来的，也能够确定信里表格的格式是符合要求的。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个定义的例子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">event</span> EventHandler&lt;MessageArrivedEventArgs&gt; MessageArrived;</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件参数类的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MessageArrivedEventArgs</span> : <span class="title">EventArgs</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Message</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;<span class="keyword">return</span> message;&#125;    <span class="comment">//让message通过Message只读</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显式定义无参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageArrivedEventArgs</span>()</span>=&gt;</span><br><span class="line">        message = <span class="string">&quot;No message sent.&quot;</span></span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageArrivedEventArgs</span>(<span class="params"><span class="built_in">string</span> newMessage</span>)</span>=&gt;</span><br><span class="line">        message = newMessage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引发事件，第一个参数是this，第二个实例化事件参数类</span></span><br><span class="line">MessageArrived(<span class="keyword">this</span>, <span class="keyword">new</span> MessageArrivedEventArgs(<span class="string">&quot;Hello World!&quot;</span>))；</span><br></pre></td></tr></table></figure>
<p>最后要注意的是，如果事件根本不需要传入参数，依然可以用<code>EventHandler</code>委托来定义，只要向第二项参数里传入<code>EventArgs.Empty</code>就行了。</p>
<blockquote>
<p>暂且到此为止，明天应当学习协变、逆变，以及LINQ。</p>
</blockquote>
]]></content>
      <tags>
        <tag>C Sharp</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C#杂记之贰：协变与逆变</title>
    <url>/2020/03/02/C-%E6%9D%82%E8%AE%B0%E4%B9%8B%E8%B4%B0/</url>
    <content><![CDATA[<p>昨天费力把上一篇中的“事件”章节给写完了，弄明白的确实不少（发现弄不明白的更多了）。</p>
<p>由于沉迷《饥荒》，并且也因为有点抗拒没听说过的概念，这一篇鸽到了现在。今天还是开始看吧。</p>
<p><strong>协变</strong>（Covariance）和<strong>逆变</strong>（Contravariance）统称为变体（Variance）。</p>
<h1>协变</h1>
<p>协变是指，对派生程度更大的类型的支持。也就是说，对于某处要求的类型，传入它的派生类也是没关系的。这是很容易理解的，因为子类可以隐式地转换为基类。协变体现的即是面向对象程序设计思想中，所谓的“<strong>里氏替换原则</strong>”（Liskov Substitution Principle）：任何基类可以出现的地方，子类一定可以出现。</p>
<h1>逆变</h1>
<h2 id="神秘的问题"><a class="header-anchor" href="#神秘的问题">¶</a>神秘的问题</h2>
<p>比较难以理解的是逆变。与协变相反，这是对派生程度更小的类型的支持。比如在要求<code>string</code>的地方支持使用<code>object</code>。什么地方会出现这种看似违反里氏替换原则的“危险”操作呢？</p>
<p>在翻阅了许多文档之后，我反而是在<a href="https://github.com/jkchao/typescript-book-chinese/blob/master/docs/tips/covarianceAndContravariance.md">《深入理解 TypeScript》</a>中找到了较为明白的解释，下面我试着用C#的方式叙述一下。</p>
<p>假设<code>Greyhound</code> （灰狗）是 <code>Dog</code> （狗）的子类，而 <code>Dog</code> 则是 <code>Animal</code> （动物）的子类。由于子类型通常是可传递的，因此我们也称 <code>Greyhound</code> 是 <code>Animal</code> 的子类。这是显然的。</p>
<p>那么，一个问题出现了：</p>
<p><strong>如果我们有一个委托<code>Func&lt;Dog, Dog&gt;</code>，是不是真的只能分配那些接受<code>Dog</code>为参数，并返回<code>Dog</code>的方法呢？</strong></p>
<span id="more"></span>
<p>根据里氏替换原则，既然灰狗是狗的子类，似乎我们完全可以用灰狗来代替狗：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Dog类的DogBark()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Dog <span class="title">DogBark</span>(<span class="params">Dog dog</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    WriteLine(<span class="string">&quot;A Dog:&quot;</span> + dog.dogMessage);</span><br><span class="line">    <span class="keyword">return</span> dog;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Greyhound类的GreyhoundBark()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Greyhound <span class="title">GreyhoundBark</span>(<span class="params">Greyhound greyhound</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    WriteLine(<span class="string">&quot;A Greyhound: &quot;</span> + greyhound.greyhoundMessage);</span><br><span class="line">    <span class="keyword">return</span> greyhound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Func&lt;Dog, Dog&gt; LetDogBark = <span class="keyword">new</span> Func&lt;Dog, Dog&gt;(dog.DogBark);</span><br><span class="line"></span><br><span class="line"><span class="comment">//CS0123: &quot;GreyhoundBark&quot;没有与委托&quot;Func&lt;Dog,Dog&gt;&quot;匹配的重载</span></span><br><span class="line">LetDogBark += greyhound.GreyhoundBark;</span><br></pre></td></tr></table></figure>
<p><code>Greyhound</code>不是可以完全代替<code>Dog</code>吗？这里怎么会报错呢？这是因为当调用委托时，可能传入一个虽然是狗但不是灰狗的对象作为参数，比如德国牧羊犬<code>GermanShepherd</code>。德国牧羊犬当然没法执行灰狗的<code>GreyhoundBark()</code>方法。虽然子类可以代替基类，但子类之间是不一定能兼容的，这就是在委托里出现的特殊情况。</p>
<p>解决的方法就是逆变，即委托所指定的参数类型为<code>Dog</code>时，只能分配参数类型为<code>Dog</code>或派生程度更小的<code>Animal</code>的方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在Greyhound类另定义GreyhoundBarkAlter()，以Animal为参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Greyhound <span class="title">GreyhoundBarkAlter</span>(<span class="params">Animal animal</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    WriteLine(<span class="string">&quot;A Greyhound: &quot;</span> + animal.animalMessage);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//这回不报错了</span></span><br><span class="line">Func&lt;Dog, Dog&gt; LetDogBark = <span class="keyword">new</span> Func&lt;Animal, Greyhound&gt;(greyhound.GreyhoundBarkAlter);</span><br></pre></td></tr></table></figure>
<h2 id="理解"><a class="header-anchor" href="#理解">¶</a>理解</h2>
<p>现在，我们可以回答上面提出的问题了。对于<code>Dog=&gt;Dog</code>的委托，哪些方法是可以分配的呢？</p>
<p><strong>不仅可以将具有匹配签名的方法分配给委托（即Dog=&gt;Dog的方法）；</strong></p>
<p><strong>还可以根据协变，分配与委托类型指定的派生类型相比，返回派生程度更大的类型的方法（即Dog=&gt;Greyhound的方法）；</strong></p>
<p><strong>或根据逆变，接受具有派生程度更小的类型的参数的方法（即Animal=&gt;Dog的方法）。</strong></p>
<p>这个规则初看起来很怪，让人感觉其中会存在漏洞，比如一个对象协变逆变几次之后可不可能被当成一个八竿子打不着的类的对象？举个例子，除了上述的<code>Animal</code>、<code>Dog</code>、<code>Greyhound</code>之外，我们再引入一个继承自<code>Animal</code>的<code>Fish</code>类。这样，这几个类的继承树就是如此：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99558:/osIJ72AYHXaKv6O.png?authkey=AIbyrqnS5z58phc" alt="继承树"></p>
<p>如果我想捣点乱，比如试图把一只<code>Dog</code>传进去，经过一些变体操作后将它伪装成一条<code>Fish</code>，传进某个委托的参数里，引发崩溃。是否可能实现这一邪恶计划呢？</p>
<p>假如现在有一个<code>Fish=&gt;Fish</code>的委托，是我们要下手的目标。根据委托参数的逆变性，我们只能传入<code>Animal</code>或<code>Fish</code>。那么，我们就先把<code>Dog</code>伪装成<code>Animal</code>。这好像很简单，只要用一个<code>Dog=&gt;Dog</code>的方法返回自己，再依照协变性将这个方法分配给<code>Dog=&gt;Animal</code>的委托就能做到，甚至直接<code>as Animal</code>都可以。</p>
<p>但当我写下上面这一段之后，我意识到了我认知上的错误。</p>
<blockquote>
<p>根据委托参数的逆变性，我们只能传入<code>Animal</code>或<code>Fish</code>。</p>
</blockquote>
<p>这是不对的。必须强调，逆变性并不是指我们能实现“给<code>Fish=&gt;Fish</code>类型的委托传入<code>Animal</code>类型参数”这样的“基类代替子类”的操作，<strong>而是指我们能把<code>Animal=&gt;Fish</code>的方法封装进<code>Fish=&gt;Fish</code>类型的委托变量。</strong> 在这里<code>Animal</code>是<code>Fish</code>的父类，看起来就像是违反了里氏替换原则。但实际上，这恰恰是里氏替换原则的体现：</p>
<p>当我们调用要求传入<code>Fish</code>的委托时，根据里氏替换原则，只能传入派生程度一致或更高的参数，比如<code>Fish</code>类自己的对象。而这个<code>Fish</code>类型的参数，相比起被封装在<code>Fish=&gt;Fish</code>委托里面的<code>Animal=&gt;Fish</code>方法所要求的<code>Animal</code>类型参数而言，其派生程度是更高的。换句话说，<strong>对于被封装的<code>Animal=&gt;Fish</code>方法，逆变恰恰使得<code>Fish</code>这个子类代替了<code>Animal</code>这个基类，这是符合里氏替换原则的！</strong></p>
<blockquote>
<p>另外还有一个概念是不变体（Invariance），这限定了只能使用原始指定的类型，无论是其基类还是子类还是别的类都不被接受。</p>
</blockquote>
<h1>自定义泛型委托中的变体</h1>
<p>上面说的支持变体的委托，是指<code>Func&lt;&gt;</code>和<code>Action&lt;&gt;</code>这两种C#预定义的泛型委托，它默认参数类型逆变，而返回类型协变。如果是自定义的泛型委托，则需要手动指定参数和返回类型的变体（不过很少会有需要自定义泛型委托的场景）。</p>
<p>我们用<code>out</code>和<code>in</code>泛型修饰符来进行指定，<code>out</code>代表支持协变，<code>in</code>代表支持逆变：</p>
<p>协变：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 支持协变的委托，out修饰符修饰的是返回类型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> R <span class="title">DCovariant</span>&lt;<span class="keyword">out</span> <span class="title">R</span>&gt;()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符合委托签名的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Control <span class="title">SampleControl</span>()</span></span><br><span class="line">&#123; <span class="keyword">return</span> <span class="keyword">new</span> Control(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Button <span class="title">SampleButton</span>()</span></span><br><span class="line">&#123; <span class="keyword">return</span> <span class="keyword">new</span> Button(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">&#123;            </span><br><span class="line">    <span class="comment">// 将委托实例化</span></span><br><span class="line">    DCovariant&lt;Control&gt; dControl = SampleControl;</span><br><span class="line">    DCovariant&lt;Button&gt; dButton = SampleButton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dButton可以赋给dControl</span></span><br><span class="line">    <span class="comment">// 因为DCovariant委托是支持协变的</span></span><br><span class="line">    dControl = dButton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用委托</span></span><br><span class="line">    dControl(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逆变：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 支持逆变的委托，in修饰符修饰的是参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">DContravariant</span>&lt;<span class="keyword">in</span> <span class="title">A</span>&gt;(<span class="params">A argument</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 符合委托签名的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SampleControl</span>(<span class="params">Control control</span>)</span></span><br><span class="line">&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SampleButton</span>(<span class="params">Button button</span>)</span></span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将委托实例化</span></span><br><span class="line">    DContravariant&lt;Control&gt; dControl = SampleControl;</span><br><span class="line">    DContravariant&lt;Button&gt; dButton = SampleButton;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dControl可以赋给dButton</span></span><br><span class="line">    <span class="comment">// 因为DContravariant委托是支持逆变的</span></span><br><span class="line">    dButton = dControl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用委托</span></span><br><span class="line">    dButton(<span class="keyword">new</span> Button()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>泛型接口中的变体</h1>
<p>除了泛型委托之外，泛型接口里也会运用到变体。</p>
<p>非常常用的<code>IEnumerable&lt;T&gt;</code>、<code>IEnumerator&lt;T&gt;</code>、<code>IQueryable&lt;T&gt;</code> 和<code>IGrouping&lt;TKey,TElement&gt;</code>泛型接口，它们的所有类型参数都是协变类型参数，这些类型参数只用于成员的返回类型。</p>
<p>另外还有<code>IComparer&lt;T&gt;</code>、<code>IComparable&lt;T&gt;</code>和<code>IEqualityComparer&lt;T&gt;</code>等接口，它们的所有类型参数都是逆变类型参数，只用于接口成员中的参数。</p>
<p>关于接口我的理解还不够深入，这里就不展开讨论了。</p>
<blockquote>
<p>开题答辩即将开始，报告一笔未动，不知道最近还有没有机会写LINQ与异步，看情况吧。</p>
</blockquote>
]]></content>
      <tags>
        <tag>C Sharp</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>200305：写在开题答辩之前</title>
    <url>/2020/03/05/200305/</url>
    <content><![CDATA[<p>这一篇虽记于3月4日，但一看日历，明日惊蛰，四舍五入等我写完便也是依照惯例的特殊日随笔了，那就把时间改为明天的第一帧吧。</p>
<p>写这篇的主要目的是作毕业设计工作进度的报告，因为昨天接到10号便要开题答辩的通知，依照要求我应在两天之内联系导师汇报工作进度。回过神来已是晚上八点，再不总结一下就要来不及了。</p>
<h1>干了些什么？</h1>
<p>太长不看，上列表：</p>
<ul>
<li>决定转向游戏制作</li>
<li>学习C#和游戏学基础</li>
<li>学习Aseprite和Photoshop</li>
<li>TextMesh Pro和UGUI</li>
<li>DanmakU类库，弹幕的生成</li>
<li>Pixel Perfect效果</li>
<li>实现基本的游戏逻辑</li>
</ul>
<span id="more"></span>
<h2 id="决定转向游戏制作"><a class="header-anchor" href="#决定转向游戏制作">¶</a>决定转向游戏制作</h2>
<p>从<a href="https://hakurei.red/2019/11/02/191102/">191102</a>起，我由于开始接触C#这门与大数据开发关系不太深的语言，更由于自己一直以来的一些爱好与愿望，决定转向游戏制作。</p>
<p>那时的计划是先系统性学习C#，然后逐步了解Unity引擎，尝试在实验室工作之外制作一个东方同人游戏，既贴合毕业所需，也可作为日后求职的材料。</p>
<h2 id="学习C-和游戏学基础"><a class="header-anchor" href="#学习C-和游戏学基础">¶</a>学习C#和游戏学基础</h2>
<p>计划刚一开始，接下来的半个月就在实验室的忙碌中度过，常常是晚上回家还需要继续研究到深夜，系统性的学习就暂且推迟了。期间我也听从一些建议，购入了《C#入门经典》和《游戏设计、原型与开发》。这两本书的确值得一读，明晰的思路和通俗的语言往往能让我从文档的苦海中挣脱，也能纠正我许多先入为主的错误思想。</p>
<p>于是11月17日，在去向导师报到之前，我花了几天学习Unity官方发布的脚本开发视频教程，对C#这门语言的总体有了一定的认识。</p>
<p>既然在此之前学习过C++、Java和Python，按理说对面向对象程序设计已经轻车熟路，但C++和Java我实在是面向考试学习，所剩下来的只有那些马光志老师所曰“静态成员指针，析构过程，虚基类……”云云的诘屈聱牙，还有Eclipse那丑陋不堪、摇摇欲坠的界面。至于OOP的思想么，是一点也没学到，更没能掌握其全貌。</p>
<p>Python亦是门乱七八糟的语言，从GitHub上弄下来的代码十页里有两页能跑就该念安拉至大了。我仅仅是囫囵吞枣，了解到了一门编程语言的语法可以这么精简，性能也可以这么低下。切实的好处也是有的：我仰仗着Python胡写一气考完了CSP，而如果当时用的是C++，那分数恐怕得打对折。</p>
<p>C#则不同。也不知道是不是因为学习的是英文课程，老外讲这些东西尤其有天分，许多一团乱麻的地方变得直观了起来。除了C#的基础之外，还讲解了一些Unity的重要概念，这下我稍微有了一点信心，也产生了自己很快就能上手的“错觉”。</p>
<p>从导师那里回来之后，我要做的事只剩下了一件：基本完全独立的游戏开发。想到自己即将开始做和ZUN当年相同的事，不觉有些热血上涌。第一步当然是策划，不过既然只有我一个人，我当时认为可能没必要弄得这么“正式”。当然这是错误的，比如现在我就深受没有早些写策划案之害，需要从零开始与开题报告的Deadline斗争了。</p>
<p>不过我还是开始读那本《游戏设计、原型与开发》，看了些游戏分析框架与“涌现”概念、设计思路的内容。在这个过程中，我虽没有完整的策划案，总算是从零碎的思绪中揪出了个大致方向——庚子之灾。《東方珀露澗 ~ Aurora of Dragon Lore.》的名字就是在这时取的。</p>
<p>这段时间也是我2019年学习最为狂热的几天，博客完全是日更，以至于某位少女都为此表示了认可。</p>
<h2 id="学习Aseprite和Photoshop"><a class="header-anchor" href="#学习Aseprite和Photoshop">¶</a>学习Aseprite和Photoshop</h2>
<p>十二月初，我意识到自己必须得做一些中等意思的美术工作。由于《东方月神夜》和《幻想乡萃夜祭》给我带来的极大冲击和传统美术风格的较高门槛，我选择尝试创作像素艺术风格的美术素材。</p>
<p>因此，开始接触专用于像素艺术的Aseprite和美工万能的Photoshop。Photoshop是被我用得不如PowerPoint，Aseprite倒是掌握了些。最初的像素作品显然是不忍直视，尽管花去了一整天：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99522:/rWmnCw9V1uBeDH6.gif?authkey=AIbyrqnS5z58phc" alt="第一幅妖梦"></p>
<p>寒假回家之后，我又花了一段时间学习Aseprite的使用以及创作像素艺术的技巧，对于明暗和比例有了基本的概念。这是2月15日，作为测试用敌机而绘制的鬼人正邪，比起上面有了明显的进步：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99559:/kd1UyB28NIfcCtl.png?authkey=AIbyrqnS5z58phc" alt="正邪"></p>
<p>之后，关注已久的国行Switch发布了，看完发布会失望的我当即去买了日版Switch，度过了一段没日没夜的日子——终于是成为了“高贵的主机玩家”。</p>
<h2 id="消失的两个月"><a class="header-anchor" href="#消失的两个月">¶</a>消失的两个月</h2>
<p>最初的开发工作进行后不久，综合能力培养课程设计就开始了，我也久违地参与到有一定复杂度和体量的工程中去。这段时间长达一个月，很忙，也很迷茫，有种“刚起跑就跌倒”的感觉。中途也仅仅是探求了Unity异步场景加载这一个问题。</p>
<p>不过十二月的某个下午，恭听了一位资深.NET巨佬对C#的演示讲解，许多之前没有深入接触的概念涌现出来——静态、异步、接口、转型、委托、事件、集合、LINQ……堪称“一日看尽长安花”。这些内容，我直到现在都在试着慢慢消化理解，最近一周写的C#杂记也正是为了这一点。</p>
<p>一月初，课设和大四上学期一起结束，其中留下的一些坑让我后来又进行了两次考据。放假之后，家里大小杂事，加上我好不容易有了前往海拉鲁大陆的机会，就此一直忙到快过年。</p>
<p>接下来的事大家都明白，一月底，新冠肺炎来了。瘟疫撞上新年，这下又有了可忙的事。一直到2月11日，我才时隔两个月再次打开Unity。</p>
<h2 id="TextMesh-Pro和UGUI"><a class="header-anchor" href="#TextMesh-Pro和UGUI">¶</a>TextMesh Pro和UGUI</h2>
<p>接续开发进度的第一件事是完善之前只有背景图片的主菜单。</p>
<p>这里用到了Unity的UGUI工具集，主要是用Event控制的一系列GameObject：Canvas，Image，Button，Text等等。为了实现不同分辨率下的有层次的布局，又接触了多摄像机和锚点等UI设计的知识。</p>
<p>为了更加接近东方正作主菜单的逻辑，完全用键盘控制菜单、实现按钮的动画和音效，中间也进行了许多折腾。</p>
<p>不得不吐槽的是UGUI中的Text组件，渲染效果十分感人：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99476:/AgXQhHJ9CUlykEs.jpg?authkey=AIbyrqnS5z58phc" alt="模糊的Text"></p>
<p>公认的对策是“曲线救国”：先把字号调得巨大，再把缩放调得极小，强行让显示效果变得清晰。这里我得将缩放调整为0.2，字号调到159才有了较为锐利的效果：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99477:/5hdfeoBDHNJvjUI.jpg?authkey=AIbyrqnS5z58phc" alt="曲线救国"></p>
<p>为此，完美的解决方案是使用TextMesh Pro，其实Unity已经收编了这个第三方工具，放在了新版本Unity的Package Manager里。</p>
<p>这个基本成型的主界面虽简陋得很，背景也是<a href="https://www.pixiv.net/artworks/42856952">从Pixiv上拉来的</a>，但勉强能用，看得过去。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99560:/kjJHdAK6FUepgv7.jpg?authkey=AIbyrqnS5z58phc" alt="主菜单"></p>
<p>即使是320*240的极低分辨率，也能较好（？）地显示。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99561:/a9u57DCd2oLTxAV.jpg?authkey=AIbyrqnS5z58phc" alt="低分辨率主菜单"></p>
<p>读取文档界面：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99612:/UeLpRQ9yuvdW4YT.jpg?authkey=AIbyrqnS5z58phc" alt="文档界面"></p>
<h2 id="DanmakU类库，弹幕的生成"><a class="header-anchor" href="#DanmakU类库，弹幕的生成">¶</a>DanmakU类库，弹幕的生成</h2>
<p>（糟，要写不完了，省着点，详细的还是报告里补充吧）</p>
<p>制作弹幕是既困难又简单的部分，这个部分的设计在后面的工作中可能会花去我的主要时间。纯粹的的“Bullet Hell”实现起来可能相对简单，而要制作包含一定意蕴的“符卡”，其复杂度就需要为之慎重考量了。</p>
<p>以前玩过用东方弹幕风和LuaSTG制作的弹幕射击游戏，Unity引擎里有没有能辅助制作弹幕的工具呢？无论如何，至少在Unity上实现极复杂的符卡是可以的，SlimeSmile团队的作品就是很好的例子。</p>
<p>GitHub上一找还真的有，是Google的工程师开发的开源类库<a href="https://github.com/james7132/DanmakU">DanmakU</a>，想来这个大写的U所代表的应当是Unity。这个库容量不大，开发时间跨度却已长达5年，还有着天坑遍地、语焉不详的要命文档，但它确实是个不错的选择——大不了我Fork过来自己改就是了。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99562:/KnzCNdg9b5TVWZB.png?authkey=AIbyrqnS5z58phc" alt="DanmakU"></p>
<p>DanmakU的思想是重点处理那些占绝大部分的“fire and forget”的子弹，将1023个子弹一同进行GPU绘制请求，而不是将每个子弹视作独立的个体，同时使用尽量多的线程处理。这可以极大地降低垃圾回收的开销，保持CPU低占用，充分使用GPU加速。</p>
<p>以下是一个使用DanmakU绘制的，简单的单发射点弹幕示例：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99563:/I1pSQHZWwL7FbEh.png?authkey=AIbyrqnS5z58phc" alt="DanmakU绘制弹幕"></p>
<h2 id="Pixel-Perfect效果"><a class="header-anchor" href="#Pixel-Perfect效果">¶</a>Pixel Perfect效果</h2>
<p>Unity起初是个面向3D游戏的引擎，对2D的支持也是近年来才逐步完善。对于像素游戏而言，如果希望做到尽善尽美，Unity就存在一些不足。可能出现的问题在这篇文章里有很好的分析：<a href="https://zhuanlan.zhihu.com/p/55367765">制作传统风格像素游戏时的几个陷阱 - Aya Magician</a></p>
<p>其中较为重要的问题就是像素对齐。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99564:/V9dc4qHm1AoKt6D.jpg?authkey=AIbyrqnS5z58phc" alt="像素对齐"></p>
<p>另外就是Unity中可能出现的像素大小不均，不知道是否有相应的专业术语：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99565:/vYGFLB15dmbolKJ.jpg?authkey=AIbyrqnS5z58phc" alt="像素大小不均"></p>
<p>这些问题被Pixel Perfect Camera部分解决了。这是使用之后的效果，像素大小均匀统一，边缘非常清晰锐利，且完美对齐。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99566:/mYIKiA8jLSJnlhv.jpg?authkey=AIbyrqnS5z58phc" alt="Pixel_Perfect_Camera.jpg"></p>
<p>但实际上，完全对齐的像素会降低游戏在观感上的帧率，移动过程中还会有锯齿感，不适合对帧率要求高的弹幕游戏，故我在游戏设置中提供了像素对齐的开关选项。</p>
<h2 id="实现基本的游戏逻辑"><a class="header-anchor" href="#实现基本的游戏逻辑">¶</a>实现基本的游戏逻辑</h2>
<p>这里主要涉及到的是用户操作和碰撞检测。</p>
<p>用户操作大体上无需赘述，但有一个细节是需要注意的：</p>
<p>对于斜方向的移动，如果只是简单地将水平速度和垂直速度叠加，会造成沿对角线1.414倍速的移动，导致不连续的操作手感，增大失误的可能性。因此，当检测到同时存在Horizontal和Vertical的输入时，应当将横纵速度均削减为0.707倍，这样对角线上的合速度就能与横纵方向上的速度保持一致。</p>
<p>Unity引擎的碰撞由Rigidbody（刚体）和Collider（碰撞体）引发，但DanmakU由于其原理上的特殊性，处理起来稍显麻烦。更要命的是，文档里涉及到碰撞处理的部分居然是一片空白！</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99567:/okdhyMnRmuNcFzw.png?authkey=AIbyrqnS5z58phc" alt="空白的DanmakU文档"></p>
<p>于是我只好在读了半天源码，并且在Visual Studio里调试之后，才初步明白碰撞检测和处理的方法。</p>
<h1>最后……“随笔”的部分</h1>
<p>在写这篇文章前不久，接到了米哈游的策划笔试题。</p>
<p>原本想着我大概不能算是一个合格的开发，便打消了投开发岗的念头，且看到各公司关于策划的说明好像与我十分符合，竟“一时兴起”地改了改简历投了策划。学开发出身的策划——也许还是有其价值的吧？</p>
<p>看到题目的时候，我就惊了。虽不能透露，总之是在我的知识范围之外，也明白那些要求是实打实的有用。两周的期限，我还得先用一个星期准备开题答辩，真有点悬。</p>
<p>不过所谓“努力”，就是克服困难去做想做的事。无论旁人看来的结果如何，对于自己来说，只要为之付出过，就永远是成功的。</p>
<blockquote>
<p>庚子惊蛰。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>Unity</tag>
        <tag>C Sharp</tag>
        <tag>游戏</tag>
        <tag>东方Project</tag>
      </tags>
  </entry>
  <entry>
    <title>试分析苇名弦一郎的BOSS设计</title>
    <url>/2020/03/16/%E8%AF%95%E5%88%86%E6%9E%90%E8%8B%87%E5%90%8D%E5%BC%A6%E4%B8%80%E9%83%8E%E7%9A%84BOSS%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>对BOSS战的分析，可以从战斗机制的设计和对玩家能力的考验两个方向进行。</p>
<h1>战斗机制</h1>
<p>何谓战斗机制？</p>
<p>“机制”这个词实在太宽泛。几个月前我曾在<a href="https://hakurei.red/2019/11/20/%E6%B8%B8%E6%88%8F%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%A3%B9/">这篇笔记</a>里总结过一次。</p>
<p>根据MDA框架，机制是“数据层面上的组件与算法”；形式、戏剧和动态元素框架中，“机制”基本等同于“形式”元素，即交互模式、目标、规则、过程、资源、边界、结局等等。四元法有一元是机制，指的是“玩家与游戏互动的规则”，也是游戏与其他非互动性媒体的区别所在。</p>
<p>不过，我们仍然可以把“机制”换个词，用“规则”来代替。更进一步的，战斗机制即是指，在战斗时，玩家能做什么？</p>
<p>那么《只狼》的战斗中，玩家能做什么？</p>
<p>最大的特色就是“打铁”，即弹反与架势槽。这个机制把传统动作游戏里高难度、高回报、低频率的“弹反”完全逆转成为难度相对偏低、回报不算明显，但使用频率极高的一种主要操作。《只狼》的战斗目标不再是单纯的削血，而主要是以进攻和弹反使敌人的架势槽涨满，此时即可一击必杀（忍杀）。同时架势槽的自然回落速度随剩余血量的减少而变慢，架势槽和血槽成为了相辅相成的两个机制。</p>
<p>第二点是处理敌人的“危”攻击。敌人偶尔发动无法格挡的技能，玩家头顶会浮现出红色的“危”字，这时就需要玩家根据敌人的起手动作，紧急判断下一步的应对措施。所谓的“危”其实也蕴含着“机”，如果处理得当，可以对敌方架势槽造成较大的上升。</p>
<p>主要的“危”攻击有两种类别，一是突刺，无法格挡，可以精准弹反，但正确的处理是在突刺的瞬间向敌人脸上垫步发动“识破”，造成较大的架势条上涨；二是横扫，最佳的处理方法是跳到敌人头上踩踏，亦可以造成较大的架势条上涨。一些BOSS战中能用“雷电奉还”反弹雷电攻击，而少数敌人能使出的擒抱攻击只能靠闪避处理。</p>
<span id="more"></span>
<h1>玩家能力</h1>
<p>何谓玩家能力？</p>
<p>这里我找到两种说法。</p>
<p>第一种说法：</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/60192653">五石. 设计方法论001-确定游戏类型与玩家能力</a>：</p>
<p>这个时候我们会引入一个东西叫做玩家能力（也叫玩家技巧）。我们会设立几个维度，如策略/操作/游戏知识等，然后在这个品类下为我们要考察的玩家能力划分等级。依然举例子来说明：</p>
<ul>
<li>黑魂系列：大量的操作和游戏知识技巧，极少的策略技巧。</li>
<li>文明系列：大量的策略，中等的游戏知识，少量的操作。</li>
<li>刀塔自走棋：中等的策略，中等的游戏知识，少量的操作。</li>
<li>守望先锋：中等的策略，少量的游戏知识，大量的操作。</li>
</ul>
</blockquote>
<p>策略指的是较长期的规划，操作指的是短期的反应能力，游戏知识则是对游戏机制的全面了解。既然是动作游戏，策略显然是不怎么需要考虑的，主要考验的就是操作和游戏知识。</p>
<p>第二种说法：</p>
<blockquote>
<p><a href="https://www.gameres.com/459042.html">小篱. 让新手成为核心玩家——从玩家能力分析开始</a>：</p>
<p>玩家的能力大致可以归纳为两大类八小类：</p>
<p>第一大类，集中力和肌肉的协调能力</p>
<ul>
<li>时机：考验玩家是否在正确的时间按键。比如跳舞类游戏，音乐游戏，对打游戏中出连招的时机，或者掐着时间跳平台。</li>
<li>估量：考验玩家是否估量准确通过挑战的幅度。比如赛车类游戏，玩家在拐弯时要把握好转弯的速度和幅度。</li>
<li>精确：考验玩家是否在一个精确的位置输入操作。比如射击类游戏，玩家需要精确的瞄准敌人。</li>
<li>反应：考验玩家对于一个不能预测的突发情况是否在正确的时刻输入操作。比如对打游戏，街头霸王的玩家需要很快的躲避，挡格。赛车游戏中高速行驶的车需要躲开迎面而来的车辆或者障碍。</li>
</ul>
<p>第二大类，分析力、逻辑思维和记忆力</p>
<ul>
<li>战术：分析当前观察到的信息很快的做出决定，这个决定具有短期影响。比如反恐精英CS中，玩家需要根据对方的攻击重点，来调整自己队伍的攻防重点。比如RPG回合制游戏中，玩家需要分析怪物的血量，技能，抗性，判断出怪物的弱点，安排好自己的技能顺序。</li>
<li>策略：分析当前观察到的信息用了很长时间做出决定，这个决定具有长期影响。比如WOW中，玩家有很多天赋树的选择，不同的天赋的选择往往会导致玩家的攻击或者治疗效果的不一样。比如足球游戏中，玩家对于阵形和球员的调整。</li>
<li>管理：分配自己有限的资源。比如生化危机中玩家只有固定的少量的背包空格，需要安排好弹药和补给的数量。比如管理游戏，铁路大亨，虚拟人生。</li>
<li>机智：收集信息和线索去解决问题。比如古墓丽影中玩家需要思考机关的破解方式，生化危机中玩家需要收集很多道具去打开一个机关，比如手机上的很多益智游戏。</li>
</ul>
</blockquote>
<p>第二种解释较为详细，更加适合用来分析。第一大类基本可以归为“操作”，第二大类中，除了“策略”之外的的战术、管理、机智则可以归为“游戏知识”。</p>
<h1>为什么是弦一郎？</h1>
<p>这是因为我至今还没彻底通关《只狼》，而是停留在了源之宫，甚至还没有找樱龙“拜泪”，更别说剑圣苇名一心了。这主要是我个人很不擅长源之宫这种低矮却错综复杂，可能还有很多水的地图，打平家宅邸以及魂3的法兰要塞都让我花了很长时间。</p>
<p>不主要说义父，则是因为他的设计简直是为了恶心玩家。</p>
<p>首先出手极狠，完美弹刀也要涨可观的架势条。打起来让人畏手畏脚，莽也不是守也不是，比起一般的敌人找到打铁节奏就能有惊无险地通过，面对义父就算是“太鼓达人”不时也要退避三舍恢复元气。</p>
<p>第二是禁药。虽然触发范围不算大，奈何义父总是在拼刀正酣之际贴脸来上一下，即使是较为熟练的玩家也不免中招。一旦中了禁药，极长的持续时间会相应地给玩家造成极大的心理压力，甚至此时义父的进攻还会变得更为积极，在狂风暴雨的攻势下玩家的操作很容易出现误差，就此落命。</p>
<p>第三是撒毒。不大的天守阁场地里有时甚至能散布四片毒区，占去约1/3的场地，大大缩小玩家的生存空间，这下不只是攻与守的抉择，连位移都要慎重考量了。</p>
<p>第四是烟雾弹。烟雾弹的存在也是为了打断节奏，在跳出烟雾重新定位的时候，义父的架势条已经回落了一大截，前面几十秒的苦心拼刀可能就付诸东流。</p>
<p>且不论什么正义的鞭炮，不得不说，巨型忍者枭这个BOSS确实诠释了“忍者”的身份，道具花样百出，招招阴险毒辣。但这些设计堆叠起来——它实在是太令人痛苦了。</p>
<p>而苇名弦一郎，作为《只狼》前期最为重要的BOSS，与他堂堂正正的对决可以说是整部游戏的“期中测验”，值得用来分析。</p>
<h1>与弦一郎对决之前</h1>
<p>和弦一郎的战斗在《只狼》中出现了三次，一次是在游戏刚开始不久时，基本上属于“剧情杀”；第二次是作为前期转入中期的BOSS；第三次是作为游戏最终决战的引子。“起承转合”之中，弦一郎就占了起、转、合三点，不得不说是《只狼》里形象非常饱满、令人印象深刻，也极为重要的BOSS。</p>
<p>游戏进入主线时玩家来到破旧寺院，遥望远方见到的最显眼的目标就是苇名城天守阁，而玩家的第一个长期目标亦是登上天守阁，向弦一郎复仇。在去往天守阁的旅途中，玩家逐步掌握《只狼》的游戏机制，包括弹反、架势、“危”攻击的处理、义手忍具，乃至于在苇名流道场知道了“雷电奉还”。而抵达天守阁顶端时，与弦一郎的对决将前面的一切汇聚起来，是考验玩家对游戏机制理解的一次“期中考试”。</p>
<h1>弦一郎</h1>
<p>《只狼》中面对敌人的攻击，处理方式除了一般的动作游戏中所具有的打断、闪避、格挡、弹反之外，还添加了识破、踩头、忍具等机制，并且具有相比以前的“魂”系列更短的反馈时间。机制宽度上的增加与反馈时间的缩短，很好的弥补了因没有复杂的装备系统在深度上带来的不足。在这样的游戏机制下，最能考验玩家对弹反的掌握程度的，也令我印象尤为深刻的，是弦一郎的标志性技能“飞渡浮舟”：先是常规的两刀，略停顿后接两次上挑，立刻跃起极快地乱砍四下，最后在较长的停顿后以转身强力上挑收尾。这一套下来总共9刀，时长仅4秒左右，处理得当的话可以造成约1/4的架势槽上涨，而处理不当玩家就会当场落命，可以说是攻略中的一个难点。虽然这里说起来很轻松，但实际上这一套连招往往出现在激烈的、包含大量变招的拼刀之中，光是记住弦一郎总共出刀几次都不是件易事。</p>
<p>另一个值得注意的是弦一郎的跳劈，劈砍结束后会产生小范围的烟尘，让玩家无法看清对方的动作。此时弦一郎会接突刺或者横扫的“危”攻击，玩家需要根据烟尘中一闪而过的刀光来判断到底是哪一种，是应该起跳，还是应该“识破”。</p>
<p>完美弹反飞渡浮舟的严苛判定和用烟尘营造的障眼法，考验的是玩家的反应力、观察力和对时机的掌控力。而为了达到用这些攻击手段考验玩家能力的目的，弦一郎的BOSS战也经过了一番设计。一方面是在战斗场地的设置上。前面玩家打过鬼庭形部雅孝的战场、蝴蝶夫人的佛堂、乃至“居合哥”佐濑甚助的道场，而天守阁的空间相较它们更小，也没有设置任何掩体。这无疑是让玩家没有盘旋的余地，不鼓励像《黑暗之魂》里一样摸几刀就远远躲开，把BOSS战玩成实质上的“回合制游戏”，而是要正面迎战。另一方面弦一郎自身也有很多远程攻击和拉近距离的技能，比如空中射箭四连、射箭后翻滚近身以及跳劈，几乎是不让玩家有喘息机会的。这些设计，完全是在引导玩家和弦一郎贴身近战，并且不得不处理那些麻烦的技能，这就是弦一郎前两个阶段的主旋律。</p>
<p>当玩家好不容易磨掉两条血，可能已经“弹尽粮绝”的时候，弦一郎却觉醒意外的力量，进入隐藏的第三阶段，成为“巴流 苇名弦一郎”。第三阶段很有意思，场景的环境由细雪和风骤变成快雪惊雷，这正是“巴之雷”力量的反映，立刻就让玩家回想起在苇名流道场所见的“雷电奉还”卷轴，提示了正确的应对措施。而真正施展出华丽的雷电奉还之后，产生的“打雷”麻痹效果以及极大的架势槽上涨，堪称是这场战斗中最令人爽快的一刻，使得第三阶段没有看上去的那么难，也构成了良好难度曲线的最后一环。良好的难度曲线，即是难度逐渐上升到顶峰，而后又逐渐降低的。</p>
<h1>纯粹</h1>
<p>其实《只狼》是一部过于纯粹的游戏，以至于我不知道该怎么光就一个BOSS的设计进行进一步分析。像那篇由国产游戏策划所写的著名差评里所表达的那样，这个游戏几乎只剩下了“节奏大师音乐游戏”……但这并不是《只狼》的缺点，反而可以说是一种“返璞归真”。作为动作游戏，它既不是《荣耀战魂》那样的过于硬核，也不是《鬼泣》那样的炫瞎狗眼：它纯粹、朴实、“大巧不工”，强化少量核心机制的地位。而能够做到这个的游戏，总是不会差的。</p>
]]></content>
      <tags>
        <tag>游戏</tag>
        <tag>游戏学</tag>
      </tags>
  </entry>
  <entry>
    <title>C#杂记之叁：LINQ</title>
    <url>/2020/03/27/C-%E6%9D%82%E8%AE%B0%E4%B9%8B%E5%8F%81/</url>
    <content><![CDATA[<p>准备完了开题答辩，弄完了笔试，又咸鱼了数天、玩了数天《动物森友会》，一下子离上一篇C#杂记过了三个星期。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99568:/CPuc8SVgWGXTkEA.jpg?authkey=AIbyrqnS5z58phc" alt="朔月"></p>
<p>所以接下来要填的坑是LINQ和异步。弄完了这个，C#最大的几块拼图才得以完整，大抵能够叫是入了门。</p>
<h1>查询表达式</h1>
<p>所谓的LINQ，是语言集成查询<strong>L</strong>anguage <strong>IN</strong>tegrated <strong>Q</strong>uery的缩写。通过引用命名空间<code>System.Linq</code>，可以用可读性极强的、类似SQL查询语句形式的代码对一些数据结构，甚至直接对数据库进行便捷的操作，如查询、排序、分组等，而不必编写大量逻辑复杂的循环代码。<!--尤其是在与异步流式处理相结合时，可以优雅地将C#的性能发挥到极致。(存疑)-->LINQ的操作十分高深，这里我仅学习一些基础、常用的LINQ功能。</p>
<p>以下是一个典型的LINQ查询示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//数据源</span></span><br><span class="line">    <span class="built_in">string</span>[] name = &#123;<span class="string">&quot;Alonso&quot;</span>, <span class="string">&quot;Zheng&quot;</span>, <span class="string">&quot;Smith&quot;</span>, <span class="string">&quot;Jones&quot;</span>, <span class="string">&quot;Smythe&quot;</span>, <span class="string">&quot;Small&quot;</span>, <span class="string">&quot;Ruiz&quot;</span>, <span class="string">&quot;Hsieh&quot;</span>, <span class="string">&quot;Jorgenson&quot;</span>, <span class="string">&quot;Ilyich&quot;</span>, <span class="string">&quot;Singh&quot;</span>, <span class="string">&quot;Samba&quot;</span>, <span class="string">&quot;Fatimah&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询表达式</span></span><br><span class="line">    <span class="keyword">var</span> queryResults = </span><br><span class="line">        <span class="keyword">from</span> n <span class="keyword">in</span> names</span><br><span class="line">        <span class="keyword">where</span> n.StartWith(<span class="string">&quot;S&quot;</span>)</span><br><span class="line">        <span class="keyword">select</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//迭代查询结果</span></span><br><span class="line">    WriteLine(<span class="string">&quot;Name beginning with S:&quot;</span>);</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="keyword">var</span> item <span class="keyword">in</span> queryResults)&#123;</span><br><span class="line">        WriteLine(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Write(<span class="string">&quot;Program finished. Press Enter/Return to continue:&quot;</span>);</span><br><span class="line">    ReadLine();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>这段代码查询字符串数组<code>name</code>中以<code>S</code>开头的元素，收入<code>queryResults</code>中，并将它们输出。其中类似SQL语句，包含“from…in…where…select”的部分被称为“查询表达式”。</p>
<p><code>from...in...</code>子句指定了要查询的数据，这里例子中是数组<code>names</code>中的每一个元素<code>n</code>。数据是指数据源中的元素，而LINQ支持的数据源必须支持<code>IEnumerable&lt;T&gt;</code>接口，这是C#中所有的数据、集合都支持的。</p>
<p><code>where</code>子句不是必需的，它用表达式（<strong>也包括Lambda表达式</strong>）作为查询条件，针对每个<code>n</code>，查询条件能返回一个bool值，以此限定查询结果的范围。</p>
<p><code>select</code>子句指定查询结果集中包含怎样的元素。对于这个例子，<code>select</code>子句是其最简单的形式，即直接包含元素<code>n</code>本身。更复杂的情况，比如可以用<code>n.Length</code>来采集字符串的长度。</p>
<p>采集到的查询结果与数据源一样是实现了<code>IEnumerable&lt;T&gt;</code>的集合，用<code>foreach</code>语句就可以进行迭代。当然，也可以用<code>IEnumerable&lt;T&gt;</code>接口的<code>ToList&lt;T&gt;</code>方法将其创建成列表再做进一步处理。</p>
<p>实际上，直到访问查询结果之前，LINQ查询都并没有真的进行。查询结果变量只是保存了“执行查询的计划”，这被叫做查询的“延迟执行”。</p>
<p>除了上述的构造查询表达式之外，还可以用LINQ支持的一系列扩展方法实现类似的功能。比如在<a href="https://hakurei.red/2020/02/27/C-%E6%9D%82%E8%AE%B0%E4%B9%8B%E5%A3%B9/">C#杂记之壹：委托与事件</a>里我曾写到的，当引用<code>System.Linq</code>命名空间后，<code>IEnumerable&lt;T&gt;</code>接口中就会多出一些扩展方法，比如其中的<code>Where()</code>方法，它接受一个<code>Func&lt;TSource, bool&gt;</code>委托作为参数，用于筛选数据源中的元素，类似于查询表达式中的查询条件。这行代码里，用到两个Lambda表达式作为委托：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> queryResults = numList.Where(i =&gt; i &lt; <span class="number">5</span>).Select(i =&gt; i * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的方法语法等同于以下的查询表达式：</span></span><br><span class="line"><span class="keyword">var</span> queryResults = </span><br><span class="line">    <span class="keyword">from</span> i <span class="keyword">in</span> numList</span><br><span class="line">    <span class="keyword">where</span> i &lt; <span class="number">5</span></span><br><span class="line">    <span class="keyword">select</span> i * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用了几次LINQ之后，我发现用扩展方法写反而更常见，甚至也更方便。</p>
</blockquote>
<h1>排序</h1>
<p>在查询表达式中使用<code>orderby</code>子句，可以对查询结果进行排序。该子句默认按照排序依据升序，如果在子句末尾使用<code>descending</code>关键字就可改为降序。下面的例子里，<code>orderby</code>子句依据字符串元素的最后一个字符，对查询结果进行降序排序：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> queryResults = </span><br><span class="line">    <span class="keyword">from</span> n <span class="keyword">in</span> names</span><br><span class="line">    <span class="keyword">where</span> n.StartWith(<span class="string">&quot;S&quot;</span>)</span><br><span class="line">    <span class="keyword">orderby</span> n.Substring(n.length<span class="number">-1</span>) <span class="keyword">descending</span></span><br><span class="line">    <span class="keyword">select</span> n ;</span><br></pre></td></tr></table></figure>
<p>至于多级排序，形式也十分简单：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三级排序，最后是构造匿名类型，迭代访问时用var即可</span></span><br><span class="line"><span class="keyword">var</span> queryResults = </span><br><span class="line">    <span class="keyword">from</span> c <span class="keyword">in</span> cunstomers</span><br><span class="line">    <span class="keyword">orderby</span> c.Region, c.Country <span class="keyword">descending</span>, c.City</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span> &#123;c.ID, c.Region, c.Country, c.City&#125;;</span><br></pre></td></tr></table></figure>
<h1>聚合</h1>
<p>有时我们并不关注每一条查询结果的细节，所要的只是关于查询结果的一个统计值，这就是所谓的聚合运算。既然学过SQL，这几个基本聚合运算符也是“老朋友”了：</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Count()</td>
<td style="text-align:left">结果的个数</td>
</tr>
<tr>
<td style="text-align:left">Min()</td>
<td style="text-align:left">结果中的最小值</td>
</tr>
<tr>
<td style="text-align:left">Max()</td>
<td style="text-align:left">结果中的最大值</td>
</tr>
<tr>
<td style="text-align:left">Average()</td>
<td style="text-align:left">数字结果的平均值</td>
</tr>
<tr>
<td style="text-align:left">Sum()</td>
<td style="text-align:left">数字结果的总和</td>
</tr>
<tr>
<td style="text-align:left">Distinct()</td>
<td style="text-align:left">结果去重（其实不是聚合）</td>
</tr>
</tbody>
</table>
<p><strong>不过，LINQ与SQL仍有所不同，聚合运算符不是像SQL里一样写在select子句里，而是结果集所支持的方法。</strong></p>
<p>SQL的形式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(column_name) <span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure>
<p>LINQ的形式，聚合运算时可以可选地传入委托作为元素的转换函数，然后对转换后的结果进行聚合：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">WriteLine(queryReusults.Max(i =&gt; i * <span class="number">5</span> + <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<h1>分组查询</h1>
<p>LINQ的分组查询类似于SQL的<code>GROUP BY</code>，配合聚合函数使用得到分组聚合值，用<code>group...by...into...</code>子句实现。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> queryResults = </span><br><span class="line">    <span class="keyword">from</span> c <span class="keyword">in</span> customers</span><br><span class="line">    <span class="keyword">group</span> c <span class="keyword">by</span> c.Region <span class="keyword">into</span> cg</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span> &#123; TotalSales = cg.Sum(c =&gt; c.sales), Region = cg.Key &#125;;</span><br></pre></td></tr></table></figure>
<p>上面这个例子，首先用group by into对数据源<code>customers</code>进行分组，得到新的结果集<code>cg</code>。通过分组查询得到的这个临时结果集实现了<code>IGrouping</code>接口，它包含<code>Key</code>属性，表示分组所依据的值，也就是<code>by</code>后面所接的表达式（本例中是表示客户地区的<code>c.Region</code>）之值。</p>
<p>最后的<code>select</code>子句依然是构造匿名类型，这在需要投影多个属性时是很有用的。</p>
<h1>join查询</h1>
<p>和SQL中一样，join查询是用在需要用另外的数据源作为参考来进行查询，或者需要从多个数据源中汇集信息时的。SQL中实现多表查询至少有两种方法，一是使用JOIN，二是引用多个表然后把连接条件写在where子句中。但由于LINQ的<code>from...in...</code>子句只能引用一个数据源，所以第二种方案是行不通的，需要使用<code>join...in...on...</code>子句来实现。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> queryResults = </span><br><span class="line">    <span class="keyword">from</span> c <span class="keyword">in</span> customers</span><br><span class="line">    <span class="keyword">join</span> o <span class="keyword">in</span> orders <span class="keyword">on</span> c.ID <span class="keyword">equals</span> o.ID</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">new</span> &#123; </span><br><span class="line">        c.ID, </span><br><span class="line">        c.City, </span><br><span class="line">        SalesBefore = c.Sales, </span><br><span class="line">        NewOrder = o.Amount, </span><br><span class="line">        SalesAfter = c.Sales + o.Amount</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>上面的例子是一个简单的内连接（Inner Join），其实<a href="https://www.c-sharpcorner.com/UploadFile/ff2f08/sql-join-in-linq-linq-to-entity-linq-to-sql/">LINQ也能实现外连接</a>，只是不算那么优雅（而且好像也没多大卯月）。</p>
<h1>交并差</h1>
<p>这是LINQ为IEnumerable带来的非常贴心的功能，仅三个简单的扩展方法。</p>
<p>取并集：Union()</p>
<p>取交集：Intersect()</p>
<p>取差集：Except()</p>
<p>不过，由于数学上的“集合”是无重复的，上面的Union()方法返回的也是去重的结果。如果想保留重复的结果，可以使用Concat()。</p>
<p>这几个方法返回的类型都是IEnumerable，需要在调用之后再使用ToList()或者ToArray()之类的方法。</p>
<p>你甚至可以用这玩意一行代码秒掉<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">LeetCode 349 两个数组的交集</a>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">Intersection</span>(<span class="params"><span class="built_in">int</span>[] nums1, <span class="built_in">int</span>[] nums2</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums1.Intersect(nums2).ToArray();        <span class="comment">//LINQ完事，别想算法了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>总结</h1>
<p>基础形式：<strong>from…in…where…select…</strong></p>
<p>其中：</p>
<p>from…in…指定数据源是什么；</p>
<p>可选的where指定按照什么条件筛选；</p>
<p>select指定要获取怎样的结果；</p>
<p>排序：orderby… (descending)</p>
<p>聚合：Count(), Max(), Min(), Average(), Sum(), Distinct()</p>
<p>分组：group…by…into…</p>
<p>join：join…in…on…</p>
<blockquote>
<p>明天真该async await了！（动森真好玩）</p>
</blockquote>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99569:/OCPcmBo3hr4zkt5.jpg?authkey=AIbyrqnS5z58phc" alt="博物馆庆典"></p>
]]></content>
      <tags>
        <tag>C Sharp</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>200404：清明追思</title>
    <url>/2020/04/04/200404/</url>
    <content><![CDATA[<p>到了清明节，很奇怪的，今年并没有下雨。印象中每年的清明正应那句“清明时节雨纷纷”，这几天就该是细雨连绵，气温恰好舒适得让人头脑清晰。气象数据统计上也反映了这一点。杏花村所在的安徽池州，历年来清明前后的降雨概率高达85%。湖北离得不远，这印象是有基础的。</p>
<p>下不下雨倒是无关紧要，今天有其更大的意义。</p>
<blockquote>
<p>新华社北京4月3日电 为表达全国各族人民对抗击新冠肺炎疫情斗争牺牲烈士和逝世同胞的深切哀悼，国务院今天发布公告，决定2020年4月4日举行全国性哀悼活动。在此期间，全国和驻外使领馆下半旗志哀，全国停止公共娱乐活动。4月4日10时起，全国人民默哀3分钟，汽车、火车、舰船鸣笛，防空警报鸣响。</p>
</blockquote>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99570:/LS6WIcNkAsH4VeJ.jpg?authkey=AIbyrqnS5z58phc" alt="清明追思"></p>
<span id="more"></span>
<p>“躲进小楼成一统”的这两个多月，我的情绪依然常常通过社交平台与外界牵连着，随着疫情通报和人间冷暖而波动。从武汉F4的操作秀到“全境封锁”再到李文亮医生的逝世，整个中国天翻地覆。但那之后似乎一切都终于走上正轨，那两天很是发了一番牢骚之后，我也就不再那么关注了。记得中途的某一天，我爸问我：你们计算机专业可以为抗击疫情做什么呢？是啊，我做得了什么呢？</p>
<p>我做不了什么。我不是阿里P7，也没发过顶会Paper，与医学的关联也仅仅是去年帮同济医学院搬过几次砖——贡献大的总只可能是攀登到顶峰上的数人。我能做到的最好的事，也就是“配合”：老实一点，不要给别人添麻烦。</p>
<p>所以九点五十九分，我放下“钓到彩蛋了！用来做什么好呢……？”的手柄，走上阳台等待警笛。十点整，汽车的汽笛随着防空警报一起响起。我沉默着望向窗外，世界静止在此刻，秒针转得飞快。后来令我想痛骂自己的是，默哀时我没有多么悲伤——相对于2009年5月12日的自己来说。</p>
<p>那是中国的第一个“防灾减灾日”。届时我小学尚未毕业，没有如今学来的阴阳怪气的“理客中”，看什么都很朴素，像是如今不少人追寻的“痛则大哭，喜则大笑”的境界。教室里我低着头，却又将眼睛略微睁开一点，模糊的视野里只能看到红漆斑驳的木制旧书桌。手中攥着稍微漏墨的英雄钢笔，2008年的种种往事涌上心头：联众游戏大厅，鲜虾鱼板面，纸飞机，绿蓝带，滑板车……手机中未能送达的短信，独臂少年喝到的冰可乐，粉笔写下的“多难兴邦”。</p>
<p>光荣与受难并存，我写在2008的末尾。</p>
<blockquote>
<p><strong>别了，2008</strong></p>
<p>在这2008年的最后一天的深夜，我正坐在电脑前向即将过去的2008年，以我的文字告别。2008年，这真是一个难以告别的年份啊。</p>
<p>在这2008年，我们经历了太多，太多…在开年时,我们就受到了重重一击:中国受到了百年难遇的大雪灾,可在雪灾之中,却有众多好心人来帮助那些受灾的群众，使这原本寒冷的雪灾变得温暖起来。</p>
<p>而在接下来的5月里，中国历史上最大的地震：5.12汶川大地震降临了。在天地动摇中，我们却看到了温暖的一幕：消防队员们尽力地援救受难的人们。</p>
<p>接着就好了，奥运会开幕了，我们的运动员为我国夺得了100枚金牌，这是我们中国人的骄傲。</p>
<p>重大的事件发生了：三鹿“毒奶粉”事件。我国竟然多家乳业公司的奶粉都含有三聚氰胺，里面竟然还有伊利和蒙牛、光明，这三家公司一直都是人们信任的品牌，却被查出了有三聚氰胺，令人为之汗颜。</p>
<p>接着，是神舟七号飞天。神舟七号的飞行员首次出舱活动，这是中国人的光荣。</p>
<p>然后，就是现在，我在电脑前，向这难舍的2008告别。</p>
<p>别了，2008…</p>
</blockquote>
<p>在这样的日子里，我出了一趟门。</p>
<p>出门是在昨天。封城以来，除了偶有几次的取快递，我基本没有离开过这个“Cell”。种种迹象表明，我在自我封闭——更简单地说，就是自闭。到了近日，我也不知道连“绿码”都不用扫了，戴上口罩就可以在这个曾经最严重的疫区之一随意穿行。</p>
<p>这样下来，我持续地沉溺在递归里，乃至每周都要逛三次Google Earth，每天都要有三回从窗台飞身而出的欲望。但当今天得知现在甚至还能乘上火车自由地前往全国各地时，我心里的世界地图又一瞬间缩小到了这一方居民楼。虽然不准确，但就像柏拉图的地穴寓言，从地穴里出来的囚犯想要直视太阳还需要好几个阶段的过渡。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99573:/y4Kbm9ZWDV8Fxd2.jpg?authkey=AIbyrqnS5z58phc" alt="壕塘西巷"></p>
<p>熟悉的街巷虽然还稍显冷清，但还是旧时风味。灰头土脸的老建筑和郁郁葱葱的行道树屹立在大地上，骄傲地宣示着这座十八线小城绝不枯竭的生命力。</p>
<blockquote>
<p>庚子清明。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>C#杂记之肆：异步</title>
    <url>/2020/04/08/C-%E6%9D%82%E8%AE%B0%E4%B9%8B%E8%82%86/</url>
    <content><![CDATA[<div class="note warning"><p><strong>前方高能！</strong><br>
这篇笔记断断续续花了近10天，思路、结构较为混沌，如果没有充分做好心理准备，建议立刻关闭窗口。<br>
（其实就是我写完实在不愿审阅）</p>
</div>
<p>首先说明，异步是<strong>极为高深</strong>的高级编程技术，这篇文章只是才疏学浅的我阅读文档之后的一些思考与理解，可能有极多描述不准确乃至完全错误之处，还望批评指导。顺便吐槽，C#文档翻译得实在是太烂了，很多地方一看就是机翻的，却没有机翻警告。很多地方百思不得其解的词，切换到英语就发现其实很简单，翻译的用词完全错误，难受啊！</p>
<h1>何为异步</h1>
<p>与异步相对的是“同步”，代表着一句代码的执行结束是其后一句代码的执行开始，整个流程是按照固定的顺序进行的，这是一般程序的逻辑。然而，某些语句可能需要花较长时间才能得到结果——比如网络通信和文件读写——这些语句的执行并不怎么占用CPU，但会阻塞整个线程，后续的语句需要等待这些语句执行完成，造成大量的浪费。特别是如果网络环境很不好、读取的文件好几个G，那可是尤其要命，可能整个程序都会出现肉眼可见的卡顿甚至崩溃。</p>
<p>为了解决这种飞快的CPU与龟爬的IO之间的不平衡，传统的方案是单独开个线程让它去执行耗时的操作，让主线程继续运行与耗时操作的结果无关的代码。但是线程操作很麻烦、开销很高，线程数量也有限，不是能随便使用的，所以依然不是个完美的方法。</p>
<p>异步就是为了解决这个问题而存在的。当代码需要执行一个耗时的操作时，它只发出指令，并不等待结果，然后就去执行其他代码了。一段时间后，当耗时操作返回结果时，再通知CPU进行处理。</p>
<span id="more"></span>
<h1>怎么使用</h1>
<p>从C# 5开始，编写异步程序变得比较容易。</p>
<p>C#的异步编程模型主要通过两个关键字来使用：<code>async</code>和<code>await</code>。</p>
<h2 id="用早餐毁掉美好的一天"><a class="header-anchor" href="#用早餐毁掉美好的一天">¶</a>用早餐毁掉美好的一天</h2>
<p>先来一段同步的憨憨代码，这描述了一个“做早餐”的流程：</p>
<ol>
<li>倒一杯咖啡。</li>
<li>加热平底锅，然后煎两个鸡蛋。</li>
<li>煎三片培根。</li>
<li>烤两片面包。</li>
<li>在烤面包上加黄油和果酱。</li>
<li>倒一杯橙汁。</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Coffee cup = PourCoffee();          <span class="comment">//倒咖啡</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;coffee is ready&quot;</span>);</span><br><span class="line">    Egg eggs = FryEggs(<span class="number">2</span>);              <span class="comment">//煎蛋</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;eggs are ready&quot;</span>);</span><br><span class="line">    Bacon bacon = FryBacon(<span class="number">3</span>);          <span class="comment">//煎培根</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;bacon is ready&quot;</span>);</span><br><span class="line">    Toast toast = ToastBread(<span class="number">2</span>);        <span class="comment">//烤面包</span></span><br><span class="line">    ApplyButter(toast);                 <span class="comment">//涂黄油</span></span><br><span class="line">    ApplyJam(toast);                    <span class="comment">//涂果酱</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;toast is ready&quot;</span>);</span><br><span class="line">    Juice oj = PourOJ();                <span class="comment">//倒橙汁</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;oj is ready&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Breakfast is ready!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线性的逻辑很简单，但有大问题。煎蛋、煎培根和烤面包都要花很长时间，其实完全可以在做煎蛋和培根的同时，让面包自己在面包机里烤。不然还没等面包烤完，别的东西早凉透了，吃了可能还会引起肠胃不适。煎蛋和煎培根甚至也没必要一前一后——谁家还没有两个锅呢？或者找个大点的锅来一起煎也行啊。</p>
<h2 id="异步做早餐"><a class="header-anchor" href="#异步做早餐">¶</a>异步做早餐</h2>
<p>来看看一个近乎完美的“做早餐解决方案”是怎样的。下面是C#文档里的示范异步代码，我擅自添加了些方便理解的沙雕注释：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Coffee cup = PourCoffee();          <span class="comment">//倒杯咖啡</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;coffee is ready&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> eggsTask = FryEggsAsync(<span class="number">2</span>);     <span class="comment">//得煎俩鸡蛋，开整！</span></span><br><span class="line">    <span class="keyword">var</span> baconTask = FryBaconAsync(<span class="number">3</span>);   <span class="comment">//得煎仨培根，开整！</span></span><br><span class="line">    <span class="keyword">var</span> toastTask = MakeToastWithButterAndJamAsync(<span class="number">2</span>);  <span class="comment">//得搞两片涂黄油和果酱的面包，开整！</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> allTasks = <span class="keyword">new</span> List&lt;Task&gt;&#123;eggsTask, baconTask, toastTask&#125;;  <span class="comment">//列个任务清单吧</span></span><br><span class="line">    <span class="keyword">while</span> (allTasks.Any())  <span class="comment">//看来清单里还有任务没搞完</span></span><br><span class="line">    &#123;</span><br><span class="line">        Task finished = <span class="keyword">await</span> Task.WhenAny(allTasks);   <span class="comment">//下一个完成的任务是啥？</span></span><br><span class="line">        <span class="keyword">if</span> (finished == eggsTask)   <span class="comment">//噢，是鸡蛋煎好了！</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;eggs are ready&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (finished == baconTask)     <span class="comment">//噢，是培根煎好了！</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;bacon is ready&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (finished == toastTask)     <span class="comment">//噢，是面包做完了！</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;toast is ready&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        allTasks.Remove(finished);      <span class="comment">//行，把完成的任务从清单里划了</span></span><br><span class="line">    &#125;</span><br><span class="line">    Juice oj = PourOJ();    <span class="comment">//最后再来杯橙汁，完事</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;oj is ready&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Breakfast is ready!&quot;</span>);   <span class="comment">//爽到</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">async</span> Task&lt;Toast&gt; <span class="title">MakeToastWithButterAndJamAsync</span>(<span class="params"><span class="built_in">int</span> number</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> toast = <span class="keyword">await</span> ToastBreadAsync(number);      <span class="comment">//要处理面包得先等面包烤好</span></span><br><span class="line">        ApplyButter(toast);     <span class="comment">//涂点黄油</span></span><br><span class="line">        ApplyJam(toast);        <span class="comment">//涂点果酱</span></span><br><span class="line">        <span class="keyword">return</span> toast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>粗略一看，握草，感觉魔改成异步之后复杂了好多。其实不然，我慢慢来分析。</p>
<h3 id="定义异步方法"><a class="header-anchor" href="#定义异步方法">¶</a>定义异步方法</h3>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> eggsTask = FryEggsAsync(<span class="number">2</span>);     <span class="comment">//得煎俩鸡蛋，开整！</span></span><br><span class="line"><span class="keyword">var</span> baconTask = FryBaconAsync(<span class="number">3</span>);   <span class="comment">//得煎仨培根，开整！</span></span><br><span class="line"><span class="keyword">var</span> toastTask = MakeToastWithButterAndJamAsync(<span class="number">2</span>);  <span class="comment">//得搞两片涂黄油和果酱的面包，开整！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> allTasks = <span class="keyword">new</span> List&lt;Task&gt;&#123;eggsTask, baconTask, toastTask&#125;;  <span class="comment">//列个任务清单吧</span></span><br></pre></td></tr></table></figure>
<p>可以注意到，这一段使用的几个方法，其名称都在后面加了个“Async”，这是异步方法的命名规范。调用三个异步方法，就是设置了三个任务（Task）。那谁谁，照这个任务去执行吧！我要接着跑后面的代码了。</p>
<p>那么，怎么定义一个异步方法呢？来看上面示例中的这个方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> Task&lt;Toast&gt; <span class="title">MakeToastWithButterAndJamAsync</span>(<span class="params"><span class="built_in">int</span> number</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> toast = <span class="keyword">await</span> ToastBreadAsync(number);      <span class="comment">//要处理面包得先等面包烤好</span></span><br><span class="line">    ApplyButter(toast);     <span class="comment">//涂点黄油</span></span><br><span class="line">    ApplyJam(toast);        <span class="comment">//涂点果酱</span></span><br><span class="line">    <span class="keyword">return</span> toast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，方法定义的前面有<code>async</code>修饰符，这直接说明了此方法是异步（<strong>async</strong>hronous）的。</p>
<p>异步方法返回的是<code>Task&lt;TResult&gt;</code>类型，代表着这个任务（Task）的结果是<code>TResult</code>所代表的类型。比如一个返回类型为<code>Toast</code>的同步方法，其异步版本的返回类型就应该是<code>Task&lt;Toast&gt;</code>，代表着一个“烤面包（Toast）”的任务（Task）。</p>
<p><strong><code>async</code>异步方法的存在，要依靠包含<code>await</code>运算符的表达式或语句。反过来说，异步方法里必须得有<code>await</code>的存在。</strong> 上面的代码里，<code>Main</code>方法本身也是被<code>async</code>修饰的，就是因为Main方法里也用到了<code>await</code>语句。</p>
<h3 id="设置前置条件"><a class="header-anchor" href="#设置前置条件">¶</a>设置前置条件</h3>
<p><code>async</code>是用来定义异步方法的，那<code>await</code>是干什么的呢？按照字面意思来理解就好，“等待”。异步方法运行到这里就开始等待，直到<code>await</code>的操作数所表示的异步操作（一个<code>Task&lt;TResult&gt;</code>）执行完毕。<strong>一旦异步操作完成，<code>await</code>运算符就从<code>Task&lt;TResult&gt;</code>的任务里，获取任务的最终结果，以<code>TResult</code>类型返回，然后再继续运行后续代码。</strong> 这说明<code>await</code>所等待的任务的结果是后续操作的前置条件。上面这个异步方法第一句就在<code>await</code>，这是因为后面抹黄油和果酱的流程都必须建立在“烤完面包”的前置条件上。</p>
<p>然而，我们希望优化的耗时操作往往本身不是异步的。<code>await</code>只能接异步操作，怎么和非异步的耗时操作结合呢？比如说有这样一个“根正苗红”的同步函数：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">int</span> bar</span>)</span>&#123;</span><br><span class="line">    Wtf();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要让它的执行完成作为前置条件，就得把它改造成一个返回<code>Task&lt;string&gt;</code>的函数。但是如果原函数是不允许修改的呢？依然有办法，只要用<code>Task.Run(() =&gt; Foo(bar))</code>来调用就好了。</p>
<p><code>Task.Run()</code>可以把以下四种委托包装成任务，其中常用的是前两种：</p>
<ol>
<li><code>Action</code></li>
<li><code>Func&lt;TResult&gt;</code></li>
<li><code>Func&lt;Task&gt;</code></li>
<li><code>Func&lt;Task&lt;TResult&gt;&gt;</code></li>
</ol>
<p>由于Lambda表达式也是委托，完全可以构造一个符合上述种类的Lambda表达式。<code>() =&gt; Foo(bar)</code>没有参数，返回类型为<code>string</code>，是一个受到支持的<code>Func&lt;string&gt;</code>委托。因此在被<code>Task.Run()</code>包装之后，它就能成为一个<code>Task&lt;string&gt;</code>，作为异步过程中的前置条件。</p>
<h3 id="使用连接符"><a class="header-anchor" href="#使用连接符">¶</a>使用连接符</h3>
<p>再来看中间的这一段。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (allTasks.Any())</span><br><span class="line">&#123;</span><br><span class="line">    Task finished = <span class="keyword">await</span> Task.WhenAny(allTasks);</span><br><span class="line">    <span class="keyword">if</span> (finished == eggsTask)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;eggs are ready&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (finished == baconTask)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;bacon is ready&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (finished == toastTask)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;toast is ready&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    allTasks.Remove(finished);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>allTasks.Any()</code>使用<code>List&lt;T&gt;</code>的<code>Any()</code>方法检查列表里是否还有剩余的元素，即当还有未完成的任务时，令程序一直在此循环，这实际上类似于一个消息循环机制。</p>
<p><code>Task.WhenAny(allTasks)</code>有点儿特殊，它是一个<code>Task&lt;Task&gt;</code>，即“结果是任务”的任务——在<code>allTasks</code>里的某一个任务完成时，它把这个刚刚完成的任务作为自己的结果。这样，<code>await</code>运算符就提取出了那个刚刚完成的任务，将它赋给<code>finished</code>，接下来就可以作出相应的反应了。别忘了在任务处理完之后，把这个完成了的任务从任务列表里删去。</p>
<p>另有一个类似的方法是<code>Task.WhenAll()</code>，它所创建的任务在参数所表示的一系列任务都完成时才完成。命名空间<code>System.Threading.Tasks</code>里的这类辅助处理多个任务的方法被称为“连接符”。</p>
<p>以上就是一种基于任务的异步模式（TAP）：把多个任务一齐启动，记录在任务列表里，然后用<code>await</code>、循环和连接符来等待所有任务的完成。对于每个任务本身，如果具有一些前置条件，就依然用<code>await</code>来等待其前置条件的完成。</p>
<h1>扩展：线程池</h1>
<p>至此，虽然我们知道了怎么把同步代码改造成异步的，但其中的原理是什么呢？</p>
<p>异步的关键是定义<code>async</code>异步方法和用<code>await</code>进行必要的流程控制，而这两个关键字都是围绕<code>Task&lt;TResult&gt;</code>展开的。因此要更深入地理解异步，就要了解<code>Task&lt;TResult&gt;</code>的工作机制。</p>
<p>Task工作的基础是线程池，C#中的线程池是命名空间<code>System.Threading</code>中的<code>ThreadPool</code>静态类。关于线程池和多线程又可以事无巨细地写一篇长文，这里先作简要的记录。</p>
<p>每一个进程都可以拥有一个线程池，里面有预先创建好的一大堆空闲线程。当一个任务需要用线程处理的时候，就无需临时单独创建一个线程，可以直接从线程池里找一个空闲的来跑。跑完也不用费劲将线程销毁，它会被线程池回收，等待其它任务来利用。假如要处理的任务太多，导致线程池里所有的线程都在忙碌，线程池可能会创建新线程，也可能让任务等待空闲线程的出现。</p>
<p>线程池也有缺点。由于池里线程的一切工作都是由CLR托管的（这又是一个天坑），虽然用起来是简单了，但你无法对这些线程进行具体的操作，一旦把任务加进队列里也没法取消（不要停下来啊！）。不过都要用上线程池了，那不是一把梭跑就完事了嘛，谁还希望让任务停下来呢？</p>
<p>使用线程池的方法是利用<code>QueueUserWorkItem()</code>方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadPool.QueueUserWorkItem 方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">QueueUserWorkItem</span> (<span class="params">System.Threading.WaitCallback callBack</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">QueueUserWorkItem</span> (<span class="params">System.Threading.WaitCallback callBack, <span class="built_in">object</span> state</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>这个方法把一项工作添加到线程池的工作队列中，一旦线程池有空闲线程，就会从队列里取出工作来执行。</p>
<p>其中，<code>WaitCallback</code>是一个委托，它接收<code>object</code>作为参数，并返回<code>void</code>，类似<code>Action&lt;object&gt;</code>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">System.Runtime.InteropServices.ComVisible(true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">WaitCallback</span>(<span class="params"><span class="built_in">object</span> state</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>注意，由于委托参数的<a href="https://hakurei.red/2020/03/02/C-%E6%9D%82%E8%AE%B0%E4%B9%8B%E8%B4%B0/">逆变性</a>（我靠，居然在这里用上了前面学的逆变），这里仅能使用<code>object</code>或派生程度更低的类型的参数。由于<code>object</code>已经是最终基类，故只能用它。</p>
<p>但<code>object</code>可是啥都没有啊？如果要安排一个带有任务信息的委托作为任务，怎么把信息封在里面？</p>
<p>为了解答这个问题，我们可以先看<code>QueueUserWorkItem</code>的后一个重载。参数除了<code>WaitCallback</code>类型的委托<code>callBack</code>之外，还有一个<code>object state</code>，它就是委托调用时使用的参数。由于协变性，你可以把任何类型视作<code>object</code>，也就可以在调用委托时传入任意类型的参数。而前一个重载的参数列表中没有<code>object state</code>，是给无需在调用时传入参数的委托使用的，类似<code>Action</code>。</p>
<p><strong>如此一来就很明白了，支持添加到线程池工作队列里的工作是这样的函数：返回类型为<code>void</code>，参数列表中有0或1个任意类型的参数。</strong></p>
<h1>未竟之旅</h1>
<p>原本这里应该有更多关于Task和await工作原理的内容，但当我在C#文档的迷宫中走得愈发深入时，我发现我的理解被不断推翻，比如说用async和await实现的异步实际上是单线程的，但它们所围绕的Task又和用线程池实现的多线程密不可分。</p>
<p>我试图理清这一切到底是如何工作的，这时回调函数、消息循环、线程调度、编译原理这几只怪物都跑了出来，甚至将一切都指向了JavaScript，告诉我是时候敬而远之了。</p>
<p>因此，目前这篇笔记是十分没有深度的一篇，它有太多可以写也需要写的内容了。C#我还有更多的东西一知半解，目前在此考据技术细节是不明智的。但过段时间我还会继续刨根究底，现在将非常具有参考价值的一篇StackOverflow问题链接贴在这里：</p>
<p><a href="https://stackoverflow.com/questions/37419572/if-async-await-doesnt-create-any-additional-threads-then-how-does-it-make-appl">If async-await doesn’t create any additional threads, then how does it make applications responsive?</a></p>
<p>以及之前我画的<strong>理解错误</strong>的示意图：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99571:/7TIPufG6oAm2cOd.png?authkey=AIbyrqnS5z58phc" alt="BreakfastAsync.png"></p>
<blockquote>
<p>下一步，应该是回过头去搞清楚集合、列表、数组，还有相关的接口和索引器啥的。</p>
</blockquote>
]]></content>
      <tags>
        <tag>C Sharp</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C#杂记之伍：数组与集合</title>
    <url>/2020/04/15/C-%E6%9D%82%E8%AE%B0%E4%B9%8B%E4%BC%8D%EF%BC%9A%E6%95%B0%E7%BB%84%E4%B8%8E%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>数组可以说是在任何语言中都非常基本的数据结构了。这篇笔记以C#中的数组为引，再延伸到C#的几种集合类(Collections)以及一些相关的基本概念。</p>
<h1>数组 Array</h1>
<h2 id="概述"><a class="header-anchor" href="#概述">¶</a>概述</h2>
<p>数组存储相同种类的元素，其大小固定，且是顺序存储的，即在内存中占据一段连续的地址。</p>
<p>数组作为一种引用类型(其基类是System.Array)，需要用<code>new</code>来创建实例。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化时指定大小</span></span><br><span class="line"><span class="built_in">double</span>[] balance = <span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以直接赋值来初始化</span></span><br><span class="line"><span class="built_in">int</span>[] marks = &#123;<span class="number">99</span>, <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>初始化而尚未赋值的数组，编译器会根据其类型隐式地将所有元素设置为默认值。</p>
<p>数组最大的特点还是能够用下标索引来随机访问其中的元素：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> salary = balance[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是C# 8.0引入的好东西！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//末尾运算符 ^ </span></span><br><span class="line"><span class="comment">//[^n]表示[length-n]，类似Python用负数索引[-n]表示[length-n]</span></span><br><span class="line"><span class="built_in">double</span> salary = balance[^<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//范围运算符 ..</span></span><br><span class="line"><span class="comment">//[a..b]表示从[a]到[b]的范围(但不包含[b]！)，类似Python的切片[a:b]</span></span><br><span class="line"><span class="comment">//省略a代表0，省略b代表^0</span></span><br><span class="line"><span class="built_in">double</span>[] salaries1 = balance[..^<span class="number">3</span>];</span><br><span class="line"><span class="comment">//如果a比b还大，会抛出异常(Python中则是返回空列表)</span></span><br><span class="line"><span class="built_in">double</span>[] salaries2 = balance[<span class="number">3.</span><span class="number">.2</span>];     <span class="comment">//ArgumentOutOfRangeException</span></span><br><span class="line"><span class="comment">//a和b一样大时，返回长度为0的集合</span></span><br><span class="line"><span class="built_in">double</span>[] salaries3 = balance[<span class="number">3.</span><span class="number">.3</span>];</span><br><span class="line">Console.WriteLine(salaries3.Length);   <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>由于实现了<code>IEnumerable</code>接口，数组可以使用<code>foreach...in...</code>的方式进行迭代访问，还可以使用LINQ，这样就无需获取数组长度再用for循环迭代了。关于这个接口及其相关的内容，我在本文稍后的部分记述。</p>
<span id="more"></span>
<h2 id="索引器-Indexer"><a class="header-anchor" href="#索引器-Indexer">¶</a>索引器 Indexer</h2>
<p>索引器（Indexer）可以让各种类、结构、接口实现数组的这种能够用下标索引来访问的功能。</p>
<p>索引器就像一个名为<code>this</code>的属性，可以用访问器进行定义。</p>
<blockquote>
<p>访问器是可在属性上定义的两个方法。其中get方法在读属性时执行；set方法隐含一个传入的<code>value</code>参数，在写属性时执行。一个常见的用途是用公开属性的访问器来对私有属性进行读/写。另外也可以在set访问器里对传入值进行范围检查等操作。</p>
</blockquote>
<p>索引器的一般定义示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">element-type <span class="keyword">this</span>[<span class="built_in">int</span> index]</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// get 访问器</span></span><br><span class="line">   <span class="keyword">get</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 返回 index 指定的值</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// set 访问器</span></span><br><span class="line">   <span class="keyword">set</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 设置 index 指定的值</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较神奇的是，索引器的索引下标并不是只能使用int，还可以用string。同时索引器又像是一个方法，甚至可以重载，这意味着你可以同时定义以int和string作为索引下标的索引器。</p>
<h2 id="多维数组"><a class="header-anchor" href="#多维数组">¶</a>多维数组</h2>
<p>C#的多维数组在定义时，维度之间用逗号隔开。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三维数组</span></span><br><span class="line"><span class="built_in">int</span>[, ,] array3Da = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>] &#123; &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125; &#125;, </span><br><span class="line">                                        &#123; &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;, &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125; &#125; &#125;;</span><br></pre></td></tr></table></figure>
<h2 id="交错数组"><a class="header-anchor" href="#交错数组">¶</a>交错数组</h2>
<p>交错数组是<strong>数组的数组</strong>。当我们说“数组”的时候，说的是一个引用类型。因此交错数组与多维数组的不同之处在于，它本质上是个一维数组，其元素为引用类型，且被初始化为null。</p>
<p>也正因此，交错数组中的元素只需要是规定的数组类型即可，不需要具有一致的长度：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//包含大小不同的三个二维数组元素的一维交错数组：</span></span><br><span class="line"><span class="built_in">int</span>[][,] jaggedArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>][,] </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123; &#123;<span class="number">1</span>,<span class="number">3</span>&#125;, &#123;<span class="number">5</span>,<span class="number">7</span>&#125; &#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123; &#123;<span class="number">0</span>,<span class="number">2</span>&#125; &#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">int</span>[,] &#123; &#123;<span class="number">11</span>,<span class="number">22</span>&#125;, &#123;<span class="number">99</span>,<span class="number">88</span>&#125;, &#123;<span class="number">0</span>,<span class="number">9</span>&#125; &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">System.Console.Write(<span class="string">&quot;&#123;0&#125;&quot;</span>, jaggedArray4[<span class="number">0</span>][<span class="number">1</span>, <span class="number">0</span>]);   <span class="comment">//输出：5</span></span><br></pre></td></tr></table></figure>
<h1>集合 Collections</h1>
<h2 id="概述-v2"><a class="header-anchor" href="#概述-v2">¶</a>概述</h2>
<p>集合类是定义在<code>System.Collection</code>命名空间里的几种类。比起数组，它们实现了几个接口，能更方便用于存储和检索数据。</p>
<p>为了支持无数种类型，非泛型集合把所有的元素都装箱成<code>object</code>类的对象来存储。元素的读写总要涉及到装箱与拆箱，在性能上有一定损失；而且也因为装箱，你可以把任意不同类型的元素装进同一个集合，这是危险的，相当不妙。</p>
<p>因此，在引入对泛型的支持后，更好的选择是使用命名空间<code>System.Collection.Genreric</code>里的泛型集合来存储数据。以下是几种非泛型和泛型集合：</p>
<table>
<thead>
<tr>
<th style="text-align:left">非泛型集合类</th>
<th style="text-align:left">泛型集合类</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">动态数组 ArrayList</td>
<td style="text-align:left">列表 List&lt;T&gt;</td>
<td style="text-align:left">具有动态大小的数组</td>
</tr>
<tr>
<td style="text-align:left">哈希表 Hashtable</td>
<td style="text-align:left">字典 Dictionary&lt;Tkey,Tvalue&gt;</td>
<td style="text-align:left">由键-值对组成的集合</td>
</tr>
<tr>
<td style="text-align:left">排序列表 SortedList</td>
<td style="text-align:left">排序列表 SortedList&lt;Tkey,Tvalue&gt;</td>
<td style="text-align:left">和字典相似但有排序功能</td>
</tr>
<tr>
<td style="text-align:left">队列 Queue</td>
<td style="text-align:left">队列 Queue&lt;T&gt;</td>
<td style="text-align:left">先进先出（FIFO）队列</td>
</tr>
<tr>
<td style="text-align:left">堆栈 Stack</td>
<td style="text-align:left">堆栈Stack&lt;T&gt;</td>
<td style="text-align:left">后进先出（LIFO）队列</td>
</tr>
</tbody>
</table>
<p>而泛型集合中，最常用的是List&lt;T&gt;和Dictionary&lt;Tkey,Tvalue&gt;，其它的集合基本都建立在其基础上。</p>
<h2 id="列表-List-T"><a class="header-anchor" href="#列表-List-T">¶</a>列表 List&lt;T&gt;</h2>
<h3 id="概述-v3"><a class="header-anchor" href="#概述-v3">¶</a>概述</h3>
<p>上面的表格里写到，List&lt;T&gt;是泛型版本的ArrayList，是具有动态大小的<strong>数组</strong>。也就是说，其原理依然是<strong>顺序存储</strong>的数组，具有随机访问快但插入删除较慢的特点。</p>
<p>C#里有没有用双向链表实现的链式存储数据结构呢？也是有的，它就是LinkedList&lt;T&gt;，只不过很少有人会用到，毕竟随机访问速度在大多数场景下更加重要。</p>
<h3 id="创建"><a class="header-anchor" href="#创建">¶</a>创建</h3>
<p>要创建一种类型的列表，依然需要用new：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">List&lt;Animal&gt; animalCollection = <span class="keyword">new</span> List&lt;Animal&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="容量"><a class="header-anchor" href="#容量">¶</a>容量</h3>
<p>List中有两个int属性：Count和Capacity。</p>
<p>Count代表List中现有的元素数量，而Capacity代表List的容量。当Count达到Capacity的值，再试图加入元素时，Capacity就会自动进行调整。下面是在一个List&lt;int&gt;中加入600个元素的结果，其中白色数字代表现有元素数量Count，绿色数字代表List容量Capacity：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99572:/iIOaP5s24YgMCpX.png?authkey=AIbyrqnS5z58phc" alt="动态调整Capacity"></p>
<p>可以看出，加入第一个元素时，Capacity从0被调整到4。之后每次Count要超过Capacity时，Capacity就会翻倍，以容纳更多元素。这个容量调整算法不是固定的，比如对于Dictionary&lt;Tkey,Tvalue&gt;来说，每次调整增加的容量都是质数。虽然不知道为什么要这样设计，但奇怪的知识增加了！</p>
<p>除了让其自动增长之外，还可以直接访问Capacity，手动设置为不小于当前Count的值；也可以调用List的<code>TrimExcess()</code>方法，将Capacity直接削至Count的值。不过考虑到开销，如果未使用的容量小于总容量的10%，则不会对容量进行调整。下面是在加入了300个元素后，调用<code>TrimExcess()</code>（用黄色字体表示），再加入300个元素的效果：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99574:/iOIcSNkACBZKDPa.png?authkey=AIbyrqnS5z58phc" alt="TrimExcess"></p>
<p>手动设置Capacity有什么用呢？毕竟就算设置了，由于Capacity的自动调整机制，还是能不受限制地往里添加元素。而且在调整Capacity时，还会有复杂度为O(n)的计算，这是因为List&lt;T&gt;仍然基于顺序存储，调整Capacity必须在内存中重新划分一块区域，再把元素复制进去。关于手动调整Capacity的意义我依然存疑，如果你知道，请告诉我！</p>
<h3 id="增"><a class="header-anchor" href="#增">¶</a>增</h3>
<ul>
<li>Add() 在末尾动态加入元素</li>
<li>AddRange() 在末尾添加一个集合中的元素</li>
<li>Insert() 在指定索引处插入元素</li>
<li>InsertRange() 在指定索引处插入一个集合的元素</li>
</ul>
<h3 id="删"><a class="header-anchor" href="#删">¶</a>删</h3>
<ul>
<li>Remove() 删除第一个内容匹配的元素</li>
<li>RemoveAt() 删除指定索引处的元素</li>
<li>RemoveRange() 删除一定范围内的元素</li>
<li>RemoveAll() 删除所有条件匹配的元素</li>
<li>Clear() 直接清空</li>
</ul>
<h3 id="改"><a class="header-anchor" href="#改">¶</a>改</h3>
<p>依然可以直接用下标索引访问：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">animalCollection[<span class="number">0</span>] = cat;</span><br></pre></td></tr></table></figure>
<p>其原理是List类用Item()方法作索引器。</p>
<p>但要注意，List的长度是其Count属性的值。对于新建的List，没有任何元素，Count为0，甚至不能用0号索引来访问并赋值。应该先用一些方法让索引对应的位置可用。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">List&lt;Animal&gt; animalCollection = <span class="keyword">new</span> List&lt;Animal&gt;();</span><br><span class="line">animalCollection[<span class="number">0</span>] = cat;    <span class="comment">//这是错误的，0号元素还不存在</span></span><br><span class="line"></span><br><span class="line">List&lt;Animal&gt; animalCollection = <span class="keyword">new</span> List&lt;Animal&gt;(<span class="keyword">new</span> Animal[<span class="number">10</span>]);</span><br><span class="line">animalCollection[<span class="number">0</span>] = cat;    <span class="comment">//这是可以的，创建List时填入了10个null</span></span><br></pre></td></tr></table></figure>
<h3 id="查"><a class="header-anchor" href="#查">¶</a>查</h3>
<ul>
<li>Contains() 判断List内是否有内容匹配的元素</li>
<li>Exists() 判断List内是否有条件匹配的元素</li>
<li>Find() 查找并返回第一个条件匹配元素</li>
<li>FindAll() 查找并以List的形式返回所有条件匹配元素</li>
<li>IndexOf() 查找第一个内容匹配的元素，返回其索引(可以用重载指定搜索范围)</li>
<li>LastIndexOf() 查找倒数第一个内容匹配的元素，返回其索引(可以用重载指定搜索范围)</li>
<li>BinarySearch() 用指定的比较器在一定范围内二分查找元素，返回其索引</li>
</ul>
<h2 id="字典-Dictionary-Tkey-Tvalue"><a class="header-anchor" href="#字典-Dictionary-Tkey-Tvalue">¶</a>字典 Dictionary&lt;Tkey,Tvalue&gt;</h2>
<p>C#中的字典是泛型的哈希表（HashTable），存储的是键值对<code>KeyValuePair&lt;TKey, TValue&gt;</code>。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; mydict = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line"><span class="comment">//仍然是Add()添加元素</span></span><br><span class="line">mydict.Add(<span class="string">&quot;lang1&quot;</span>, <span class="string">&quot;C++&quot;</span>);</span><br><span class="line">mydict.Add(<span class="string">&quot;lang2&quot;</span>, <span class="string">&quot;C#&quot;</span>);</span><br><span class="line">mydict.Add(<span class="string">&quot;lang3&quot;</span>, <span class="string">&quot;Python&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//CotainsKey()判断是否有该键，也有ContainsValue()判断是否有值</span></span><br><span class="line"><span class="keyword">if</span>(mydict.ContainsKey(<span class="string">&quot;lang3&quot;</span>))</span><br><span class="line">      mydict.Remove(<span class="string">&quot;lang3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据TKey使用索引器，但访问前不检查可能会爆炸(KeyNotFoundException)</span></span><br><span class="line"><span class="comment">//WriteLine(mydict[&quot;lang3&quot;]);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//TryGetValue()尝试用key获取value，没获取到的话传出null，本身返回False</span></span><br><span class="line">WriteLine(mydict.TryGetValue(<span class="string">&quot;lang4&quot;</span>, <span class="keyword">out</span> <span class="built_in">string</span> test));</span><br><span class="line">WriteLine(test);</span><br></pre></td></tr></table></figure>
<h2 id="队列-Queue-T-和堆栈-Stack-T"><a class="header-anchor" href="#队列-Queue-T-和堆栈-Stack-T">¶</a>队列 Queue&lt;T&gt;和堆栈 Stack&lt;T&gt;</h2>
<p>这两个就更没什么值得说的了，基本上是List&lt;T&gt;的“阉割”版。</p>
<p>对于它们而言，添加、删除元素并不是用Add()方法和Remove()方法。队列Queue&lt;T&gt;中，使用入队Enqueue()和出队Dequeue()；队列Stack&lt;T&gt;中，使用压入Push()和弹出Pop()。</p>
<p>你也无法再使用索引随机访问Queue和Stack中的元素，必须遵守这两种数据结构的规则。能进行的操作非常有限，比如用Peek()访问队首/栈顶元素。</p>
<h1>枚举器</h1>
<p>说到枚举器，必须了解的是两个接口：<code>IEnumerator</code>和<code>IEnumerable</code>。</p>
<h2 id="IEnumerable"><a class="header-anchor" href="#IEnumerable">¶</a>IEnumerable</h2>
<p>所有的数组和集合都实现了这个接口，它们被称为可枚举类型。这也是数组和集合能进行各种操作，乃至使用LINQ的基础。这个接口里只有一个方法：</p>
<p><code>GetEnumerator()</code>。</p>
<p>方法名很易懂，获取枚举器。C#中的“枚举器”，指的就是实现了接口<code>IEnumerator</code>的类型。</p>
<p>LINQ为IEnumerable接口添加了许多扩展方法，这一点在第C#杂记的壹和叁中我都有提到。其实由于LINQ用查询表达式写可读性更强，这些扩展方法里我觉得最有用的是<code>ToList()</code>方法，它可以把各种数组和集合都转换为万能的List&lt;T&gt;。特别地，对Stack&lt;T&gt;来说，调用<code>ToList()</code>后得到的列表是根据“后进先出”的出栈顺序排列的。</p>
<h2 id="IEnumerator"><a class="header-anchor" href="#IEnumerator">¶</a>IEnumerator</h2>
<p>如上所说，实现了这个接口的类型被称为枚举器。</p>
<p>枚举器的工作就是把元素一个个地吐出来（枚举）。这个接口用三个成员共同实现了类似链表的数据结构：</p>
<ul>
<li>Current：序列中当前位置项的属性，以<code>object?</code>可空类型表示，故可以为任何类型。原始状态下这个属性不可用，访问时会抛出异常：
<blockquote>
<p>System.InvalidOperationException:“Enumeration has not started. Call MoveNext.”</p>
</blockquote>
</li>
<li>MoveNext()：将枚举器位置指向下一项，如果下一项是无效的，则返回False，表示枚举已经完成。</li>
<li>Reset()：把位置重置为原始状态。</li>
</ul>
<p>实现了<code>IEnumerable</code>的可枚举类型，其能够使用foreach语句进行迭代的原理就是运用了枚举器：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] myArray = &#123; <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span> &#125;;		<span class="comment">// 创建数组</span></span><br><span class="line">        <span class="keyword">var</span> ie = myArray.GetEnumerator();	<span class="comment">// 获取枚举器</span></span><br><span class="line">        <span class="keyword">while</span> (ie.MoveNext())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> i = (<span class="built_in">int</span>)ie.Current;	<span class="comment">// 获取当前项</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, i);	<span class="comment">// 输出</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用foreach进行同样的迭代</span></span><br><span class="line">        <span class="keyword">foreach</span>(<span class="keyword">var</span> i <span class="keyword">in</span> myArray)</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>比较与排序</h1>
<p>众所周知，一切排序算法的基础都是<strong>比较</strong>。不同排序算法的复杂度之差异，就在于它们比较元素的次数。</p>
<p>C#中有两个接口用于实现比较：<code>IComparable</code>和<code>IComparer</code>。</p>
<p>看这两个接口的名字，就可以会猜测它们和上面在枚举器里说到的两个接口的关系一样。事实上它们之间有很大不同，但也有相似之处。</p>
<h2 id="IComparable"><a class="header-anchor" href="#IComparable">¶</a>IComparable</h2>
<p>实现了这个接口的类型是可比较类型，由它们组成的数组、集合是可以进行排序的。C#中有很多内置类型已经实现了这个接口，比如各种值类型、字符串、时间日期等等。</p>
<p>这个接口也只有一个方法：<code>CompareTo()</code>。</p>
<p>CompareTo()接收一个用于和<code>this</code>比较的参数，并返回一个<code>int</code>作为比较的结果。举个例子，如果定义了<code>Person</code>类，且为其实现IComparable接口：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span> : <span class="title">IComparable</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span> &#123; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span> </span><br><span class="line">   &#123; </span><br><span class="line">      <span class="keyword">this</span>.Name = name; </span><br><span class="line">      <span class="keyword">this</span>.Age = age; </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//实现IComparable接口</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.Age == obj.Age)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.Age &gt; obj.Age)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在此基础上，比较两个Person：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(person1.CompareTo(person2) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   WriteLine(<span class="string">&quot;Same Age.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(person1.CompareTo(person2) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   WriteLine(<span class="string">&quot;Person 1 is older.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(person1.CompareTo(person2) &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   WriteLine(<span class="string">&quot;Person 1 is younger.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="IComparer-T"><a class="header-anchor" href="#IComparer-T">¶</a>IComparer&lt;T&gt;</h2>
<p>Comparer是“比较器”，对于那些没有实现IComparable接口的类，可以为其单独定义一个实现IComparer&lt;T&gt;的类。</p>
<p>接口中包含一个方法<code>Compare()</code>。它对两个<code>T</code>类型的对象进行比较，返回<code>int</code>作为比较的结果。这个接口也有非泛型版本，它能支持不同类型的对象之间的比较，这很神秘，可能一般不会用到。</p>
<p>用实现了IComparer&lt;Person&gt;的比较器对两个Person进行比较：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">   Person person1 = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">24</span>);</span><br><span class="line">   Person person2 = <span class="keyword">new</span> Person(<span class="string">&quot;罗翔&quot;</span>, <span class="number">42</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">int</span> n = <span class="keyword">new</span> PersonComparer().Compare(person1, person2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Sort-方法"><a class="header-anchor" href="#Sort-方法">¶</a>Sort()方法</h2>
<p>Sort()方法运用集合中元素所属类型的默认比较方法，或指定的某种比较方法进行<strong>升序排序</strong>。</p>
<p>这个方法有四种重载：</p>
<ul>
<li>Sort()<br>
无参形式，在元素对象实现了IComparable接口时可以使用。</li>
<li>Sort(IComparer&lt;T&gt;)<br>
以比较器为参数，需要定义比较器，并<code>new</code>一个传入。</li>
<li>Sort(Int32, Int32, IComparer<T>)<br>
在指定范围用比较器排序。</li>
<li>Sort(Comparison<T>)<br>
用委托进行排序，其中委托Comparison&lt;T&gt;接受两个同类型参数，返回int。原型： <figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Comparison</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T x, T y</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这看起来并不够优雅，直接用LINQ的<code>OrderBy()</code>配合Lambda表达式来排序它不香吗？</p>
<p>据说OrderBy没法在Unity构建的iOS游戏上运行，所以必须得用Sort()。不过去它妹的，等真的踩了这个坑再说吧，现在先记在这里（笑）。</p>
<blockquote>
<p>原本以为数组和集合是极为简单的东西，计划着能在一天内写完，结果坑越挖越多，中途也写了不少代码进行测试和验证，竟然也花了快一个星期。至此，C#入门级别最大的几块拼图几乎完成了。后面的坑还有装箱拆箱、特性、堆区与栈区内存、对象的构造与析构过程、垃圾回收机制、异步流式处理等等，慢慢填吧。</p>
</blockquote>
]]></content>
      <tags>
        <tag>C Sharp</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>200505：后浪</title>
    <url>/2020/05/05/200505/</url>
    <content><![CDATA[<p>不可避免地，这两天被《后浪》刷了屏。</p>
<p>看到<strong>后浪</strong>二字，我一开始想到的是那家后浪出版公司。我还在读《vista看天下》时，这家出版公司就有许多存在感。虽然知乎上只看梵语原著的大佬们将其打为营销号的同类，但我至少认同他们在选书和装帧上的天分。对于一家出版公司，这好像也就是最重要的：把那些有趣有用的书以亲近可人的姿态送进大街小巷的书店，让那些或许仅仅是为刻奇所驱使，亦或许真正识文解意的爱书人，能够看到那个熟悉的图标就忍不住算算自己的余额。</p>
<p>显然，我是属于前一种“爱书人”。也许上次去书店我抽出了《山海经校注》，这次我找来了一本《中国神话史》，下次还要考虑着把那套《火鸟》扛走……但是实际上堆在桌上，自己经常翻看的还是诸如《C#高级编程》和《Unity 5.x从入门到精通》之类，“科技类图书四大社”的俗套玩意。</p>
<p>噢，不——在那堆东西里甚至还夹着一本没翻过几页的《日本书纪》。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99578:/Vna4JIWD3xKYSe5.jpg?authkey=AIbyrqnS5z58phc" alt="冠位十二阶 宪法十七条"></p>
<span id="more"></span>
<p>总之，比起“果麦”那种昂贵的书架装饰品，我对“后浪”和广西师范大学的“理想国”是更有好感，或者说怀抱更多敬意的。</p>
<p>而关于《后浪》这条视频，“脱离群众”、“毒鸡汤”的批评已经太多太多，我所在意的是如今中国青年中的新思潮。</p>
<p>改革开放四十年，阶级再一次被建立起来，甚至前所未有地固化。这个时代自大又自卑的青年们，被打鸡血有多亢奋，面对现实就有多寒心。当他们发现自己不幸福的原因不是不够优秀不够努力，而是国籍属于第三世界，或者自己不是什么二代三代时，他们很难再接收下一次的鸡血注射。</p>
<p>我实在不属于键政圈，是个对政治完全没有多少了解的普通人。但就像恶臭、MUR猫和抽象话一样，如今山高县和曹丰泽等人发展出的“入关学”火出了圈，仿佛成了一颗解决“内卷”的银弹。这似乎也是现代青年在困惑中思考出的结果：取而代之，开皮卡吃牛肉住大house。</p>
<p>是什么和为什么都很清楚，<strong>可是，怎么做？</strong></p>
<p>嘿，有意思的是，当说到这里，前一秒还在规划着未来的人往往沉默，或者含糊其辞。偶有高声应者，竟是宣扬“996”之必要性：“你不努力奋斗，不熬夜加班修福报，怎么积累入关资本？”哦我的天，996难道不是入关学试图解决的问题吗？</p>
<p>以我粗浅的思想看来，另一条路是很明确的，只是不怎么有人愿意提，毕竟一提到用它来入关，号可能就要没了——那就是马克思主义。入关学甚嚣尘上的同时，我也听到左派的声音确实越来越大。那些言必谈马恩列斯毛，却并不自称为“小青马”的“真马克思主义者”们如今到处都是。我真的很好奇这种“文艺复兴”会把中国带向何处，于是我试着认真地在知乎上提出了这个问题。如我所料地，还没过一分钟，它就消失在了知识的荒原。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99575:/IAMH8e5ri9swjSG.jpg?authkey=AIbyrqnS5z58phc" alt="马恩列斯毛"></p>
<p>且不说如今中国的马克思主义浓度到底有多高，至少许多政治方面教师的意识形态大家都是很明白的。这里我只想吐槽中国共产党的网站建设。猜猜在中共官方网站<a href="http://cpc.people.com.cn/">人民网</a>找出《邓小平文选》有多大的难度？虽然标着“理论”、“学习”、“书库”的链接一大堆，但相信我，你可能会在掘地三尺终于找到入口之后，看到这个画面：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99576:/eTYX5yOimQvz2Mj.png?authkey=AIbyrqnS5z58phc" alt="404"></p>
<p>实际上，你得在<a href="http://www.dswxyjy.org.cn/">中共中央党史和文献研究院</a>才能找到。这个研究院的前身中央编译局可能更为人所熟知。猜猜在百度搜索“中央编译局”，打开那个标着“官方”、标题是“中共中央党史和文献研究院”的链接，你会看到什么？</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99577:/FSBCVRKcwPT15Xd.png?authkey=AIbyrqnS5z58phc" alt="消失的中央编译局"></p>
<p>反而是在没有任何官方背景的<a href="https://www.marxists.org/chinese/index.html">马克思主义文库</a>，你可以自由畅爽地浏览各种文献。看看他们如何以传统的方式庆祝劳动节吧，这种文风已经快成为非物质文化遗产了：</p>
<blockquote>
<p>在全世界无产阶级共同的节日五一劳动节来临之际，我们向全体默默努力与奋斗的劳动者祝贺节日快乐！<br>
不论这个世界被说成多么美好，但只要剥削、压迫及其根源私有制存在一天，它就不属于劳动人民。<br>
让我们继续为阶级解放而奋斗。劳动人民终会推翻万恶的剥削制度，获得自由解放。全世界无产阶级大团结万岁！</p>
</blockquote>
<p>写到这里时，伴随着阵阵鞭子声，窗外传来十来岁孩子声嘶力竭的哭喊：“我要离家出走，快让我出去，我要死啊……呜呜，你打我的头呀，你快点打死我呀……我要去，我要去坐牢！”</p>
<p>这也是后浪的一朵。那一家的电视机常传来英语教学和卡通动画的声音。</p>
<p>我在阳台望向万家灯火，心情十分平静。没有什么宏大叙事。大家只是这么顺其自然稀里糊涂地过下去，兵来将挡水来土掩——历史就在每个普通的时刻被人民群众书写着。</p>
<blockquote>
<p>庚子立夏。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>国事</tag>
      </tags>
  </entry>
  <entry>
    <title>200621：江湖再见</title>
    <url>/2020/06/23/200621/</url>
    <content><![CDATA[<p>距离上一次更新竟然过去了一个半月。倒也不是我不想写，每当念起时总有些“俗事缠身”。而当处理完这些事，我要么是没有安静的适合写作的环境，要么便是只想躺平刷微博，失却了敲键盘的热情。</p>
<p>今天终于得闲，慢慢地来记几笔吧。</p>
<p>五月初，我终于得知毕设deadline的确切日期已经不远，而且那时我的春招战果虽不算好，但总归拿到了保底的offer，唯一要做的就是赶进度了。To Do List上的待办事项随着Commit被勾掉一些，那时我充满热情，状态是相当理想的。我又满怀兴奋地购入一堆技术书籍——不必说，它们自然还是没有被翻过几页。</p>
<p>我的Unity终于有了点入门的感觉，开发就像华科的施工队般“日新月异”。为了保持这种节奏，毕设所需要写的那些形式上的文书之类一度令我深恶痛绝，但很快我就从中感受到了回顾与总结既往工作的乐趣，这项杂务实际上是大有裨益的，让人能暂时跳出“此山中”，不至于沉迷于手头的问题而“不见庐山真面目”。</p>
<p>到了线上答辩的时刻，大家的课题多是大型分布式系统或者机器学习等等非常“Computer Science”的内容，我的《基于Unity的东方Project同人ARPG游戏设计与开发》无论什么时候都那么格格不入。偏偏我的答辩排在最后几位，只好先接受了数个小时的天书洗礼。</p>
<span id="more"></span>
<p>轮到我时，我感到冷汗直冒，毕竟届时完成的内容实在是少之又少，短到30秒就能演示得七七八八，连敌人的寻路移动都还是答辩前一天才勉强做出来的。我打开游戏，对基本不懂游戏的老师、和过于懂游戏的同学们进行解说，由于演示全程只有我一个人的声音，那种感觉别提有多尴尬了。之后，对着PPT我天花乱坠地讲了一堆乱七八糟的东西——ZUN、东方、同人展、GPU实例化、SDF算法、字体渲染、UI设计、像素艺术、TileMap、《元气骑士》、A*算法、符卡和擦弹、Shader、法线贴图、行为树……</p>
<p>哦对，那段时间我曾试图写一篇总结各种最短路径算法的文章，可时间不够，又多了一篇草稿。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99579:/z51u3qRUyGEcniD.jpg?authkey=AIbyrqnS5z58phc" alt="答辩PPT"></p>
<p>听完之后，大家沉默了，似乎也没有人发现我的演示超时了好几分钟。很意外的是，最终我得到了高达95的惊人评分，甚至被推荐评选优秀毕设。最后因为种种原因，我没能参加评优答辩，但这个结果已经远远超出我的预期了。半年以来，或者可能是更长的时间里，我极少有机会得到认可和鼓励，作为四年里得分最高的课程，它为我的大学生活画上了还算完美的句号。</p>
<p>我的导师陈汉华教授对于我没能进入游戏行业工作表示遗憾。我自己当然更是感到后悔，就像去年年底刚刚开始走上这条路时我所想的，“如果能早个一年开始……”</p>
<p>社会的毒打总是残酷，记不得是阮一峰、陈梓瀚还是哪位大佬说的：“你毕业时第一个月的工资，约等于大学期间所买的技术书籍价格之和。”对于并不优秀的人，选择是很少的。但答辩结束之后我竟然看到了一丝转机：简历投去快两个月都没有消息的游戏公司点点互动，也就是曾经的FUNPLUS来找我了。</p>
<p>那时我已经接受中国信科的offer，而且对自己的游戏开发能力还远不够自信，一度想要推辞。我的确不够自信，以至于某一天我把自己的QQ签名改为了<strong>TURING COMPLETENESS</strong>（图灵完备）——这是“世上无难事”的计算机科学表达。但在HR的劝诱下，我还是开始了应聘流程。过程大体顺利，一轮笔试四轮面试，一路面到了CTO。他们的CTO沈翔先生在EA做主机游戏出身，面试里多次讲到<strong>Responsibility</strong>和<strong>Passion</strong>，是个对游戏充满热爱的人，而我那次的表现也很让他感到惊喜和满意。一个月里能得到两次认可，我已经是快乐之至了。因此，在谈完薪资和报到时间，通过HR终面的时候，我以为自己已经峰回路转、世界线变动，很快就要到上海去，在游戏行业一展身手。</p>
<p>计划赶不上变化，也许是因为这家横跨中美的公司受到了两次疫情的打击，也许是因为别的什么原因，就在我的offer即将发下时，他们缩招了。这下，半个月期间参加的面试都成了徒劳，在同人展一掷千金之后交不起房租，只能靠萨莉亚过活的日子也化作泡影。我很是颓丧了一小会，不过这也许本就不是如今的我所应得的，我就靠这样的“精神胜利法”说服了自己接受继续留在武汉的命运。可是，面对闯荡一线城市，拿着几乎数倍于自己工资的同学们，待在武汉“体制内”的我怎么可能不酸呢？</p>
<p>说到武汉，这个插曲过去时，华科毕业生的最后一次返校也到来了。返校政策涉及到几千人的核酸检测和行程，却在临近日期时一变再变，好在最后有惊无险，我的寝室里也没有出现大量的蜘蛛蟑螂，只是许多东西都发了霉。</p>
<p>许多同学还是选择在分两批的返校中于第一批返校。那两天的深夜，一群男生在宿舍进行了最后的疯狂：我们喝酒、打牌、大声嚷嚷——毕竟，毕业证已经拿到手了，辅导员和宿管再也管不了我们。我虽断碳十几天，但是面对两箱啤酒和学院提供的无限畅饮可口可乐，谁能拒绝呢？健康？去它的吧！我立刻就要可能是永远地告别学生时代，从此只有“欲买桂花同载酒，终不似，少年游”的慨叹了。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99583:/KWIXwNuL8Q9vamc.jpg?authkey=AIbyrqnS5z58phc" alt="茶话会？"></p>
<p>原本我们都认为这一届毕业生不会有毕业照和拨穗仪式了，但既然能安排上返校，这些传统艺能还得操办起来。校园里的大家都是已经进行过核酸检测的“良民”，在武汉这个曾经的疫情震中也可以暂时摘下口罩，简直是一种放肆。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99580:/VzX7ZjvGLxIUWRm.jpg?authkey=AIbyrqnS5z58phc" alt="传统艺能"></p>
<p>再会了，1037号森林！</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99581:/FZaD8O2Wz5seBkp.jpg?authkey=AIbyrqnS5z58phc" alt="未名小亭"></p>
<p>回到家里，学院的毕业纪念册上是我赶在毕业论文交稿前写的文案：</p>
<blockquote>
<p>你问我，九班是什么？<br>
是积分，是正交矩阵，是无限深势阱<br>
是堆栈，是跳转指令，是有限状态机<br>
是线程，是选路算法，是静态服务器<br>
是报告，是期末考试，是青年大学习<br>
是电路板的焊点，是示波器的曲线<br>
是昙华林的红旗，是马鞍山的炊烟<br>
是博物馆的编钟，是植物园的睡莲<br>
是篮球赛后的脉动，是排球场上的鸣笛<br>
是拱手论道的李耳，是举手打车的主席<br>
是热干面、平安果，可乐鸡翅与火锅<br>
是关山口、叶麻店，光谷广场与沁苑<br>
珍重再见！珍重再见！<br>
刺鼻的石楠花刺眼的梧桐絮<br>
华科的它们已成美好的过去<br>
而作为那一夜璀璨的流星群<br>
九班的我们奔向光明的前途<br>
&quot;CS1609&quot;这个字符串<br>
它曾被一群可爱的人无数次写下</p>
</blockquote>
<p>离校还没一周，我又跑到武汉去见第二批返校的<a href="https://github.com/richardoml">RichardoML</a>和<a href="https://github.com/vincecooper">Vince Cooper</a>，但已经不能再进校园。“这就是最后了！”我说。不过这其实还不是最后，学校正式的毕业典礼还没举行呢。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99582:/EaYtmJdQZ9w8TOU.jpg?authkey=AIbyrqnS5z58phc" alt="该走了。"></p>
<p>毕业典礼正是在今天，有许多鸡汤的灌溉、许多后浪的澎湃，最后直播信号中断在<code>10:37</code>。这是真正意义上的结束了。</p>
<p>刚刚毕业时，我还怀着对迈进广阔世界的些许不安，但现在我只想早日回归那种为了解决自己所面临的问题，而终日独坐、心无旁骛的生活。今天一气读完玛丽·雪莱的《弗兰肯斯坦》，让我似乎找到了点那种感觉。</p>
<p>但是朋友，你能想象吗？2020年现在还没过一半，作为去年预想中《东方珀露涧》之主题的“庚子之灾”，已经展现了其充足的威力。对下半年的世界我很是期待：四方的盒子里，有学习的时间、同住的朋友、大彩电和茶几沙发……再拿秋雨的帘幕将窗户一遮，我隔岸观大洋彼岸的火，只待次世代正式带来<code>.NET 5.0</code>和<code>Xbox Series X</code>，还是很有些惬意的。</p>
<blockquote>
<p>庚子夏至。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>200722：中国移动与高跟鞋</title>
    <url>/2020/07/22/200722/</url>
    <content><![CDATA[<p>又是一个月，我还是没有写技术方面的博客，这两个月的状况恰如自己突然变得稀疏的GitHub页面：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99584:/ZHmG2KzgC4vMa95.png?authkey=AIbyrqnS5z58phc" alt="GitHub突然稀疏"></p>
<p>再这么下去，我可真的要写不来代码了。</p>
<p>最大的事儿，当然是入职了。这次加入的是成立不久的央企中国信科，由历史悠久的烽火通信和大唐电信合并而成，一言蔽之如今是在通信行业排在华为和中兴之后第三位的公司。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99585:/QadeXHJM6t8fyvD.png?authkey=AIbyrqnS5z58phc" alt="中国信科"></p>
<p>说实话，以前我与烽火通信几乎没有什么交集，而大唐电信倒是早有耳闻，不仅仅是因为它那霸气侧漏的名字，最主要的是3G时代大唐电信给中国移动搞的那套备受吐槽的<code>TD-SCDMA</code>制式，让我这个当年的G3用户深切认识到了什么叫“如果G3就是3G，那么国美就是美国”。</p>
<span id="more"></span>
<p>自此，我成为了中国移动黑，凡是能自定义运营商标识符的手机，我都给改成了“中国移不动”，G3带给我的心理阴影一直保留到现在，让我看到移动那红配绿赛狗屁的<code>AND和</code>LOGO就敬而远之，回忆起WAP飞信网是如何用氪金手游把我钱包骗空的，以及比五福一安还要历史悠久的祖传5元30M。在有线网络方面，移动这家伙也没让我失望，网络上对移动宽带跨越多年的种种吐槽无需赘述。</p>
<p>我早已打算好再也不要和移动扯上一毛钱的关系，然而，生活往往在你意想不到的时候给你开个玩笑。搬到金融港之后，联通装宽带的师傅问我们是否有联通光猫可用。我在阳台找到了移动的光猫，却发现背后的铭牌赫然印着<code>FiberHome烽火通信</code>——巧了，我就是烽火通信宽带部门的员工。</p>
<p>无语之际，我也觉得这是一个良机，让我在亲身经历通信产品的研发之后，能放下对中国移动的成见：大力支撑中国自研技术探索的中国移动太不容易了！另外一方面，“如果你觉得你的祖国不好，你就去建设它”的这种说法，如今我正是在践行着。细细想来，我倒不是真的讨厌移动，或者别的什么公司——比如微软——完全是一种“恨铁不成钢”的思想：你这么牛逼，咋这点基本的体验都做不到位呢？我寻思我上我也行！</p>
<p>工作和职业，也就是这么一回事吧。在脱离了生存还是死亡的威胁之后，对一些事物“看不下去”，想要用自己的能力减少一些夜半疾呼“CNM”的声音，因此，去工作了。</p>
<p>说得好像很理想化，其实与这两天在培训中讲到的工作的意义没有违背多少。</p>
<p>培训才开始两天，这短短时间里我就开始了纠结的思考。听着视频里打扮成朋友圈标准形象的讲师口若悬河，老是会胡思乱想。他们有时像是在提供谆谆教诲，有时又像是在为资本家摇旗呐喊，最终反复围绕着的核心，就是<strong>职业化</strong>。</p>
<p>我印象很深刻的是一个“经济学家与小孩”的故事，没有在网上找到出处，所以简述大意如下：</p>
<blockquote>
<p>经济学家的屋外每晚都有一群小孩疯闹，吵得他不得安生，在与他们交涉无果后，经济学家想了个办法：<br>
他对孩子们说：“今天你们谁闹得最大声，我就给30美元作为奖励。”当然，这一天孩子们兴高采烈地大喊大叫。<br>
第二天，经济学家说：“我能发的钱不多，未来三天你们谁闹得最大声，我就奖励10美元。”孩子们虽然热情下降了些，但仍有人坚持大喊大叫。<br>
过了三天，经济学家又说：“非常抱歉，我以及没钱可奖励你们了，所以接下来十天闹得最大声的，我只能奖励5美元。”<br>
这下，压根没有孩子愿意来了，经济学家开始享受他安静的养老生活。</p>
</blockquote>
<p>外部激励会改变人的行为。换个表述，那就是“资本主义对人的异化”，虽然在上面这个故事中体现得还不是那么露骨。这种异化的手段，也许就是讲师们反复强调的“职业化”。它与马克思所希求的“全面而自由的发展”，或者说人的自我实现，是对立的。</p>
<p>但如今，资本主义的话语体系将人的自我实现之路称为“职业规划”，并且把它也作为“职业化”的一部分，给这本应自由的事物加上了许多条条框框，将自我实现指向这样一个结果：“世俗意义上”的成功者要么是全心全意为资本家卖命的卫道士，要么就是资本家本身。</p>
<p>当然，我不过仍然是在信口开河：我连一本马克思的著作都没认真读过呢。键政不可取，不可取。</p>
<p>但是仍然有令我非常膈应的事物：讲起职业礼仪的时候，女性的职业着装必须得有高跟鞋。都说“久病成医”，作为在微博上无时无刻被“一小撮”极端女权主义分子重拳出击的“蝈蝻”，自然也懂得一些拳法套路。如今凡是听到这些两性有别的敏感话题，几乎是条件反射般地想打拳：高跟鞋就是现代版的裹小脚，职场的这种恶臭规则完全是由男权社会制定，为了迎合男性的一般审美而泯灭天性，为什么中国女性连上班穿双鞋的自由都没有，我气得浑身发抖，大热天的全身冷汗手脚冰凉……</p>
<p>其实我就是单纯的不怎么喜欢高跟鞋而已。</p>
<p>即使是《崩坏3》或许继承自《猎天使魔女》的对高跟鞋的谜之执着，也并没有让我产生多少好感。</p>
<p>虽然我不可能亲自穿过，但高跟鞋给我的印象就是硌脚崴脚咚咚咚，以及暴露出脚背并不好看的蓝色静脉血管，至少，除了拔高身高之外，我是想不到它与乐福鞋相比有什么优点。某种语境下的“乐福鞋”与精神小伙中一度流行的豆豆鞋指的是一种东西（GUCCI必须背锅），我这里指的则是类似JK制服鞋的那种样式，大概是这样的：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99591:/AFtwZgcayEnsBk7.jpg?authkey=AIbyrqnS5z58phc" alt="pid = 40513774"></p>
<p>顺带一提，一定不会有人像这样坐在雪地上。</p>
<p>（这篇，到底在写什么玩意啊……）</p>
<blockquote>
<p>庚子大暑。</p>
</blockquote>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>能不能好好上网-壹：搭建IPv6私有云盘</title>
    <url>/2020/08/09/%E8%83%BD%E4%B8%8D%E8%83%BD%E5%A5%BD%E5%A5%BD%E4%B8%8A%E7%BD%91-%E5%A3%B9/</url>
    <content><![CDATA[<p><strong>能不能好好上网？</strong></p>
<p>在中国，很难。</p>
<h1>故事背景</h1>
<p>我对网络的探索与折腾，源于每台Windows电脑都自带的“远程桌面连接”。和“公文包”与“媒体库”一样，这种系统里的隐秘角落就像等待人去探险的洞窟和密林，激发着我的好奇心。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99586:/FcrqSmxuBWz9e8a.png?authkey=AIbyrqnS5z58phc" alt="远程桌面连接"></p>
<p>到底要怎样使用这个东西呢？尤其是，当发现计算机名竟然可以随意更改时，我产生了担心：如果有重名的计算机，我怎么知道要连到哪一台呢？</p>
<p>以此为契机，我了解到了局域网，IP和3389端口的概念——巧合的是，我目前的手机尾号就是<code>3389</code>，而前半部分则恰好可以写作一个IPv4地址。那时，中国的网络用户数量远不如今天，大部分设备都有公网IP。可能也正因如此，诸如CS1.6，War3和东方非想天则一类基于IP联机的游戏能够风靡一时。</p>
<p>时代变了。匮乏的IPv4地址资源遇上万物互联的爆发式增长势头，NAT一层套一层，再也没法畅快地IP直连，人们在网络里也像居住于水泥丛林间的鸽子笼，失却了那种田间地头吆喝一嗓子的快意。</p>
<p>在演变到今天状况的前两年，大家还有动态的公网IPv4地址，而不是被圈养在运营商的“大内网”里，那段时间我还能进行一些“叠床架屋”的操作来胡作非为。</p>
<p>我在树莓派上弄了一个简单的Python脚本，每隔一小时检查路由器的公网IP，如果发生了变动就用邮件形式发出通知。再配合路由器上配置的IP-MAC绑定和端口转发，我就能在外访问到局域网里某台设备的具体端口。虽然后来改用了更方便的TeamViewer，但很长一段时间里，我就是这样在实验课机房里连接寝室中的台式机来写代码的。如今看来，我这操作基本就是实现了一个“低配版”的DDNS服务。</p>
<p>那么，说回现在。</p>
<span id="more"></span>
<h1>无源光网络PON</h1>
<p>这半个多月的培训期间我虽然挺摸，但也不是白学的。</p>
<p>首先，要从网络的宏观结构讲起。放到可能是最宏观的角度，整个通信网络就分为三层：</p>
<ol>
<li>核心层</li>
<li>汇聚层</li>
<li>接入层</li>
</ol>
<p><code>PON</code>(Passive Optical Network)所在的就是接入层。简而言之，它不用电，而是用完全的光线路将终端设备与“局端”，即运营商的机房连接起来。</p>
<p>这个过程中，运营商机房里的终端设备叫做光线路终端<code>OLT</code>(Optical Line Terminal)。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99587:/H6TtIV3QYKRnZek.jpg?authkey=AIbyrqnS5z58phc" alt="烽火OLT AN6000"></p>
<p>从OLT延伸出其的线路则称为光分配网<code>ODN</code>(Optical Distribution Network)，由光纤光缆和光缆交接箱、光分路器等各种设备组成，最终把机房的光纤连入千家万户。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99588:/pWMHZyJ2tDA8Sua.jpg?authkey=AIbyrqnS5z58phc" alt="光交箱"></p>
<p>你家弱电箱里连接光纤的“光猫”属于光网络单元<code>ONU</code>(Optical Network Unit)。它最重要的功能就是拨号，并将接收到的光信号转换成电信号，再通过以太网线连接其他设备。不过，现在的ONU大多还集成了无线路由器，就如下图所示，它甚至能使用双频WiFi兼顾穿墙和大带宽的功能。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99590:/zCWKXgnjQtHGDm2.jpg?authkey=AIbyrqnS5z58phc" alt="ONU"></p>
<h1>路由？桥接？</h1>
<p>光猫有两种工作模式：“路由”与“桥接”。</p>
<p>默认情况下，光猫以“路由”模式工作。此时它身兼数职，有些“融合终端”类型的设备甚至还要充当IPTV机顶盒。可它毕竟是办宽带的时候100块钱就给你装上的玩意，其无线热点质量当然没法和专职的无线路由器媲美。现在的无线路由器大多也内置了拨号能力，如果我们让专业的设备做专业的事，即让路由器负责拨号和无线热点，而仅仅将光猫作为一个无情的光电转换器，二者的负载会平衡许多。</p>
<p>这就是光猫的“桥接”模式。除了性能上的考虑，更重要的是，这样做可以少去光猫上的一层NAT，让你的局域网设备可以通过路由器直接接入广域网，而不是被光猫再设一道卡。如果要像我曾经做的那样在外访问家中的局域网设备，改桥接是必不可少的。</p>
<p>那么，怎么改呢？</p>
<p>关于这一点其实已经有很多讨论，搜一搜“光猫 改桥接”就能出来一大堆。实际情况虽然根据运营商和设备型号的区别会有些许不同，但总体流程上依然大同小异。</p>
<p>关键是要拿到配置页面的超级管理员密码：移动写在设备背面铭牌上，联通直接就是<code>CUAdmin</code>，电信则比较麻烦，可能得用Telnet从光猫里获取一个配置文件才能找到。</p>
<p>改好桥接，光猫就失去了拨号上网的功能。接下来就需要插上无线路由器，在路由器的配置页面里设置宽带账号和密码，进行PPPoE拨号。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99589:/4cAU1RgiLjKJamB.png?authkey=AIbyrqnS5z58phc" alt="路由器拨号"></p>
<h1>IPv6</h1>
<p>按说现在就可以故技重施，为路由器配置IP-MAC绑定和端口转发，然后用公网IP来搞事了。可正如我之前所说，现在哪还有什么公网IP，你能查到的不过是运营商“大内网”里的IP罢了。</p>
<p>我不信邪，要试试前几年被网友实践过无数次的法子：打电话给运营商人工客服，宣称家里需要装摄像头/远程办公，希望分配动态公网IP。然后，再补上万能的“财富密码”——<strong>工、信、部</strong>。</p>
<p>然而依然是搞不定，到v2ex上一查也发现湖北联通确实早就弄不到公网IP了。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99592:/rb1OJq4QTuMNzvf.jpg?authkey=AIbyrqnS5z58phc" alt="无公网IP"></p>
<p>但是，真的就没有了吗？既然分不到IPv4的资源，那就用IPv6。</p>
<p>IPv4的地址分为4段，每一段都是<code>0</code>到<code>255</code>之间的256个数之一，能表示的数量才四十多亿个；而IPv6则足足分了8段，每段甚至可以是<code>0x0000</code>到<code>0xffff</code>之间的65535个数之一。IPv6能表示的数量多得不可想象，完全不需要使用NAT这种饱受诟病的东西，大家是切实地连接在同一张网上。</p>
<p>建设基于IPv6的下一代互联网早已是一项重要任务，虽由于各种历史遗留问题推进得比较缓慢，发展到今天也已小有成果。大部分的4G/5G移动网络完全支持IPv6；固网宽带基本实现了IPv6/v4的双协议栈共存，只要将拨号设备的IPv6功能开启，就能得到两个地址，而那个IPv6地址可就是“正真正銘”的公网IP了。</p>
<p>正好，我使用的小米路由器就支持开启IPv6。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99593:/7wRjS3lHJ1OgyvL.png?authkey=AIbyrqnS5z58phc" alt="IPv6设置"></p>
<p><a href="https://www.test-ipv6.com/">IPv6连接测试</a>全绿，爽到！你甚至可以现在就用手机流量/WiFi环境试一试能否接入IPv6网络。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99594:/5SJeWwB8DVXquh6.png?authkey=AIbyrqnS5z58phc" alt="测试结果"></p>
<h1>DDNS</h1>
<p>这下公网IP也有了，可我在外怎么知道自己的IP呢？难道还像以前一样自动定时检查然后发邮件通知？</p>
<p>对了，合理的方法就是使用动态域名服务DDNS(Dynamic Domain Name Server)。</p>
<p>网络建立在IP地址的基础上，它虽然适合计算机处理运算，但不方便人类记忆，所以才引入了域名。当我们用域名(网址)访问一个网站时，其实要先找DNS服务器将域名转换成IP地址，这类似于打114查号台进行电话导航。也许你还知道hosts文件，它相当于一本“私人通讯录”，假如你要去的网站在hosts里有对应的IP，就没必要费事去DNS查了。</p>
<p>而DDNS是这样的：张三是一个法外狂徒，每隔几天就要换新手机号，但又希望同伙能找到他。所以，张三一换号就告诉查号台自己的新号码。想联系的人只管对查号台说“我找张三”，虽然每次得到的号码可能都不一样，但接电话的肯定是张三本人。</p>
<p>这个例子中，查号台是DNS服务器，张三本人是网站，“张三”这个名字是域名，而张三的手机号就是IP地址——很容易理解吧？</p>
<p>所以，如果要实现DDNS，还需要一个域名。这个网站的域名“hakurei.red”正是我去年花16元在阿里云上注册的，主域名已经拿来做了博客，用子域名“shrine.hakurei.red”做DDNS正合适。</p>
<p>我使用的工具是GitHub上开源的<a href="https://github.com/xuchao1213/AliyunDdnsCSharp">xuchao1213/AliyunDdnsCSharp</a>。看名字就知道它由C#开发，干净得不得了，只要在配置文件里简单填上几项就能生成一个Windows服务，自动实现DDNS的功能。最棒的是，它支持IPv6。</p>
<h1>防火墙</h1>
<p>IP有了，域名也绑上了——接下来就测试下能不能从外网连接上吧。用Live Server把网站弄到890端口上试试？</p>
<p><code>ERR_CONNECTION_REFUSED</code></p>
<p>这是典型的防火墙问题。</p>
<p>在Windows防火墙里打开了对应端口的TCP和UDP连接——问题依旧。</p>
<p>在小米WiFi App的安全中心里关闭了各种防火墙——问题依旧。</p>
<p>没辙了。上网一查，原来小米路由器还有针对IPv6的防火墙，可是目前并没有界面给用户调。唯一的办法，是破解路由器的SSH连接，再连入路由器的Linux系统手动修改位于<code>/etc/config/firewall</code>的配置文件。类似的操作我曾经还真的做过好多次，那时是为了让路由器连接在纽约搭建的V2Ray服务器实现科学上网，因此这次也是驾轻就熟。</p>
<p>由于80等默认的WEB服务端口被运营商封锁，我选择了使用890端口。开启IPv6协议890端口的入站规则配置如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">config <span class="keyword">rule</span></span><br><span class="line">	<span class="keyword">option</span> src <span class="string">&#x27;wan&#x27;</span></span><br><span class="line">	<span class="keyword">option</span> <span class="keyword">family</span> <span class="string">&#x27;ipv6&#x27;</span></span><br><span class="line">	<span class="keyword">option</span> target <span class="string">&#x27;ACCEPT&#x27;</span></span><br><span class="line">	<span class="keyword">option</span> dest <span class="string">&#x27;lan&#x27;</span></span><br><span class="line">	<span class="keyword">option</span> <span class="type">name</span> <span class="string">&#x27;Allow-890&#x27;</span></span><br><span class="line">	<span class="keyword">option</span> dest_port <span class="string">&#x27;890&#x27;</span></span><br></pre></td></tr></table></figure>
<p>随后重新加载一下，让新规则生效：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/firewall reload</span><br></pre></td></tr></table></figure>
<p>接下来，只要我电脑上的服务器开着，就能通过<a href="http://shrine.hakurei.red:890">shrine.hakurei.red:890</a>访问到它了。</p>
<h1>Cloudreve</h1>
<p>端口已经成功打开，放点什么上去呢？</p>
<p>一开始，我尝试了最简单的静态文件服务器<a href="https://github.com/JacksonTian/anywhere">JacksonTian/anywhere</a>，把一些漫画和动画放了进去。但文件服务器毕竟是为了获取文件，不方便在线浏览，比如没法给漫画翻页，得一张张地打开；PDF文件更是必须完整下载然后在本地阅读。</p>
<p>还是整点复杂的吧——比如很多神秘网站使用的网盘系统<a href="https://github.com/cloudreve/Cloudreve">cloudreve/Cloudreve</a>。这个国产项目完全采用Material Design风格，几个月前还用Go语言重构，如今开箱即用，体验十分优良。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99595:/HRexs5kK2mGfo9n.png?authkey=AIbyrqnS5z58phc" alt="Cloudreve.png"></p>
<p>由于没有公共文件夹功能，我将自己上传的<a href="http://shrine.hakurei.red:890/#/s/EDHD">书库</a>通过分享链接贴在这里。能连上的话说明你运气不错，毕竟我不会时刻开着服务器，DDNS的更新也并不总是及时。</p>
<p>还是要说句：能不能好好上网？</p>
<p>下面这句话写于1987年，它其实并不是中国的第一封电子邮件，但它所代表的精神永远值得传承：</p>
<blockquote>
<p>Across the Great Wall we can reach every corner in the world.<br>
（越过长城，走向世界。）</p>
</blockquote>
]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code C语言开发环境配置</title>
    <url>/2020/09/01/VS-Code-C%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>由于安全上的要求，我司的开发环境比较复杂，涉及到Citrix非涉密/涉密桌面和远程Linux编译服务器等等，在这样的环境下用VS Code需要经过一系列的折腾，这篇文章简要记录了我最初的配置流程。</p>
<h1>安装VS Code</h1>
<p>首先，在非涉密桌面访问<a href="https://code.visualstudio.com/">VS Code官网</a>下载最新安装包，然后安装到<strong>Q盘中（重要！）</strong>。这是因为各种软件默认安装到的是被隐藏的C盘，而非涉密桌面环境中的C盘会在重启时被自动重置，你的软件就没了。</p>
<p>不要急着删除安装包，将它<strong>复制</strong>到T盘（直接剪切可能会报权限错误），转移到涉密桌面。如果之前你已经启动了涉密桌面，可以尝试用快捷键<code>Ctrl + Alt + Tab</code>进行切换。</p>
<p>到涉密桌面环境后，安装VS Code——这次可以装在C盘里，涉密桌面的C盘是不会被重置的。注意，安装时会有几个选项，询问是否要加入右键菜单以及PATH等，请把所有的勾都勾上。</p>
<h1>安装扩展</h1>
<p>众所周知，VS Code最重要的是扩展。由于涉密桌面没有外网，我们要安装扩展只能先从非涉密桌面下载，再通过T盘转移。</p>
<p>但是，VS Code默认存放扩展的目录在C盘，这导致非涉密桌面一旦重启，你的扩展就会全部消失。所以，装扩展之前要先更改非涉密桌面中VS Code存放扩展的目录。</p>
<p>我没有在设置里找到直接修改的方法，但你可以通过以下的方法来间接修改。</p>
<p>首先进入VS Code的安装目录（没忘记装在哪了吧），新建一个文件夹，命名为<code>extensions</code>。</p>
<p>在桌面上VS Code的快捷方式上右键打开属性（假如桌面上没有，就去安装目录里找到code.exe，右键发送-&gt;桌面快捷方式），找到<code>目标(T)</code>一栏，在已有内容的后面添上:</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="built_in">--extensions-dir</span> <span class="string">&quot;(你刚才创建的extensions文件夹的完整路径)&quot;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>这实际上是为VS Code设置了一个启动参数，说明要从你新建的这个<code>extensions</code>文件夹读取扩展，同时，你下载的扩展也会被放到这里。以后只要从这个快捷方式启动VS Code，不管重启VDI几次扩展都还在，因为extensions文件夹是在Q盘里的。</p>
<p>好了，接下来启动VS Code。</p>
<p>VS Code最左侧的边栏中有一个由四个方块组成的图标，那就是扩展管理。点击它后，你可以使用上面的搜索框寻找应用商店里的扩展，它们全都是托管在GitHub上的开源项目。</p>
<p>第一个要安装的是中文语言包，搜索<code>Chinese</code>就有了。安装之后，按<code>Ctrl + Shift + P</code>启动VS Code命令面板，输入<code>language</code>，选择<code>Configure Display Language</code>，将显示语言配置为<code>zh-cn</code>。重启VS Code，令人安心的中文就出来了。</p>
<p>第二个是<code>C/C++</code>扩展，它为C语言提供了IntelliSense代码补全、调试功能等等，搜索安装即可。安装完后，右下角还会出现一个小框，那是它正在安装几个依赖包。</p>
<p>第三个是<code>Code Runner</code>扩展，安装它之后你的编辑器窗口右上会有个播放键，点击就可以运行代码了。对于C语言，它会调用gcc编译器将代码编译运行。对它的使用我目前还不熟悉，安装聊胜于无。</p>
<p>第四个是<code>Bracket Pair Colorizer 2</code>，它将各组配对的括号用不同的颜色表示，</p>
<p>扩展安装全部完成之后，将你的<code>extensions</code>文件夹整个通过T盘复制到涉密桌面里VS Code的安装目录下。</p>
<p>最后，在涉密桌面的快捷方式里也设置一遍启动参数，启动VS Code，你会发现扩展已经全部转移过来了。</p>
<h1>安装编译器</h1>
<p>你还需要一个编译器才能将C语言源代码转换成可执行程序。</p>
<p>在Windows平台使用比较广泛的是MinGW，它包含了著名的GCC编译器。但是在公司的网络环境下，下载MinGW十分缓慢，有没有别的办法?</p>
<p>Dev-C++是一个开箱即用的轻便C/C++ IDE，它也内置了我们需要的GCC编译器。我们可以借此来个“曲线救国”。为了让下载快一点，你可以到腾讯软件中心的网页版下载其<a href="https://pc.qq.com/detail/16/detail_163136.html">镜像</a>，进入链接后选择“普通下载”即可。</p>
<p>安装时的安装语言列表可能会有乱码，先选择English。安装完成之后出现引导界面，就可以选择简体中文UI了。</p>
<p>为了方便地使用GCC编译器，应该将其添加到环境变量。</p>
<p>先来到Dev-C++的安装目录，找到<code>MinGW64\bin</code>文件夹，复制其路径。打开开始菜单，输入<code>env</code>就能快速导航到环境变量设置。将之前复制的路径粘贴到PATH环境变量的末尾，一路确定保存，再新开启一个命令行输入<code>gcc</code>试试。如果提示“fatal error: no input files”，就说明GCC的环境变量已经配置好了。</p>
<p>在VS Code中按<code>Ctrl + ~</code>(即键盘左上角Esc下面的那个键)可以开启内置终端。默认的终端是cmd，但你可以将其改为<code>pwsh</code>以使用几乎完全兼容cmd且功能强大得多的PowerShell。</p>
<h1>测试一下</h1>
<p>接下来，用VS Code打开一个文件夹，新建一个C语言源文件，随便写点什么，比如Hello World：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在终端中执行<code>gcc 源文件名 -o 输出文件名</code>，你的源码就被编译出来了。用命令行运行编译出的可执行文件，将在终端中输出<code>Hello World!</code>。</p>
<h1>最后</h1>
<p>以上就是VS Code的基本。要进行调试其实也是可以的，但那个配置起来也相当麻烦，是另一个故事了（我自己也还没配好，鸽了）。</p>
<p>顺带一提，为了快速插入代码规范要求的源文件/函数注释，可以使用VS Code的“代码片段”功能，按<code>Ctrl + Shift + P</code>启动VS Code命令面板，输入<code>snippet</code>配置用户代码片段，选择C语言，使用方法已经写在文件注释里了。</p>
<p>得益于大量的扩展，还有很多好玩的东西。比如SSH扩展能让你在VS Code中直接连到编译服务器，此时VS Code的终端就是远程Linux服务器的终端，左侧的资源管理器也可以管理Linux服务器的文件。由于在Windows 7一类的老版系统里没有内置OpenSSH，要实现这个还得折腾一回，这里给出两篇相关文章：</p>
<p><a href="https://www.mcclellandlegge.com/2017-02-24-installsshd/">Installing OpenSSH on Windows 7</a></p>
<p>如果依照上面的文章配置时出现问题，请看这里：</p>
<p><a href="https://blog.csdn.net/Mr_Cat123/article/details/103100174">vscode进行远程服务器 An SSH installation couldn’t be found</a></p>
]]></content>
      <tags>
        <tag>工具</tag>
        <tag>C</tag>
        <tag>折腾</tag>
      </tags>
  </entry>
  <entry>
    <title>WLAN笔记-壹</title>
    <url>/2020/09/10/WLAN-Note-1/</url>
    <content><![CDATA[<h1>WLAN历史</h1>
<p>WLAN是Wireless Local Area Network(无线局域网)的缩写，实际上就是要在不采用网线的情况下，提供以太网的互联功能。</p>
<p>我们更常见到的词是Wi-Fi(Wireless Fidelity, 无线保真)，但其实Wi-Fi是实现WLAN的技术之一，它遵循IEEE 802.11标准。实现WLAN的技术还可以是IrDA红外，Bluetooth蓝牙，HomeRF，乃至于GSM和LTE等，但Wi-Fi具有巨大的优势，以至于现在说到WLAN，基本就等于Wi-Fi。</p>
<p>Wi-Fi同时作为一个商标，被WiFi联盟WFA持有，新产品要通过Wi-Fi联盟的测试和认证后，才被允许使用“Wi-Fi”logo。这实际上是为了保证产品之间的兼容性。</p>
<p>Wi-Fi技术伴随着802.11标准演进。这一过程带来了更多的子载波、更高的调制方式、更高的编码率、更短的GI、更宽的带宽、还有MAC层的报文聚合等等。当然，它们的共同目的都是不断提升无线网络的吞吐量，降低时延。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99596:/SBMczewQtKh6NoU.jpg?authkey=AIbyrqnS5z58phc" alt="历代Wi-Fi"></p>
<span id="more"></span>
<h1>基本架构</h1>
<p>AP(Access Point，接入点)是Wi-Fi网络的中枢，它相当于有线网络中的集线器，把各个无线终端设备连接起来，在一般的使用场景中，AP就是无线路由器。</p>
<h2 id="FAT-AP"><a class="header-anchor" href="#FAT-AP">¶</a>FAT AP</h2>
<p>传统的Wi-Fi组网采用FAT AP架构，这种“胖”AP集Wi-Fi物理层，用户数据加密，用户认证，QoS，网络管理，漫游技术以及其他应用层的技术于一体，一台无线路由器干了所有的事。这种简单架构适合家庭用户，但并不适合进行大规模组网。</p>
<h2 id="FIT-AP"><a class="header-anchor" href="#FIT-AP">¶</a>FIT AP</h2>
<p>因此，又产生了FIT AP架构。它新增一个叫做AC(AP Controller，无线接入控制器)的网元,让AP不再做用户数据加密，认证等功能，而是把数据传到AC，由AC进行集中控制和管理。而剥离了许多功能的“瘦”AP设备就可以做得更方便部署。这种架构更容易搭建大型无线网络，提供更多的增值服务。</p>
<h1>安全策略</h1>
<h2 id="WEP"><a class="header-anchor" href="#WEP">¶</a>WEP</h2>
<p>WEP是Wired Equivalent Privacy有线等效加密。</p>
<p>WEP定义在IEEE 802.11标准中，采用RC4对称加密算法(已经不安全)，涉及链路认证和数据加密，不涉及接入认证和密钥协商。</p>
<p>链路认证就是我们输入Wi-Fi密码后，获取IP地址，建立数据链路的过程。WEP的链路认证分为开放系统认证(相当于没有密码)和共享密钥认证，且链路上的数据也会通过该密钥进行加密。</p>
<p>我们当然不能以明文的形式将密钥发送出去，那怎样进行终端设备和WLAN设备之间密钥的比对呢？如图所示，这个过程借助了“挑战短语”的技巧。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99597:/Zd7plsaz6RobQke.png?authkey=AIbyrqnS5z58phc" alt="共享密钥认证"></p>
<p>共享密钥用于加密数据的设计虽然简洁，但也带来了安全隐患：只要知道了WEP密钥，就可以对所有数据进行解密，也可以恶意构造虚假的数据帧。</p>
<p>链路认证完成之后，我们的设备虽然<strong>获取到了IP地址</strong>，但不一定能连接到其他设备和互联网，这涉及到的就是接入认证。对于在链路认证阶段采用开放系统认证的WEP AP，通常会在接入认证阶段使用MAC认证或Portal认证。</p>
<p>MAC认证与其说它是一种认证方式，不如说是一种访问控制方式。它直接使用终端设备的MAC地址作为凭据，而无需输入任何信息，但由于MAC地址很容易伪造，这种认证并不够安全。</p>
<p>Portal认证即Web认证，在用户接入时弹出认证页面，由认证服务器完成认证。这种认证方法需要终端设备上具备浏览器。</p>
<h2 id="WPA-WPA2"><a class="header-anchor" href="#WPA-WPA2">¶</a>WPA/WPA2</h2>
<p>由于WEP存在安全漏洞，现在使用更广的是WPA/WPA2加密方式。WPA采用提供密钥重置机制的临时密钥完整性协议TKIP，增强了安全性；加强版的WPA2所使用的CCMP协议以AES加密算法为核心，比TKIP更难破解。</p>
<p>WPA/WPA2在链路认证方面仅支持没有密码的开放系统认证，但引入了接入认证和密钥协商。</p>
<p>大型企业网络一般由专用的认证服务器进行802.1X接入认证方式，这种认证也可以用于有线的以太网。个人用户则主要采用预共享密钥模式，它与WEP的共享密钥认证类似，通过STA和WLAN设备端是否能够用密钥对协商的消息成功解密来确认双方配置的预共享密钥是否相同。但这个密钥仅仅用于认证过程，而不用于数据加密，不会导致WEP中严重的安全问题。</p>
<p>那么，WPA/WPA2如何进行数据加密呢？这就涉及到了密钥协商机制。</p>
<p>根据接入认证阶段生成的成对主钥PMK(Pairwise Master Key)产生成对临时密钥PTK(Pairwise Transient Key)和群组临时密钥GTK(Group Temporal Key)。其中，PTK用来加密单播报文，GTK用来加密组播和广播报文。经过了上述重要过程后，通信双方就开始了经过加密处理后的数据传输。加密算法使用TKIP或AES，加密密钥使用密钥协商阶段协商出的密钥。</p>
<p>到这里，WLAN似乎已经很安全，然而仍有一个大问题没有解决：WLAN设备端知道如果我们没有正确的密码，就不是应该连入的人；但我们对于要连接的WLAN设备端，可以说是一无所知——我们能知道的只有热点的名称SSID，而这玩意是可以随便伪造的。这就为钓鱼攻击提供了切入点，如今的“钓鱼Wi-Fi”和“伪基站”也正是利用了这个缺陷。</p>
<h2 id="WAPI"><a class="header-anchor" href="#WAPI">¶</a>WAPI</h2>
<p>和TD-SCDMA一样，WAPI也是早年中国搞的“自主知识产权”。它现在基本已经凉凉，如果你是iOS用户，兴许还曾在设置中见过这个奇怪的选项。诺基亚时代，懂行的都知道要买“港水”、“亚太”，就是因为大陆正版国行机被阉割了WLAN功能，这件事就与WAPI脱不了干系。</p>
<p>换在以前，我以为WAPI是和大名鼎鼎的“火星坐标系”GCJ02一样徒增烦恼的玩意，对WAPI满腹牢骚，并且开始反思这国怎定体问云云。但其实在技术层面上，WAPI是一个比WPA要超前的标准，它的核心是<strong>数字证书</strong>和<strong>SMS4加密算法</strong>，并且用引入鉴别服务器的<strong>三元架构</strong>设计解决了传统Wi-Fi的二元架构下容易遭受钓鱼攻击、中间人攻击的问题，具有极高的安全性。</p>
<p>关于WAPI的故事非常复杂，科研机构、IEEE、ISO、政府、运营商、硬件厂商、境外势力多方博弈，才造就了今天走802.11i路线的Wi-Fi一统天下，而WAPI潜伏于阴影的局面。最后在这里贴出几篇文章，有助于快速了解那段历史。</p>
<ol>
<li><a href="https://www.ctocio.com/hotnews/22804.html">国际标准战争的技术真相 - 奥卡姆剃刀</a></li>
<li><a href="https://www.zhihu.com/question/32032171/answer/54616292">2G时代的手机不准有 Wi-Fi 这个规定是怎样被废除的？ - 老姜装嫩的回答 - 知乎</a></li>
<li><a href="https://www.zhihu.com/question/66100012/answer/952759096">wapi真的很差么？为什么现在还有很多人喷这个？ - 老爷的回答 - 知乎</a></li>
</ol>
]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>笔记</tag>
        <tag>标准</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核内存问题定位</title>
    <url>/2021/04/13/Linux%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1>定位linux内存异常问题思路</h1>
<h2 id="内存访问异常"><a class="header-anchor" href="#内存访问异常">¶</a>内存访问异常</h2>
<ul>
<li>空指针访问：常见，易解决</li>
<li>“踩内存”：对不属于你的内存进行读写，难点在于踩内存发生的时间与程序崩溃的时间没有任何关系</li>
</ul>
<h2 id="被踩内存-踩内存的关系分类"><a class="header-anchor" href="#被踩内存-踩内存的关系分类">¶</a>被踩内存/踩内存的关系分类</h2>
<ol>
<li>越界踩内存<br>
定义或申请的内存小了</li>
<li>使用已释放的内存<br>
释放掉的内存又被使用</li>
<li>随机踩内存（最难排查）<br>
踩坏的位置与使用的内存没有直接关系，每次崩溃的情况可能都不一样</li>
</ol>
<h2 id="被踩坏内存的位置分类"><a class="header-anchor" href="#被踩坏内存的位置分类">¶</a>被踩坏内存的位置分类</h2>
<ol>
<li>堆踩坏<br>
<code>malloc/new/kmalloc/vmalloc</code>申请的内存</li>
<li>栈踩坏</li>
<li>全局变量踩坏</li>
</ol>
<h2 id="被踩坏内存的内容分类"><a class="header-anchor" href="#被踩坏内存的内容分类">¶</a>被踩坏内存的内容分类</h2>
<ol>
<li>字符串</li>
<li>指针</li>
<li>随机值</li>
</ol>
<span id="more"></span>
<h2 id="测试手法分类"><a class="header-anchor" href="#测试手法分类">¶</a>测试手法分类</h2>
<ol>
<li>测试某些模块</li>
<li>测试某些场景</li>
</ol>
<h2 id="多次复现观察的结果分类"><a class="header-anchor" href="#多次复现观察的结果分类">¶</a>多次复现观察的结果分类</h2>
<ol>
<li>踩坏位置固定<br>
用MMU保护，产生段错误，抓到发生问题时的调用栈</li>
<li>踩坏位置的内存类型固定<br>
位置在变，但总是堆或栈内存被踩坏</li>
</ol>
<h1>Backtrace介绍及使用</h1>
<p>程序异常退出时，列出当前函数调用关系</p>
<p>博通使用的glibc支持backtrace；MTK/RTL的MIPS平台使用uclibc，占用内存小但没有backtrace。</p>
<p>ARM平台，进程要接管<code>SIGSEGV</code>信号处理。</p>
<p>需要一些编译选项：</p>
<ul>
<li><code>-rdynamic</code></li>
<li><code>-funwind-tables</code></li>
<li><code>-ffunction-sections</code></li>
</ul>
<h1>coredump介绍及使用</h1>
<p>程序异常终止/崩溃时，操作系统会生成程序的内存快照，保存在一个文件中。</p>
<p>coredump的相关设置：</p>
<p><code>ulimit -c</code> 查看可生成的core文件的大小，默认为0</p>
<p><code>ulimit -c &#123;filesize&#125;</code> 设置core文件大小，可以设为unlimited</p>
<p>生成的core文件可以用gdb来调试</p>
<h1>ASAN介绍及使用</h1>
<p>内存错误探测工具AdressSanitizer，与其它几种Sanitizer一并为LLVM的一部分，也包含在GCC编译器中。</p>
<p>以前常用的valgrind会导致程序性能下降到十几分之一，ASAN则只降低一半。</p>
<h2 id="工作原理"><a class="header-anchor" href="#工作原理">¶</a>工作原理</h2>
<ol>
<li>
<p>运行时库<br>
不是踩内存发生后检查内存被谁踩了，而是通过运行时库<code>libasan.so</code>接管<code>malloc</code>和<code>free</code>函数。<br>
这两个函数执行完后，ASAN会在操作内存区域的前后多分配一块内存，称为“红区”(RedZone)，标记为“中毒”状态，这些区域发生访存时立刻就会被检测出来。</p>
</li>
<li>
<p>编译器插桩模块<br>
加入了ASAN相关的编译选项后，代码中的每一次内存访问操作都会被编译器改动。</p>
</li>
<li>
<p>对虚拟内存的划分</p>
<ul>
<li>主应用内存区（Mem）<br>
给普通APP代码使用的内存</li>
<li>影子内存区（Shadow）<br>
仅ASAN可感知的内存区域，将主应用内存区的每8个byte映射成1个byte，记录这一段中可用的byte数，全部可用记作<code>0</code>，全部不可用记作<code>-1</code>。</li>
</ul>
</li>
</ol>
<h2 id="优缺点"><a class="header-anchor" href="#优缺点">¶</a>优缺点</h2>
<ol>
<li>不存在误报可能，只可能漏报</li>
<li>目前只有博通平台满足ASAN的运行环境</li>
<li>需要额外消耗内存和CPU，也会增加代码大小</li>
<li>ASAN只能检测出踩到RedZone的情况，如果越界过分离谱，还是会被漏掉</li>
<li>使用已释放的内存时，由于ASAN的隔离区具有大小限制（FIFO），有些释放较早的内存被踩时不会被检测到</li>
</ol>
<h2 id="如何使用"><a class="header-anchor" href="#如何使用">¶</a>如何使用</h2>
<p>GCC4.8之后的版本包含ASAN。</p>
<p>编译选项：</p>
<ul>
<li><code>-fsanitizer-address</code></li>
<li><code>-fno-omit-frame-pointer</code></li>
<li><code>-O1</code>，或者更高的优化级别编译</li>
</ul>
<p>链接时需要加<code>-lasan</code>。</p>
<p>还需要把运行时库libasan.so拷贝进设备文件系统。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C#杂记之陆：真·杂记</title>
    <url>/2022/02/07/C-%E6%9D%82%E8%AE%B0%E4%B9%8B%E9%99%86%EF%BC%9A%E7%9C%9F%C2%B7%E6%9D%82%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>注：以下文稿写于2020年，虽未完整，为了不卡杂记的序号，还是发出来了。<br>
日后会在这里添加更多内容，也可能另起一篇拾遗（</p>
</blockquote>
<p>这一篇是真正的“杂”记。这段时间在刷LeetCode的同时，阅览了一些Java中常见的问题，鉴于Java与C#的殊途同归，也有了些收获。</p>
<p>为查漏补缺，将之前理解还不够明了的部分记在这里，主要是涉及OOP思想的一些概念。</p>
<h1>关于多态</h1>
<p>面向对象设计有四大特征：</p>
<ul>
<li>抽象：通过类和接口的属性与方法实现</li>
<li>继承：通过类和接口的继承实现</li>
<li>封装：通过访问控制符实现</li>
<li>多态：？？？</li>
</ul>
<p>多态这个概念比较神秘。以前看到一个解释是这么说的：</p>
<blockquote>
<p>继承是子类引用父类方法；多态是父类引用子类方法。</p>
</blockquote>
<p>当时看了觉得有点奇怪，父类怎么能引用子类方法呢？现在我的理解是如下：</p>
<p>子类对象<strong>继承</strong>了父类方法，但是可能又对继承过来的父类方法进行了<strong>重写</strong>覆盖。而一切出现父类的地方都可以用其子类<strong>向上转型</strong>进行替换(里氏替换原则)，调用方法时调用的会是在子类里被重写的子类方法。继承、重写和向上转型，这是实现多态的三要素。</p>
<p>这样，如果一个父类有多个子类，它们又分别用不同方式重写了继承下来的同一个方法，那么在把这些子类都当父类使用时，就会展现出多态性：明明是对同一个类的对象调用了同一个方法，但行为却完全不同。</p>
<p>举个例子，假如有个<code>扬声器</code>类，包含一个<code>大叫()</code>方法，调用时会“嘤嘤嘤”；而继承自它的有大叫“洒↓比↑”的<code>喇叭</code>类和大叫“哼，哼，啊啊啊啊啊啊啊”的<code>野兽先辈</code>类：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这段代码甚至真的可以跑，C#支持用汉字做标识符，大概是因为用了Unicode</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">PlayGround</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> 扬声器</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> 大叫() =&gt; Console.WriteLine(<span class="string">&quot;嘤嘤嘤&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> 喇叭 : 扬声器</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> 大叫() =&gt; Console.WriteLine(<span class="string">&quot;洒↓比↑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> 野兽先辈 : 扬声器</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> 大叫() =&gt; Console.WriteLine(<span class="string">&quot;哼，哼，啊啊啊啊啊啊啊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> 屑狐狸 : 扬声器</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> 大叫() =&gt; Console.WriteLine(<span class="string">&quot;呜呜呜呜，好可怜啊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> 一堆扬声器 = <span class="keyword">new</span> List&lt;扬声器&gt;() &#123; <span class="keyword">new</span> 扬声器(), <span class="keyword">new</span> 喇叭(), <span class="keyword">new</span> 野兽先辈(), <span class="keyword">new</span> 屑狐狸() &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> 某个扬声器 <span class="keyword">in</span> 一堆扬声器)</span><br><span class="line">            &#123;</span><br><span class="line">                某个扬声器.大叫();</span><br><span class="line">                <span class="comment">// 输出：</span></span><br><span class="line">                <span class="comment">// 嘤嘤嘤</span></span><br><span class="line">                <span class="comment">// 洒↓比↑</span></span><br><span class="line">                <span class="comment">// 哼，哼，啊啊啊啊啊啊啊</span></span><br><span class="line">                <span class="comment">// 呜呜呜呜，好可怜啊</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>不过，另外有一种操作是“成员隐藏”，在派生类中用<code>new</code>修饰符对基类已有的成员重新进行定义，在这种情况下体现不出多态，因为向上转型时调用的仍然会是基类已经定义的成员。</p>
<p>在竞技世界面试中，还被问到这样一个问题：<strong>多态的实现方法是什么？</strong></p>
<p>我确实没搞明白什么叫“实现方式”，于是按照上面的部分答了，但那其实是多态存在的必要条件。</p>
<p>其实现在理解来，实现方式就是指什么情况下会体现出多态。</p>
<p>方式一是重写，就像上面代码中的例子；方式二是接口，不同类对接口中方法的实现不同造成多态；方式三是抽象类和抽象方法，子类对抽象方法进行重写时的实现不同造成多态。</p>
<p>（其实我对着这几句话想了半天，觉得它们说的几乎是同一件事……）</p>
<h1>关于接口和抽象类的区别</h1>
<p>这两个都是无法被实例化的东西。</p>
<p>在较早版本的Java中，接口仅包含公有属性和方法，而且方法全部都是隐式抽象方法，没有任何实现，也不可以定义静态方法，仅仅是对实现接口的类的一种规约。</p>
<p>但在Java 8之后可以定义静态方法，而且方法还可以有方法体了。</p>
<p>C#情况也差不多，接口里可以包含方法(包括static方法)、属性、索引器、事件的声明。原本的接口完全是抽象的，不包含任何实现代码。</p>
<p>但和Java一样，从C# 8.0开始，接口可以为成员定义默认实现了。</p>
<p>这么看来，如今接口和抽象类的区别正变得不是那么大，但它们的设计目的始终是不变的：<strong>接口用来进行“有”约束，抽象类用来进行代码复用。</strong></p>
<p>不过文档里有句话让我比较在意：</p>
<blockquote>
<p>接口不能声明实例数据，如<strong>字段</strong>、自动实现的属性或类似属性的事件。</p>
</blockquote>
<p>字段和属性有什么区别？</p>
<h1>属性Property和字段Field</h1>
<p>以前在学习C++和Java的时候，我往往把“属性”和“数据成员”当作同一种东西，而且它们在课本上表现得确实就是同一种东西。但在实际的语言中，数据成员被称为<strong>字段</strong>，和属性有一些不同。</p>
<p>字段就像SQL里所表述的，它是真正承载数据的部分。一般情况下，我们趋向于不直接暴露字段，而是将它设为<code>private</code>。在命名规范上，字段一般使用驼峰命名法，即第一个单词首字母小写，其它首字母大写。由于字段一般是私有的，命名上往往还会加上下划线前缀，如<code>private string _myField</code>。</p>
<p>属性其实是上一篇中所提到的get/set访问器的外壳。它自己不承载数据，而是将字段暴露给外界进行读/写，更像是一种方法。属性对应的字段被称为属性的“后备变量”。属性和方法一样采用帕斯卡命名法，即每个单词的首字母都大写。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> _myField;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> MyProperty</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _myField;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        _myField = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此延伸出的是<strong>自动属性</strong>，这是在属性的访问器不需要进行特别的定义时使用的。实际上，上面的例子就可以使用自动属性：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> MyProperty&#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>自动属性当然不是没有对应的字段，而是由编译器自动创建了一个隐藏的后备变量。</p>
<p>使用属性而不是直接使用字段的一个好处是，你可以给get/set单独设置访问控制符，甚至可以不设置set访问器，使其成为只读属性：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使set访问器为private</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> MyProperty&#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只读属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> MyProperty&#123; <span class="keyword">get</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>另外，还可以在用属性读写字段的过程中做一些别的操作，比如验证值的合法性，就不举例了。</p>
<h1>常量const和只读readonly</h1>
<p>被<code>const</code>和<code>readonly</code>修饰的字段都不能被修改，但它们也有区别。</p>
<p><code>const</code>常量是在<strong>编译时</strong>被编译器确定，用其值取代了所有使用到它的地方，类似于C语言的宏定义。</p>
<p>而<code>readonly</code>的值是在<strong>运行时</strong>被构造函数决定的，它仍然是个变量，只不过它的值只能在构造函数中分配。对于引用类型，<code>readonly</code>会使其自始至终只引用同一个实例，但实例本身可以修改。比如一个<code>readonly</code>的<code>List&lt;T&gt;</code>，不能在构造函数之外对其直接赋值，但是可以调用它的Add()方法，向其中添加元素。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">readonly</span> List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        list.Add(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 报错，无法对静态只读字段赋值(静态构造函数或变量初始值中除外)</span></span><br><span class="line">        list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这类似于C语言的指针常量：指针本身，即 <strong>“指针指向的是什么地址”</strong> 不能修改，但 <strong>“指向的地址上写了什么东西”</strong> 是可以修改的。</p>
<h1>宏、条件编译</h1>
<p>注意，<strong>C#没有宏定义这一机制！</strong></p>
<p>确切地说，C#的预处理器不会像C语言一样，将源代码的内容根据宏定义进行替换。像<code>#define ...</code>这样的预处理器指令，并不是用来进行宏定义的，它仅仅用于设置条件编译符号。而且，这些符号也不能像在C语言中一样被分配值。</p>
<p>条件编译符号还可以通过系统环境变量、编译器命令行选项提供。</p>
<p>条件编译符号的使用场景当然是条件编译。配合另外几条预处理器指令，可以选择一定情况下编译哪些代码：</p>
<ol>
<li>#if：开始条件编译代码块，仅在定义了指定的符号时，才会编译其中的代码。</li>
<li>#elif：结束前面的条件编译代码块，并基于是否定义了指定的符号，开始一个新的条件编译代码块。</li>
<li>#else：结束前面的条件编译代码块，如果没有定义前面指定的符号，开始一个新的条件编译代码块。</li>
<li>#endif：结束前面的条件编译代码块。</li>
<li>#undef：取消符号的定义。</li>
</ol>
<p>比如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意符号的定义和取消要放在文件最前面</span></span><br><span class="line"><span class="comment">// #define DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VC7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Debug build&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> VC7</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Visual Studio 7&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;No symbol defined&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出&quot;Visual Studio 7&quot;</span></span><br></pre></td></tr></table></figure>
<p>另外，还有通过特性attribute实现条件编译的方法。具体在下一篇的特性部分记录。</p>
<!-- # CLR内存机制

C#实际上并不需要怎么关心内存管理，自动垃圾收集非常强大。但是要细说的话内容太多了，之后单独用一片来讲。

# 指针和引用的区别

指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。


# 异常处理



# 生命周期



# using


> 在公司太久没机会写代码，手痒，想要重拾C#，去开源社区做“第二份工作”了。      
> 语言特性不用就会生疏，我用以复健的工具是《深入解析C# (第4版)》， -->
]]></content>
      <tags>
        <tag>C Sharp</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C#杂记之柒：特性与反射</title>
    <url>/2022/02/14/CSharpNote7-AttributeAndReflection/</url>
    <content><![CDATA[<p>其实19年在实习期间写CFET的时候，就有用到过Attribute这个特性<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，但当时并没有研究过它的作用和原理，只是照着文档给的案例使用。最近准备看看Unity中是如何用Lua实现热更新的，发现attribute满天飞，这就不得不理解一下了。</p>
<p>简单看了看，attribute似乎和反射息息相关，正好反射这块我也不太了解，这次就将一些相关的概念一并记录吧。</p>
<h1>特性 Attribute</h1>
<p>特性是一种标签，可以用方括号贴在各种元素<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>之前，给这些元素添加<strong>元数据</strong>。元数据包括编译器指令、注释、描述、方法、类等信息。</p>
<p>许多特性都附带一些参数，如在声明<code>element</code>的时候，通过带参的attribute附加元数据，按下面的格式使用：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">SomeAttribute(positional_parameters, name_parameter = value, ...)</span>]</span><br><span class="line">element</span><br></pre></td></tr></table></figure>
<p>特性实际上是<code>System.Attribute</code>的一系列派生类，它们的后缀均为&quot;Attribute&quot;，在打标签的时候这个后缀可以省略掉。</p>
<h2 id="预定义的Attribute"><a class="header-anchor" href="#预定义的Attribute">¶</a>预定义的Attribute</h2>
<p>微软在.NET库里已经内置了一堆<code>System.Attribute</code>的派生类，我们可能只会接触到其中一小部分，这里举几种常用的为例。</p>
<h3 id="ObsoleteAttribute"><a class="header-anchor" href="#ObsoleteAttribute">¶</a>ObsoleteAttribute</h3>
<p><code>Obsolete</code>用于指示过时、弃用的元素。这些元素被认为不应该使用，因此在有调用到这种元素的地方，会产生Warning，并且附带参数<code>message</code>所包含的提示信息。如果建议使用某种新方案，就可以写在提示信息里。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99601:/tkSGJRc4mFe1w2y.png?authkey=AIbyrqnS5z58phc" alt="对过时元素告警"></p>
<p>另外，还有可选的第二个参数<code>iserror</code>，如果被设置为<code>true</code>，则会产生Error而不是Warning，阻止编译。</p>
<span id="more"></span>
<h3 id="ConditionalAttribute"><a class="header-anchor" href="#ConditionalAttribute">¶</a>ConditionalAttribute</h3>
<p><code>Conditional</code>用于进行条件编译，只有参数中所记录的符号有定义时，才编译相关的代码。</p>
<p>不过，这个attribute只适用于<code>System.Attribute</code>的派生类（也就是各种attribute），以及返回类型为<code>void</code>的方法。毕竟，比起它们来说，如果不编译其它的类，或者那些提供了返回值的方法，程序更有可能会整个垮掉。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">undef</span> DEBUG</span></span><br><span class="line"><span class="comment">//#define TEST_SYMBOL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Conditional可以附加多个，满足其中一个条件即可</span></span><br><span class="line">    [<span class="meta">Conditional(<span class="string">&quot;DEBUG&quot;</span>), Conditional(<span class="string">&quot;TEST_SYMBOL&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DebugMessage</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;[DEBUG] <span class="subst">&#123;DateTime.Now.ToString()&#125;</span> <span class="subst">&#123;msg&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//由于取消了DEBUG的定义，也没有定义TEST_SYMBOL，故什么都不会打印</span></span><br><span class="line">        Myclass.DebugMessage(<span class="string">&quot;In function Main now.&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AttributeUsageAttribute"><a class="header-anchor" href="#AttributeUsageAttribute">¶</a>AttributeUsageAttribute</h3>
<p><code>AttributeUsage</code>可以放在我们自定义的attribute类前面，用来规定该如何使用这种attribute。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(</span></span><br><span class="line"><span class="meta">   validon,</span></span><br><span class="line"><span class="meta">   AllowMultiple=allowmultiple,</span></span><br><span class="line"><span class="meta">   Inherited=inherited</span></span><br><span class="line"><span class="meta">)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyTestAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>必选参数validon规定该attribute适用于哪些元素。它是枚举器AttributeTargets的值的组合。默认值是AttributeTargets.All。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99602:/rpK4QE1bgGWxzVC.png?authkey=AIbyrqnS5z58phc" alt="各种AttributeTargets"></p>
<p>还有两个bool型的可选参数：</p>
<p><code>AllowMultiple</code>: 默认为false，表示这个attribute是否可以像<code>Conditional</code>一样，在同一个元素上打多个标签。给元素打标签其实是调用了对应attribute类的构造函数，并将实例加入到目标元素的元数据里去，所以这里就是是否允许多个实例在同一元素的元数据里共存。</p>
<p><code>Inherited</code>: 默认为true这个attribute是否可以被继承。</p>
<h2 id="自定义的Attribute"><a class="header-anchor" href="#自定义的Attribute">¶</a>自定义的Attribute</h2>
<p>既然attribute是一系列继承自<code>System.Attribute</code>的类，我们也可以编写它的派生类，实现自己的attribute。</p>
<p>如何正确地设计一个attribute？</p>
<ol>
<li>应用<a href="#attributeusageattribute">AttributeUsage</a>，规定该attribute的用法</li>
<li>声明<code>System.Attribute</code>的派生类，并且名称以&quot;Attribute&quot;结尾（命名规范，非强制）</li>
<li>声明构造函数</li>
<li>声明属性</li>
</ol>
<p>注意，attribute应该被视为一种逻辑状态的容器，因此设计时应该尽量保持简单，不应提供公共方法、事件等等。以下是微软文档中给出的自定义attribute示例，其中包含带两个参数的构造函数，三个字段，三个对应的属性：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.All)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DeveloperAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Private fields.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> level;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> reviewed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This constructor defines two required parameters: name and level.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeveloperAttribute</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">string</span> level</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">        <span class="keyword">this</span>.reviewed = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define Name property.</span></span><br><span class="line">    <span class="comment">// This is a read-only attribute.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define Level property.</span></span><br><span class="line">    <span class="comment">// This is a read-only attribute.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">string</span> Level</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;<span class="keyword">return</span> level;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define Reviewed property.</span></span><br><span class="line">    <span class="comment">// This is a read/write attribute.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="built_in">bool</span> Reviewed</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;<span class="keyword">return</span> reviewed;&#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;reviewed = <span class="keyword">value</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难看出，这个attribute用于标记一个元素的作者信息和评审状态。也许你会疑惑，这个attribute的构造函数只有两个关于作者信息的参数，如何指定评审状态Reviewed呢？</p>
<p>其实，被方括号括起来的标签和attribute的构造函数并不完全一样，我们可以将Reviewed作为可选参数传入：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">Developer(<span class="string">&quot;Macyrate&quot;</span>, <span class="string">&quot;Junior&quot;</span>, Reviewed = true)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hello</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hello</span>(<span class="params"><span class="built_in">int</span> just_a_number, <span class="built_in">string</span> just_a_string</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;Hello World! And just some info: <span class="subst">&#123;just_a_number&#125;</span> <span class="subst">&#123;just_a_string&#125;</span>.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编译器对Attribute的处理"><a class="header-anchor" href="#编译器对Attribute的处理">¶</a>编译器对Attribute的处理</h2>
<p>当C#编译器发现有元素应用了一个attribute时，根据其名称是否以&quot;Attribute&quot;结尾，编译器会决定是否把字符串&quot;Attribute&quot;追加到后面，然后在其搜索路径的所有名称空间中搜索符合指定名称的类。</p>
<p>找到对应的类，并确定该类派生自<code>System.Attribute</code>后，编译器会根据其<code>AttributeUsage</code>，看该attribute的用法是否正确。如果合法，编译器就会开始进一步处理attribute的参数。</p>
<p>编译器会根据传递给attribute的参数，查找对应的构造函数。编译器还会查找attribute类中存在的<strong>public属性/字段</strong>，将它们作为可选参数。如果编译器找到一个这样的构造函数，传入的可选参数也合法，编译器就会把指定的元数据传递给程序集。否则，就生成一个编译错误。</p>
<p>现在，我们知道了如何通过attribute给元素附加元数据。但是仅仅将这些元数据写入是没什么意义的，我们还需要依靠<strong>某种机制</strong>来读出元数据，并且用它们来控制代码逻辑，这样才能实现有意义的功能。</p>
<p>而这种读取元数据的机制，就是<strong>反射</strong>（Reflection）。</p>
<h1>反射 Reflection</h1>
<h2 id="Type类"><a class="header-anchor" href="#Type类">¶</a>Type类</h2>
<p>Type类表示“对类型的引用”，可以说是反射的核心。它包含了类类型、接口类型、数组类型、值类型、枚举类型、类型参数、泛型类型定义，以及开放或封闭构造的泛型类型。</p>
<p>针对一个类型将Type类实例化时，实际上是生成了某个Type派生类的对象（Type类对所有的类型都有相应的派生类），这个对象包含类型的具体信息。要获取关于某个类型的Type实例，主要有以下几种方法：</p>
<ol>
<li><code>typeof()</code>运算符</li>
<li>所有类型都具备的<code>GetType()</code>方法（从Object继承）</li>
<li><code>Type</code>类静态方法<code>GetType()</code></li>
</ol>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99603:/SPMU3j6z8oJWqvx.png?authkey=AIbyrqnS5z58phc" alt="Type类"></p>
<p>可以看到，<code>Type</code>中除了基本的类型名称、继承自的类、声明所属的namespace等信息，还有大量的bool值，表示这个类型的各种特点，如是否为数组，是否抽象，是否支持泛型等等。</p>
<h2 id="读取元数据"><a class="header-anchor" href="#读取元数据">¶</a>读取元数据</h2>
<p>首先我们需要了解元数据的组织层级，如下图所示。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99604:/YKkcw3hN6sfaHvn.png?authkey=AIbyrqnS5z58phc" alt="元数据层级"></p>
<p>从Type往下都很好理解，字段、属性、事件、方法/构造函数、以至于方法的参数，它们都有对应的以Info结尾的类让我们获取元数据。</p>
<p>至于Type上面的Assembly和Module，分别称为程序集和托管模块，它们都具备<code>GetTypes()</code>方法，能以<code>Type</code>数组的形式获取到自己内部的所有类型。关于程序集和托管模块之间的区别和联系，涉及到C#的编译、链接流程等等，具体可以查看<a href="https://stackoverflow.com/questions/9271805/net-module-vs-assembly">StackOverflow上的这个问题</a>。这里我们只需要知道，C#最终生成的.exe或者.dll文件就是程序集，其中包含了一块称为<code>manifest</code>的清单元数据，描述了程序集的名称、版本号、区域性信息以及所包含的文件等等。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99605:/BnUMgNFYp3ljPuR.png?authkey=AIbyrqnS5z58phc" alt="托管模块和程序集"></p>
<p>以<code>Type</code>类为中心，我们就可以读取到各种各样的元数据，以此在运行时针对类型本身，或者类型所附加的attribute来进行逻辑控制。</p>
<p>以下是一些<code>Type</code>类最为常用的方法，需要注意反射所用的方法基本都有一大堆各种各样的重载，适应各种用途：</p>
<ol>
<li>GetMembers() 返回一个MemberInfo[]，获取所有成员信息</li>
<li>GetCustomAttributes<T>() 尝试获取参数T表示的Attribute（如果没有则返回null）</li>
<li>针对每个成员的MemberInfo，可以通过MemberType获取成员的种类</li>
<li>针对MemberType为Method的成员，可以将其用<code>as</code>运算符转换为<code>MethodInfo</code>（它派生自MemberInfo）</li>
<li>针对每个方法的MethodInfo，可以使用GetParameters()获取参数的类型、名称等信息</li>
</ol>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99606:/E6H2RXZ1rVOmuvB.png?authkey=AIbyrqnS5z58phc" alt="对Type类GetMembers()"></p>
<h2 id="示例：读取Attribute中的属性"><a class="header-anchor" href="#示例：读取Attribute中的属性">¶</a>示例：读取Attribute中的属性</h2>
<p>在前面我们自定义了一个<a href="##%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84Attribute">DevelopAttribute</a>。</p>
<p>现在，我们可以通过反射读取到标签中的信息：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99607:/jFEJ4Al5fuP2Y6b.png?authkey=AIbyrqnS5z58phc" alt="反射读取attribute"></p>
<blockquote>
<p>当然，反射不仅仅有读取元数据的功能。其另一方面的魅力是，可以在运行时为那些编译时完全不知道的类型创建实例。</p>
<p>另外，通过<code>dynamic</code>实现的动态编程也与反射有一定的关系，此处暂时不展开了。</p>
</blockquote>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>C#文档里将attribute译作“特性”，为避免混淆本文全部使用attribute。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>能够使用attribute的元素包括程序集（即.exe或者.dll）、类型、方法、属性等。 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>Schult, Wolfgang &amp; Polze, Andreas. (2002). Aspect-Oriented Programming with C # and .NET. 241 - 248. 10.1109/ISORC.2002.1003711. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <tags>
        <tag>C Sharp</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义的==运算符，我们应该保留吗？</title>
    <url>/2022/03/16/UnityCustomEqualOperator/</url>
    <content><![CDATA[<blockquote>
<p>该文章译自Unity官网博客，原文：<a href="https://blog.unity.com/technology/custom-operator-should-we-keep-it">Custom == operator, should we keep it?</a></p>
<p>TL;DR: Unity的<code>==</code>是魔改版，与原生C#里的行为不一样。所以不要对<code>UnityEngine.Object</code>派生出的任何东西（包括<code>MonoBehaviour</code>）使用C#的空值相关语法糖，包括<code>?.</code>，<code>??</code>，<code>??=</code>等等（三元运算符可以用），而应该老老实实使用<code>== null</code>来判空。</p>
</blockquote>
<h1>正文</h1>
<p>当你在Unity中进行这样的操作时：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (myGameObject == <span class="literal">null</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Unity对<code>==</code>运算符做了一些特殊处理。与大多数人所期望的不同，我们对<code>==</code>运算符有一个特殊实现。</p>
<p>这样做是为了达到两个目的：</p>
<ol>
<li>当一个<code>MonoBehaviour</code>有字段时，仅仅在编辑器中<sup>1</sup>，我们不会将这些字段设置为“真null”，而是设置为一个“假null”对象。我们自定义的<code>==</code>操作符能够检查某物是否是这种假null，并采取相应的行为。虽然这种机制怪怪的，但它能让我们在假null中存储信息，这样当你对它调用一个方法，或者读取一个属性时，它可以给你更多的上下文信息。如果没有这个技巧，你只会得到一个<code>NullReferenceException</code>，一个堆栈跟踪，但你不知道到底哪个<code>GameObject</code>的<code>MonoBehaviour</code>的字段是空的。而有了这个技巧，我们就可以在检查器中突出显示<code>GameObject</code>，也可以给你更多的提示：“看起来你正在访问这个<code>MonoBehaviour</code>中的一个未初始化的字段，请用Inspector将这个字段指向某个东西”。</li>
</ol>
<span id="more"></span>
<p>目的二就有点复杂了：</p>
<ol start="2">
<li>当你得到一个<code>GameObject</code>类型的C#对象时<sup>2</sup>，它几乎什么都不包含。这是因为Unity引擎是一个C/C++引擎。<code>GameObject</code>的所有实际信息（名称、Component列表、HideFlags等）都在C++端。C#对象只有一个指向本地对象的指针。我们称这些C#对象为“包装对象”。这些C++对象的生命周期，如<code>GameObject</code>和其他所有从<code>UnityEngine.Object</code>派生的对象，都是被明确地托管的。当你加载一个新场景，或者当你对它们调用<code>Object.Destroy(myObject);</code>时，这些对象会被销毁。C#对象的生命周期通过垃圾回收以C#的方式管理。这意味着可能有一个仍然存在的C#包装对象，包装着已经被销毁的C++对象。如果你把这个C#对象和null进行比较，我们自定义的<code>==</code>操作符在这种情况下会返回<code>true</code>，尽管实际的C#变量实际上并不是真正的null。</li>
</ol>
<p>虽然这两个理由非常合理，但自定义判空也带来了一堆缺点。</p>
<ul>
<li>违反直觉。</li>
<li>将两个<code>UnityEngine.Object</code>互相比较或者与<code>null</code>比较，比你想象中的要慢。</li>
<li>自定义的<code>==</code>运算符不是线程安全的，所以你不能在主线程之外比较对象（这个我们可以解决）。</li>
<li>它和<code>??</code>运算符的行为不一致，虽然后者也会判空，但它做的是纯C#的判空，不能绕过它来调用我们的自定义判空。</li>
</ul>
<p>考虑到这些优缺点，如果我们从头构建API，我们会选择不做自定义判空，而是设计一个<code>myObject.destroy</code>属性，让你用它来检查对象是否已经死亡，同时接受这样的事实：如果你真的在空字段上调用函数，我们没法再给出较好的错误信息。</p>
<p>我们正在考虑是否应该做出改变。这是我们对“修整旧事物”和“不破坏旧项目”之间正确平衡的不断探索中的一步。为此，我们想知道你的想法。对于Unity5更新，我们一直在努力让Unity能够自动升级你的脚本（详见之后的博文）。不幸的是，对于这种情况，我们无法自动升级你的脚本。(因为我们无法区分“这是一个实际想要旧行为的旧脚本”，和“这是一个实际想要新行为的新脚本”）。</p>
<p>我们倾向于“删除自定义的<code>==</code>运算符”，但是很让人纠结，因为这将改变你的项目中目前所有判空的意义。对于对象不是“真正的null”而是一个被destroy的对象的情况，<code>== null</code>判空曾经返回<code>true</code>，如果我们做了改变，它将返回<code>false</code>。如果你想检查你的变量是否指向一个被destroy的对象，你需要将代码改为检查<code>if (myObject.destroy) &#123;&#125;</code>。我们对此有点紧张，因为如果你没有读过这篇博文，十有八九就算你读过，也很容易意识不到这种行为的改变，何况大多数人根本都没意识到这种自定义判空的存在<sup>3</sup>。</p>
<p>即使我们要改变它，也应该在Unity5里做，毕竟我们希望让用户在非主要版本更新里能少受点折磨。</p>
<p>你觉得我们怎么做好？是给你一个更清晰的体验，但你必须为此改变项目中的判空逻辑，还是保持原样？</p>
<p>以上，Lucas (<a href="https://twitter.com/lucasmeijer">@lucasmeijer</a>)</p>
<hr>
<h1>备注</h1>
<ol>
<li>
<p>我们只在编辑器中这样做。这就是为什么当你调用<code>GetComponent()</code>查询一个不存在的组件时，你会发现发生了C#的内存分配，因为我们在新分配的假null中生成了这个自定义的警告字符串。这种内存分配不会发生在构建出的游戏中。这是一个很好的例子，如果你要对你的游戏做性能分析，你总该分析实际的电脑端或移动端，而不是在编辑器里进行分析，因为我们在编辑器里对安全性、使用方法做了很多额外的检查便于你开展工作，但却牺牲了一些性能。当对性能表现和内存分配进行分析时，绝对不要对编辑器进行分析，而是总应对构建出的游戏进行分析。</p>
</li>
<li>
<p>这不仅适用于GameObject，而且适用于所有从UnityEngine.Object派生出来的东西。</p>
</li>
<li>
<p>有趣的故事：我在优化<code>GetComponent&lt;T&gt;()</code>性能时遇到了这个问题，在为<code>Transform</code>组件实现一些缓存时，我没得到任何性能提升。然后<a href="https://twitter.com/jonasechterhoff">@jonasechterhoff</a>看了看这个问题，也得出了同样的结论。缓存代码看起来像这样：</p>
</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Transform m_CachedTransform</span><br><span class="line"><span class="keyword">public</span> Transform transform</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_CachedTransform == <span class="literal">null</span>)</span><br><span class="line">            m_CachedTransform = InternalGetTransform();</span><br><span class="line">        <span class="keyword">return</span> m_CachedTransform;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实证明，我们的两位工程师没有料到判空的开销比预期的高，这就是没看到缓存带来的速度优势的原因。“如果就连我们都踩坑了，那么踩坑的用户会有多少呢？”，于是乎就有了这篇博文:)</p>
]]></content>
      <tags>
        <tag>Unity</tag>
        <tag>C Sharp</tag>
        <tag>译文</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 常用命令行</title>
    <url>/2021/08/24/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
    <content><![CDATA[<p>以下所介绍的部分命令，在设备上是由适合嵌入式 Linux 的工具集 BusyBox 提供，行为和 Linux 桌面发行版上不完全一致，这里均采用 BusyBox 所提供的指令用法。</p>
<h1>ifconfig：查看接口状态</h1>
<p><code>ifconfig</code> 可设置网卡接口的状态，或是显示目前的设置。以下是一些主要的设置参数。</p>
<p>语法格式：<code>ifconfig &lt; -a &gt; [网卡名称] &lt;参数&gt;</code></p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">add &lt;地址&gt;</td>
<td style="text-align:left">设置网卡的IPv6地址。</td>
</tr>
<tr>
<td style="text-align:left">del &lt;地址&gt;</td>
<td style="text-align:left">删除网卡的IPv6地址。</td>
</tr>
<tr>
<td style="text-align:left">up</td>
<td style="text-align:left">启动指定的网卡。</td>
</tr>
<tr>
<td style="text-align:left">down</td>
<td style="text-align:left">关闭指定的网卡。</td>
</tr>
<tr>
<td style="text-align:left">metric &lt;数目&gt;</td>
<td style="text-align:left">指定在计算数据包的转送次数时，所要加上的数目。</td>
</tr>
<tr>
<td style="text-align:left">mtu &lt;字节&gt;</td>
<td style="text-align:left">设置网卡的MTU（最大数据包大小）。</td>
</tr>
<tr>
<td style="text-align:left">netmask &lt;子网掩码&gt;</td>
<td style="text-align:left">设置网卡的子网掩码。</td>
</tr>
<tr>
<td style="text-align:left">-broadcast &lt;地址&gt;</td>
<td style="text-align:left">将要送往指定地址的数据包当成广播数据包来处理。</td>
</tr>
<tr>
<td style="text-align:left">[IP地址]</td>
<td style="text-align:left">指定网卡的IP地址。</td>
</tr>
</tbody>
</table>
<p>直接输入 <code>ifconfig</code> 就会列出目前已激活的网卡，不论这个卡是否有给予 IP ，都会被显示出来。带接口的 <code>ifconfig eth0</code> 则仅会表示接口 eth0 的相关数据，无论其是否启动。使用 <code>-a</code> 选项，则会展示所有网卡的属性。</p>
<h2 id="示例"><a class="header-anchor" href="#示例">¶</a>示例</h2>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ifconfig ra8</span></span><br><span class="line">ra8       Link encap:Ethernet  HWaddr 02:A1:BB:01:23:48  </span><br><span class="line">          inet6 addr: fe80::a1:bbff:fe01:2348/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:130 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:61 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:13971 (13.6 KiB)  TX bytes:7767 (7.5 KiB)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>展示的各项数据由上而下、由左而右分别代表：</p>
<ol>
<li>ra8：网卡的代号，也有 <code>lo</code> 这个 loopback 代表本地回环；</li>
<li>HWaddr：网卡的硬件地址，即 MAC ；</li>
<li>inet addr：IPv4 地址，后面的 Bcast，Mask 分别代表的是广播地址 broadcast 与子网掩码 netmask ，这里没有体现；</li>
<li>inet6 addr：IPv6 地址，Scope 代表该地址的作用域；</li>
<li>网络状态：UP 代表网卡已开启；BROADCAST 代表支持广播；RUNNING 代表网卡正在运行中；MULTICAST代表支持组播；</li>
<li>MTU：最大传输单元，单位是字节；</li>
<li>Metric：路由算法的度量值；</li>
<li>RX：代表网络由启动到目前为止的数据包接收情况，packets 代表数据包数、errors 代表数据包发生错误的数量、dropped 代表由于有问题而遭丢弃的数据包数量等等；</li>
<li>TX：与 RX 相反，代表网络由启动到目前为止的传送情况；</li>
<li>collisions：代表数据包碰撞的情况，如果发生太多次，表示网络状况不太好；</li>
<li>txqueuelen：代表用来传输资料的缓冲区的储存长度；</li>
<li>RX bytes/TX bytes：总接收、传送的字节总量。</li>
</ol>
<p>通过观察这些数据，可以大致了解你的网络情况。尤其是 RX ， TX 内的 error 数量，以及是否发生严重的 collision 情况，都是值得注意的。</p>
<h1>brctl：查看网桥状态</h1>
<p><code>brctl</code> 命令用于设置、维护和检查 Linux 内核中的以太网网桥配置。</p>
<p>以太网网桥是一种设备，通常用于将以太网的不同网络连接在一起，以便这些以太网对参与者显示为一个以太网。所连接的每个以太网对应于网桥中的一个物理接口。这些单独的以太网被聚集成一个更大的“逻辑”以太网，这个更大的以太网对应于网桥网络接口。</p>
<p>语法格式：<code>brctl [参数] &lt;网桥名&gt;</code></p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">addbr</td>
<td style="text-align:left">创建网桥</td>
</tr>
<tr>
<td style="text-align:left">delbr</td>
<td style="text-align:left">删除网桥</td>
</tr>
<tr>
<td style="text-align:left">addif</td>
<td style="text-align:left">将网卡接口接入网桥</td>
</tr>
<tr>
<td style="text-align:left">delif</td>
<td style="text-align:left">删除网桥接入的网卡接口</td>
</tr>
<tr>
<td style="text-align:left">show</td>
<td style="text-align:left">查询网桥信息</td>
</tr>
<tr>
<td style="text-align:left">stp {on|off}</td>
<td style="text-align:left">启用禁用 STP</td>
</tr>
<tr>
<td style="text-align:left">showstp</td>
<td style="text-align:left">查看网桥 STP 信息</td>
</tr>
<tr>
<td style="text-align:left">setfd</td>
<td style="text-align:left">设置网桥延迟</td>
</tr>
<tr>
<td style="text-align:left">showmacs</td>
<td style="text-align:left">查看 mac 信息</td>
</tr>
</tbody>
</table>
<h2 id="示例-v2"><a class="header-anchor" href="#示例-v2">¶</a>示例</h2>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 addbr 参数创建网桥：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brctl addbr br0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 addif 参数将接口加入网桥：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brctl addif br0 wl1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 show 参数查询网桥信息：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brctl show</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用网桥 STP ：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brctl stp br0 on</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭网桥 STP ：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">brctl stp br0 off</span></span><br></pre></td></tr></table></figure>
<p>无线驱动较少关注网桥，但当出现 WiFi 无法连接的情况时，有可能是网桥出现了问题，比如对应的无线接口没有被加入到网桥中。此时可以通过 <code>brctl show</code> 指令查看网桥状态进行确认。</p>
<h1>ps：查看进程状态</h1>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps --<span class="built_in">help</span></span></span><br><span class="line">BusyBox v1.30.1 (2021-06-11 10:17:09 CST) multi-call binary.</span><br><span class="line"></span><br><span class="line">Usage: ps [-o COL1,COL2=HEADER] [-T]</span><br><span class="line"></span><br><span class="line">Show list of processes</span><br><span class="line"></span><br><span class="line">        -o COL1,COL2=HEADER     Select columns for display</span><br><span class="line">        -T                      Show threads</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -o <span class="built_in">help</span></span></span><br><span class="line">ps: bad -o argument &#x27;help&#x27;, supported arguments: user,group,comm,args,pid,ppid,pgid,etime,nice,rgroup,ruser,time,tty,vsz,sid,stat,rss</span><br></pre></td></tr></table></figure>
<p>直接执行 <code>ps</code>，将打印正在执行的进程列表。</p>
<p>对于每个进程，默认显示这四列属性：</p>
<ol>
<li>PID：进程的PID</li>
<li>USER：进程的所有者用户ID</li>
<li>TIME：进程消耗的CPU时间总和</li>
<li>COMMAND：进程由何种命令启动，包括所用的参数(args)</li>
</ol>
<p>如果想自定义 <code>ps</code> 显示的列，可以使用 <code>-o</code> 参数。提示中所述的可选项目有很多，其中比较有用的除了默认的四项外，还有：</p>
<ol>
<li>stat：用不同的字符表示进程的状态。如 R 为可运行状态（ Runnable ，正在运行或准备运行）， S 为睡眠状态（ Sleep ，等待某事件发生后继续运行）， D 为不可中断状态（ Disk Sleep ，等待 I/O 操作）等等</li>
<li>vsz：进程分配的的虚拟内存，即进程可以访问的所有内存</li>
<li>rss：进程的常驻内存集，即进程的物理内存占用，其中包括进程所使用的共享库占用的内存</li>
<li>ppid：父进程的 PID</li>
<li>etime： e 代表 Elapsed （经过）， etime 是进程的挂钟时间 (wall-clock-time) ，即进程启动后经过的时间</li>
</ol>
<h2 id="示例-v3"><a class="header-anchor" href="#示例-v3">¶</a>示例</h2>
<p><code>grep -v &quot;\[.*\]&quot;</code> 是为了排除掉由内核创建的进程。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -o pid,<span class="built_in">stat</span>,time,rss,args | grep -v <span class="string">&quot;\[.*\]&quot;</span></span></span><br><span class="line">PID   STAT TIME   RSS  COMMAND</span><br><span class="line">    1 S      0:04 1392 init</span><br><span class="line">  302 S &lt;    0:00 1180 /sbin/udevd -d</span><br><span class="line">  305 S      0:08 1256 tcwdog -t 1 /dev/watchdog</span><br><span class="line">  504 S      0:00 1092 /fhrom/bin/ubusd</span><br><span class="line">  509 S      0:04 2132 /usr/sbin/dbus-daemon --system</span><br><span class="line">  521 S      0:00 1780 -ash</span><br><span class="line">  528 S      0:00 1392 /fhrom/bin/sysproxy</span><br><span class="line">  529 S      3:59 3676 sysmgr</span><br><span class="line">  537 S      0:03 2164 thttpd -C /fhrom/fhconf/thttpd.conf -p 8080</span><br><span class="line">  546 S      0:00 1280 /userfs/bin/ponmgr_cfg</span><br><span class="line">  563 S      2:23 3964 cfgmgr</span><br></pre></td></tr></table></figure>
<h1>top：动态查看进程状态</h1>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">top --<span class="built_in">help</span></span></span><br><span class="line">BusyBox v1.30.1 (2021-06-11 10:17:09 CST) multi-call binary.</span><br><span class="line"></span><br><span class="line">Usage: top [-b] [-nCOUNT] [-dSECONDS] [-m]</span><br><span class="line"></span><br><span class="line">Provide a view of process activity in real time.</span><br><span class="line">Read the status of all processes from /proc each SECONDS</span><br><span class="line">and display a screenful of them.</span><br><span class="line">Keys:</span><br><span class="line">        N/M/P/T: show CPU usage, sort by pid/mem/cpu/time</span><br><span class="line">        S: show memory</span><br><span class="line">        R: reverse sort</span><br><span class="line">        H: toggle threads, 1: toggle SMP</span><br><span class="line">        Q,^C: exit</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">        -b      Batch mode</span><br><span class="line">        -n N    Exit after N iterations</span><br><span class="line">        -d N    Delay between updates</span><br><span class="line">        -m      Same as &#x27;s&#x27; key</span><br></pre></td></tr></table></figure>
<p><code>top</code> 的功能和 <code>ps</code> 差不多，但只要不手动退出，它就会自动刷新进程的占用情况（默认间隔5s）。</p>
<p>如 help 提示，在 <code>top</code> 界面中，可以用按键切换不同的排序和显示数据。需要注意 VSZ 和 RSS 的区别，进程的物理内存占用 RSS 只有按 S 后才会显示出来。</p>
<h2 id="示例-v4"><a class="header-anchor" href="#示例-v4">¶</a>示例</h2>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Mem: 255692K used, 181472K free, 180K shrd, 17092K buff, 65480K cached</span><br><span class="line">CPU:  2.5% usr  4.7% sys  0.0% nic 91.6% idle  0.0% io  0.0% irq  1.1% sirq</span><br><span class="line">Load average: 2.02 2.18 2.25 1/258 21037</span><br><span class="line">  PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND</span><br><span class="line">  249     2 root     DW       0  0.0   0  1.3 [LDDLA_task_wait]</span><br><span class="line"> 2986     2 root     SW       0  0.0   0  0.5 [RtmpMlmeTask]</span><br><span class="line"> 1475     1 root     S    52008 11.8   0  0.4 wifimgr</span><br><span class="line">  627     1 root     S    36936  8.4   1  0.4 lancc</span><br><span class="line"> 1661     1 root     S    52108 11.8   1  0.2 processcpumonitor</span><br><span class="line">  529     1 root     S    35892  8.1   0  0.2 sysmgr</span><br><span class="line">21001   521 root     R     3236  0.7   1  0.2 top</span><br><span class="line"> 1479     1 root     S &lt;  88236 20.1   1  0.1 /fhrom/bin/gdecms</span><br><span class="line"> 1676     1 root     S    67144 15.3   1  0.1 /fhrom/bin/dbuscheck</span><br><span class="line"> 1477     1 root     S    61804 14.1   1  0.1 easymeshagent</span><br><span class="line">  716     1 ctuser   S    60344 13.7   1  0.1 /fhrom/bin/udhcpd /var/run/udhcpd.</span><br><span class="line">  596     1 ctuser   S    58016 13.2   1  0.1 tr069 -F /fhconf/ -M 1 -L 5 -S 200</span><br><span class="line"> 2847  2051 root     S    51564 11.7   1  0.1 /sbin/easymesh</span><br><span class="line"> 2830  2051 root     S    41672  9.5   1  0.1 /usr/sbin/vpnclient</span><br><span class="line">  705     1 root     S    37196  8.4   1  0.1 serviceMgr</span><br><span class="line"> 2870  2051 root     S    33504  7.6   0  0.1 /usr/sbin/dsmonitor</span><br><span class="line">  590     1 root     S    26504  6.0   0  0.1 eventmgr 23</span><br><span class="line">  643     1 root     S    26324  6.0   1  0.1 /fhrom/bin/fhomci -m -o /var/fhomc</span><br><span class="line">  602     1 root     S    25496  5.8   0  0.1 fh_bsp_led_act</span><br><span class="line">  599     1 root     S    25284  5.7   1  0.1 detectHwEvent</span><br></pre></td></tr></table></figure>
<h1>uptime：查看运行时间和平均负载</h1>
<p><code>uptime</code> 的功能非常简单，它打印出一行信息，包括：</p>
<ol>
<li>当前时间</li>
<li>系统已运行时间</li>
<li>用户连接数，是总连接数而不是用户数</li>
<li>过去1/5/15分钟的平均负载</li>
</ol>
<p>平均负载指的是处于可运行状态和不可中断状态，即 <code>ps</code> 或 <code>top</code> 中状态为 R 或 D 的平均进程数。</p>
<p>当平均负载与机器的逻辑核心数基本相等时，说明每个核心上都在运行程序，性能被充分发挥。如果平均负载明显高于逻辑核心数，则说明机器的性能已经不够了。</p>
<h2 id="示例-v5"><a class="header-anchor" href="#示例-v5">¶</a>示例</h2>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一台服务器的 <span class="built_in">uptime</span> 和逻辑核心数</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uptime</span></span></span><br><span class="line"> 09:15:06 up 74 days, 12:55, 22 users,  load average: 0.48, 1.27, 1.58</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/cpuinfo |grep <span class="string">&quot;model name&quot;</span>|<span class="built_in">wc</span> -l</span></span><br><span class="line">56</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一台路由器的 <span class="built_in">uptime</span> 和逻辑核心数</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">uptime</span></span></span><br><span class="line"> 08:51:02 up 51 min,  1 users,  load average: 2.16, 2.24, 2.19</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /proc/cpuinfo |grep <span class="string">&quot;model name&quot;</span>|<span class="built_in">wc</span> -l</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<h1>tcpdump：抓包工具</h1>
<p>tcpdump 是一个强大且复杂的本地抓包工具，限于篇幅，这里仅作简单介绍。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tcpdump -h</span></span><br><span class="line">tcpdump version 4.9.2</span><br><span class="line">libpcap version 1.8.1</span><br><span class="line">Usage: tcpdump [-aAbdDefhHIJKlLnNOpqStuUvxX#] [ -B size ] [ -c count ]</span><br><span class="line">                [ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]</span><br><span class="line">                [ -i interface ] [ -j tstamptype ] [ -M secret ] [ --number ]</span><br><span class="line">                [ -Q in|out|inout ]</span><br><span class="line">                [ -r file ] [ -s snaplen ] [ --time-stamp-precision precision ]</span><br><span class="line">                [ --immediate-mode ] [ -T type ] [ --version ] [ -V file ]</span><br><span class="line">                [ -w file ] [ -W filecount ] [ -y datalinktype ] [ -z postrotate-command ]</span><br><span class="line">                [ -Z user ] [ expression ]</span><br></pre></td></tr></table></figure>
<h2 id="抓包选项"><a class="header-anchor" href="#抓包选项">¶</a>抓包选项</h2>
<p>-c：指定要抓取的包数量。注意，是最终要获取这么多个包。例如，指定 <code>-c 10</code> 将获取10个包，但可能已经处理了100个包，只不过只有10个包是满足条件的包。</p>
<p>-i interface：指定监听接口。若未指定该选项，将从系统接口列表中搜寻编号最小的已配置好的接口(不包括 loopback 接口，要抓取 loopback 接口使用 <code>tcpdump -i lo</code>)，一旦找到第一个符合条件的接口，搜寻马上结束。可以使用 <code>any</code> 关键字表示所有网络接口。</p>
<p>-n：对地址以数字方式显式，否则显式为主机名，也就是说 <code>-n</code> 选项不做主机名解析。</p>
<p>-nn：除了 <code>-n</code> 的作用外，还把端口显示为数值，否则显示端口服务名。</p>
<p>-Q：指定要抓取的包是流入还是流出的包。可以给定的值为 <code>in</code>、<code>out</code> 和 <code>inout</code>，默认为 <code>inout</code>。</p>
<p>-s len：设置 <code>tcpdump</code> 的数据包抓取长度为len，如果不设置默认将会是65535字节。对于要抓取的数据包较大时长度设置不够可能会产生包截断，若出现包截断，输出行中会出现 <code>[|proto]</code> 的标志(proto 实际会显示为协议名)。但是抓取len越长，包的处理时间越长，并且会减少 <code>tcpdump</code> 可缓存的数据包的数量，从而会导致数据包的丢失，所以在能抓取我们想要的包的前提下，抓取长度越小越好。</p>
<h2 id="输出选项"><a class="header-anchor" href="#输出选项">¶</a>输出选项</h2>
<p>-e：输出的每行中都将包括数据链路层头部信息，例如源 MAC 和目标 MAC 。</p>
<p>-q：快速打印输出。即打印很少的协议相关信息，从而输出行都比较简短。</p>
<p>-X：输出包的头部数据，会以16进制和 ASCII 两种方式同时输出。</p>
<p>-XX：输出包的头部数据，会以16进制和 ASCII 两种方式同时输出，更详细。</p>
<p>-v, -vv, -vvv：当分析和打印的时候，产生不同详细程度的输出。</p>
<h2 id="其他功能性选项"><a class="header-anchor" href="#其他功能性选项">¶</a>其他功能性选项</h2>
<p>-D：列出可用于抓包的接口。将会列出接口的数值编号和接口名，它们都可以用于 <code>-i</code> 后。</p>
<p>-F：从文件中读取抓包的表达式。若使用该选项，则命令行中给定的其他表达式都将失效。</p>
<p>-w：将抓包数据输出到文件中而不是标准输出。可以同时配合 <code>-G time</code> 选项使得输出文件每time秒就自动切换到另一个文件。可通过 <code>-r</code> 选项载入这些文件以进行分析和打印。</p>
<p>-r：从给定的数据包文件中读取数据。使用 <code>-</code> 表示从标准输入中读取。</p>
<h2 id="过滤器"><a class="header-anchor" href="#过滤器">¶</a>过滤器</h2>
<p>在选项之后，可以使用多种过滤器组成的表达式来指定要抓取怎样的包，一些常用的过滤方式如下。</p>
<h3 id="根据主机过滤："><a class="header-anchor" href="#根据主机过滤：">¶</a>根据主机过滤：</h3>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抓取所有经过 eth1 ，目的或源地址是192.168.1.1的网络数据</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tcpdump -i eth1 host 192.168.1.1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定源地址</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tcpdump -i eth1 src host 192.168.1.1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定目的地址</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tcpdump -i eth1 dst host 192.168.1.1</span></span><br></pre></td></tr></table></figure>
<h3 id="根据端口过滤："><a class="header-anchor" href="#根据端口过滤：">¶</a>根据端口过滤：</h3>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">抓取所有经过 eth1 ，目的或源端口是25的网络数据</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tcpdump -i eth1 port 25</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定源端口</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tcpdump -i eth1 src port 25</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定目的端口</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tcpdump -i eth1 dst port 25</span></span><br></pre></td></tr></table></figure>
<h3 id="根据协议过滤："><a class="header-anchor" href="#根据协议过滤：">¶</a>根据协议过滤：</h3>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">比较严谨的方式是根据协议号来过滤。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据IP协议号过滤出 ICMP 报文（在 /etc/protocols 文件中有注明 IP 协议号）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tcpdump -i ra0 ip proto 1 -w /var/icmp.pcap</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据以太类型 EtherType 过滤出 IEEE1905.1 报文（0x893a）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tcpdump -i ra0 ether proto 0x893a -w /var/1905.pcap</span></span><br></pre></td></tr></table></figure>
<h2 id="分析-tcpdump-的抓包结果"><a class="header-anchor" href="#分析-tcpdump-的抓包结果">¶</a>分析 tcpdump 的抓包结果</h2>
<p>不建议使用 <code>tcpdump</code> 本身的打印来进行分析。</p>
<p><code>tcpdump</code> 使用 <code>-w</code> 选项输出的 .pcap 类型文件可以用 Wireshark 或 OmniPeek 打开，进行详尽的分析。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99598:/QqHfc43T5pwAon2.png?authkey=AIbyrqnS5z58phc" alt="分析 tcpdump 抓到的报文"></p>
<h1>tftp：简单文件传输协议</h1>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tftp --<span class="built_in">help</span></span></span><br><span class="line">BusyBox v1.26.2 (2021-08-06 09:48:45 CST) multi-call binary.</span><br><span class="line"></span><br><span class="line">Usage: tftp [OPTIONS] HOST [PORT]</span><br><span class="line"></span><br><span class="line">Transfer a file from/to tftp server</span><br><span class="line"></span><br><span class="line">	-l FILE	Local FILE</span><br><span class="line">	-r FILE	Remote FILE</span><br><span class="line">	-g	Get file</span><br><span class="line">	-p	Put file</span><br><span class="line">	-b SIZE	Transfer blocks of SIZE octets</span><br></pre></td></tr></table></figure>
<p>TFTP (Trivial File Transferring Protocol) 用于进行简单的文件传输，由于占用很小，比较适合在电脑与嵌入式设备之间传输文件。</p>
<p>在 Windows 上，可以通过 tftpd64 软件使用 tftp 。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99599:/u8I1dXZSUOChQcv.png?authkey=AIbyrqnS5z58phc" alt="tftpd64"></p>
<p>将 tftpd64 设置为 Tftp Server 模式，配置工作目录（需要配置一个具有读写权限的目录），即可在对端设备上进行文件传输操作。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将本地文件 lancc.log 上传到192.168.1.11的 tftp 工作目录处</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tftp -pl lancc.log 192.168.1.11</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从192.168.1.11的 tftp 工作目录处下载文件 gdb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tftp -gr gdb 192.168.1.11</span></span><br></pre></td></tr></table></figure>
<h1>chmod：更改文件权限</h1>
<p><code>chmod</code> 是 <strong>CHange MODe</strong> 的缩写。使用 <code>tftp</code> 等方法将可执行文件、 Shell 脚本等传输到单板上时，这些文件可能不具备执行权限，此时就需要用 <code>chmod</code> 命令进行调整。</p>
<p>在Linux中使用 <code>ls -l</code> 以长格式列出文件时，能看到每行最前面有10个用于表示文件模式（权限）的字符：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">lrwxrwxrwx    1 root     root             7 Jun 28  2021 cat -&gt; busybox</span><br><span class="line">drwxr-xr-x    2 root     root             0 Jan  1 08:00 mnt</span><br><span class="line">prwxr-xr-x    1 ctuser   ctuser           0 Jan  1 08:00 notify_fifo</span><br><span class="line">-rw-r--r--    1 root     root             7 Jan  2 08:29 ntp_failed</span><br><span class="line">-rwxr-xr-x    1 root     root           322 Jan  1 08:00 passwd</span><br></pre></td></tr></table></figure>
<p>其中，第1个字符表示文件类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">文件类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">普通文件</td>
</tr>
<tr>
<td style="text-align:left">d</td>
<td style="text-align:left">目录文件</td>
</tr>
<tr>
<td style="text-align:left">l</td>
<td style="text-align:left">符号链接，其所指向的文件的属性才是真实的属性</td>
</tr>
<tr>
<td style="text-align:left">c</td>
<td style="text-align:left">字符设备文件</td>
</tr>
<tr>
<td style="text-align:left">b</td>
<td style="text-align:left">块设备文件</td>
</tr>
<tr>
<td style="text-align:left">s</td>
<td style="text-align:left">套接字文件</td>
</tr>
<tr>
<td style="text-align:left">p</td>
<td style="text-align:left">管道文件</td>
</tr>
</tbody>
</table>
<p>后面的9个字符被称为文件属性，第2-4，5-7，8-10个字符分别代表文件的所有者、所属群组、其他所有用户对文件的操作权限。</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">权限</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">r</td>
<td style="text-align:left">读权限Read</td>
</tr>
<tr>
<td style="text-align:left">w</td>
<td style="text-align:left">写权限Write</td>
</tr>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:left">执行权限eXecute（执行脚本，进入目录）</td>
</tr>
</tbody>
</table>
<p>如果用4代表r，2代表w，1代表x，0代表无权限，则可以用一个八进制数来表示一种权限。3个这样的八进制数，就能代表9个字符的文件属性，然后用 <code>chmod</code> 进行修改。如：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改文件权限为rwxr-xr--</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> 754 &lt;filename&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">另一种用法是符号表示法，下面这条表示为所有用户添加执行权限</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +x &lt;filename&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为文件所有者和所属群组之外的所有用户取消读写权限</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> o-rw &lt;filename&gt;</span></span><br></pre></td></tr></table></figure>
<h1>xargs：批量执行命令</h1>
<p><code>xargs</code> 命令可以将标准输入转为命令行参数。真正要执行的命令紧跟在 <code>xargs</code> 后面，接受其传来的参数。</p>
<p>语法格式：<code>xargs [-options] [command]</code></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将管道左侧的标准输入，转为命令行参数，传给xargs后面的<span class="built_in">echo</span>命令</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> | xargs <span class="built_in">echo</span></span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>使用 <code>xargs</code> 的必要性在于，许多命令（比如 <code>rm</code> 、 <code>mkdir</code> 、 <code>ls</code>）要与管道一起使用时，都需要通过它将标准输入转为命令行参数。下面这个管道的使用例中，如果不加 <code>xargs</code> 就会报错，提示 <code>mkdir</code> 缺少操作参数：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;one two three&quot;</span> | xargs <span class="built_in">mkdir</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">与这条命令等效：</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> one two three</span></span><br></pre></td></tr></table></figure>
<p><code>xargs</code> 适合与 <code>find</code> 命令组合使用。先用 <code>find</code> 找出符合一定条件的条件，再用 <code>xargs</code> 对这些文件进行处理。</p>
<p>由于 <code>xargs</code> 默认将空格作为分隔符，这不适合直接处理文件名，因为文件名可能包含空格。但 <code>find</code> 命令有一个特别的参数 <code>-print0</code> ，可以指定输出的文件列表以 null 分隔。同时，用 <code>xargs</code> 命令的 <code>-0</code> 参数可以表示将 null 当作分隔符，这样就能形成很好的配合。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除 /tmp 路径下的所有通常文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find /tmp -<span class="built_in">type</span> f -print0 | xargs -0 <span class="built_in">rm</span></span></span><br></pre></td></tr></table></figure>
<p>还有一个原因，使得 <code>xargs</code> 特别适合 <code>find</code> 命令。有些命令（比如 <code>rm</code>）一旦参数过多会报错“参数列表过长”，而无法执行，改用 <code>xargs</code> 就没有这个问题，因为它会对每个参数执行一次命令。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找出所有 txt 文件后，对每个文件搜索其中任意大小写形式的 wifi</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">find . -name <span class="string">&quot;*.txt&quot;</span> | xargs grep -i <span class="string">&quot;wifi&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><code>-I</code> 选项用于指定一个替换字符串（比如<code>&#123;&#125;</code>），这个字符串在 <code>xargs</code> 扩展时会被替换掉，当 <code>-I</code> 与 <code>xargs</code> 结合使用，每一个参数命令都会被执行一次：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将当前目录下所有 <span class="built_in">log</span> 文件通过 tftp 传输到192.168.1.11</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> *.<span class="built_in">log</span> | xargs -I &#123;&#125; tftp -pl &#123;&#125; 192.168.1.11</span></span><br></pre></td></tr></table></figure>
<h1>history：查看历史命令</h1>
<p><code>history</code> 用于查看当前用户的历史执行命令。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">history</span></span></span><br><span class="line">(…)</span><br><span class="line"> 2004  cd DELAY/</span><br><span class="line"> 2005  ls</span><br><span class="line"> 2006  cd compile/</span><br><span class="line"> 2007  ls</span><br><span class="line"> 2008  cd en752x_ty4</span><br><span class="line"> 2009  ls</span><br><span class="line"> 2010  make clean_sdk</span><br><span class="line"> 2011  nohup make build_sdk &amp;</span><br><span class="line"> 2012  tail -f nohup.out </span><br><span class="line"> 2013  history</span><br></pre></td></tr></table></figure>
<h1>tail：输出文件结尾</h1>
<p><code>tail</code> 默认输出文件的最后10行。配合选项 <code>-f</code>，即可随文件增长即时输出新增数据。这使得它很适合用来监测日志。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在后台监测wifi_drv.log的新增内容</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -f /var/log/wifi_drv.log &amp;</span></span><br></pre></td></tr></table></figure>
<h1>nohup：退出终端后保持命令运行</h1>
<p><code>nohup</code> 即 <strong>NO Hang UP</strong>，用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。适合在编译代码时使用，这样开始编译后即使本地断开连接甚至关机，服务器上也会继续进行编译任务。</p>
<p><code>nohup</code> 命令在默认情况下（非重定向时），会输出一个名叫 nohup.out 的文件到当前目录下，如果当前目录的 nohup.out 文件不可写，则将输出重定向到 $HOME/nohup.out 文件中。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以在编译大量代码时使用</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">nohup</span> ./wrap_build.sh &amp;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果想实时看到编译的输出，可以用 <span class="built_in">tail</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -f nohup.out</span></span><br></pre></td></tr></table></figure>
<h1>gdb：GNU 调试器</h1>
<p><code>gdb</code>的功能非常强大，堪称让开发者对运行中的程序拥有了上帝视角。它的用法很多，这里简单介绍如何用 GDB 排查程序异常退出的问题。</p>
<p>如果在编译代码时加入<code>-g</code>编译选项，且没有用 <code>-s</code> 或 <code>-S</code> 等选项除去调试符号，则生成的程序可以使用 GDB 进行调试。若编译时设置优化等级为 <code>-O0</code> 不开启优化，还可以用 GDB 的 <code>s</code> (step) 指令进行单步调试。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g hello.c -o hello</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb hello</span></span><br><span class="line">(…)</span><br><span class="line">Reading symbols from hello...done.</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<p>如果需要调试指定的进程下的子线程，可以使用 <code>ps -T</code> 查看子线程的信息，编码时可以给每个线程设置名称，这样在<code>ps -T</code> 时就可以对线程进行区分。</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用 -p 选项指定 pid，调试 hello 进程</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gdb -p `pidof hello`</span></span><br></pre></td></tr></table></figure>
<p>GDB 接管成功后，执行 <code>r</code> (run) 命令，或者 <code>c</code> (continue) 命令，接着正常执行导致问题进程异常退出的用例即可，GDB 接管后不会影响进程的正常运行。</p>
<p>一旦接管的进程发生异常退出问题，GDB 就会收到到调试信号将进程停住。这时候只需要用 <code>bt</code> (backtrace) 命令查看调用栈、用 <code>p</code> (print) 命令将函数中的变量打印出来等方法即可对问题点进行分析。</p>
<p>接管进程成功后也可以通过 <code>b</code> (break) 命令设置断点进行调试，触发条件满足即可将进程暂停，查看、修改函数的入参和局部变量，进行动态调试。</p>
<p>另外，假如有程序异常终止，系统一般会报出 “core dumped”，并生成文件名以 <code>core</code> 开头的核心转储文件。这种文件保存了程序退出时进程地址空间的内容以及有关进程状态的其他信息，可以用 GDB 配合程序进行调试。</p>
<p>例如下图中对 MTK 方案 SDK 中主管 Band Steering 的程序 <code>bs20</code> 进行调试：</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99600:/KVFTlCg2azXh5pO.jpg?authkey=AIbyrqnS5z58phc" alt="GDB查看退出原因"></p>
<p>用 <code>bt</code> 指令查看函数调用栈，可以得知程序退出是在 <code>mapfilter_init</code> 函数中调用了 <code>memcpy</code> 导致的。虽然由于编译时没有加 <code>-g</code> 选项，这里不会显示出具体是代码中的哪一行，但基本上已经能定位到直接问题点了。</p>
<h1>Shell 脚本调试</h1>
<p>Shell 提供了一些用于调试脚本的选项，如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-n</td>
<td style="text-align:left">读一遍脚本中的命令但不执行，用于检查脚本中的语法错误</td>
</tr>
<tr>
<td style="text-align:left">-v</td>
<td style="text-align:left">一边执行脚本，一边将执行过的脚本命令打印到标准错误输出</td>
</tr>
<tr>
<td style="text-align:left">-x</td>
<td style="text-align:left">提供跟踪执行信息，将执行的每一条命令和结果依次打印出来</td>
</tr>
</tbody>
</table>
<p>使用这些选项有三种方法，一是执行脚本时在命令行提供参数：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh -x ./script.sh</span></span><br></pre></td></tr></table></figure>
<p>二是在脚本开头用 Shebang (<code>#!</code>) 提供参数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh -x</span></span><br></pre></td></tr></table></figure>
<p>第三种方法是在脚本中用 <code>set</code> 命令启用或禁用参数：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line">(…)</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">set</span> -x</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;ERROR: Insufficient Args.&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="built_in">set</span> +x</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">(…)</span><br></pre></td></tr></table></figure>
<p>这里 <code>set -x</code> 和 <code>set +x</code> 分别表示启用和禁用 <code>-x</code> 参数，这样可以只对脚本中的某一段进行跟踪调试。</p>
<blockquote>
<p>更多实用内容可参考《Linux命令行大全》（人民邮电出版社）。</p>
</blockquote>
]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>《被讨厌的勇气》</title>
    <url>/2022/03/30/KirawareruYuuki/</url>
    <content><![CDATA[<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99608:/tbOdUpGE5WFwXT6.png?authkey=AIbyrqnS5z58phc" alt="豆瓣评分8.6"></p>
<p>前段时间华为推出了10.3寸的墨水屏平板Matepad Paper，似乎非常贴合我对“平板”这一形态的需求。毕竟我手上的Matepad 11原本几乎唯一的作用就是阅读，而基本告别娱乐属性的墨水屏是强化这一属性最好不过的配置了。不过由于了解到华为对PDF的优化并不到位，阅读灯也没有色温调节，我还是把Matepad换成了文石的BOOX NoteX。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99609:/1qMstzlrGAFSWo4.jpg?authkey=AIbyrqnS5z58phc" alt="BOOX NoteX"></p>
<p>在把那些买来就基本没读过的书来来去去搬过几回之后，我的纸质书“情怀”就转化为了对科技的崇尚。我决定不再购买纸质书，而是尽可能获取epub/pdf的版本，<a href="https://singlelogin.org">Z-Library</a>和<a href="http://www.ucdrs.net/">全国图书馆参考咨询联盟</a>也给了我这么做的充足底气，现在也有了这台不错的设备，没有理由不把阅读这件事捡起来了。</p>
<p>有多久没有从头到尾读完一整本书了呢？似乎大学以后，阅读就是为了查阅资料，或者在碎片时间里读些短篇故事，这也许也是数年间我的认知水平与思考深度未曾有过提升的原因。之后也许会试着每两周左右读一本书吧。</p>
<p>那么第一本书就是Z-Library推荐的《被讨厌的勇气》。它初看像是又一卷成功学厕纸，但读过之后却发现意外地有道理也有趣味。</p>
<p>这本书仿照类似柏拉图《理想国》的对话形式，以“青年”与“哲人”的辩论引出心理学家阿尔弗雷德·阿德勒（Alfred Adler）的理论，以图让读者找到“幸福”的真谛。</p>
<span id="more"></span>
<h2 id="行为之源"><a class="header-anchor" href="#行为之源">¶</a>行为之源</h2>
<p>弗洛伊德和阿德勒这两位心理学家对人的行为之源头，有两种截然相反的解释：原因论和目的论。</p>
<blockquote>
<p>哲人：如果一味地关注过去的原因，企图仅仅靠原因去解释事物，那就会陷入“决定论”。也就是说，最终会得出这样的结论：我们的现在甚至未来全部都由过去的事情所决定，而且根本无法改变。是这样吧？</p>
<p>……</p>
<p>哲人：但是，立足于原因论的人们，例如一般的生活顾问或者精神科医生，仅仅会指出“你之所以痛苦是因为过去的事情”，继而简单地安慰“所以错不在你”。所谓的心理创伤学说就是原因论的典型。</p>
<p>青年：请稍等一下！也就是说，先生您否定心理创伤的存在，是这样吗？</p>
<p>哲人：坚决否定。</p>
</blockquote>
<p>关于人“现在的境况”，弗洛伊德认为<strong>是由人过去的经历所决定的</strong>。心理创伤会塑造一个人，现在所遇到的问题都可以从过去找到原因，这就是所谓的“原因论”。</p>
<blockquote>
<p>事实上我们会从经历中发现符合自己目的的因素。决定我们自身的不是过去的经历，而是我们自己赋予经历的意义。</p>
</blockquote>
<p>阿德勒不认可这一观点，他认为不存在心理创伤，过去的经历本身没有任何意义，关键在于我们怎样去看待它。也就是说，过去的意义是被人为赋予的。<strong>现在所遇到的问题，则是由于人自身想要达到某种“目的”，而自己创造出来的</strong>；人所采取的行动，也是在这一目的的指导下产生的，这就是“目的论”。</p>
<p>包括感情亦是空穴来风。衣服被服务员弄脏时产生的愤怒，这种不由自主涌现出的感情，总归是出于一定的“目的”：</p>
<blockquote>
<p>哲人：你是先产生了要大发雷霆这个目的。也就是说，你想通过大发雷霆来震慑犯错的服务员，进而使他认真听自己的话。作为相应手段，你便捏造了愤怒这种感情。……所谓愤怒其实只是可放可收的一种“手段”而已。</p>
</blockquote>
<h2 id="生活方式"><a class="header-anchor" href="#生活方式">¶</a>生活方式</h2>
<blockquote>
<p>如果过去决定一切而过去又无法改变的话，那么活在今天的我们对人生也将会束手无策。结果会如何呢？那就可能会陷入对世界绝望、对人生厌弃的虚无主义或悲观主义之中。以精神创伤说为代表的弗洛伊德式的原因论就是变相的决定论，是虚无主义的入口。</p>
</blockquote>
<p>弗洛伊德的决定论认为人的行为被无法自控的潜意识所支配，由此得出的结论是自由意志是一种幻觉。</p>
<p>相比之下，阿德勒的观点强调人的主观能动性，人格是一个不可分割的整体，即使从弗洛伊德“本我、自我与超我”的理论角度来看，自我也应占据绝对的主要地位。</p>
<blockquote>
<p>哲人：某人如何看“世界”，又如何看“自己”，把这些“赋予意义的方式”汇集起来的概念就可以理解为生活方式。从狭义上来讲可以理解为性格；从广义上来说，这个词甚至包含了某人的世界观或人生观。</p>
</blockquote>
<p>阿德勒把自我，或者说思考、行为的倾向称为“生活方式”。人最初的生活方式在约10岁的时候形成，之后往往就不再改变。</p>
<p>但这并不是说生活方式就不能改变，人不做出改变也不是因为什么外部因素的限制，而是为了达成目的：</p>
<blockquote>
<p>如果一直保持“现在的我”，那么如何应对眼前的事情以及其结果会怎样等问题都可以根据经验进行推测，可谓是轻车熟路般的状态。即使遇到点状况也能够想办法对付过去。</p>
<p>另一方面，如果选择新的生活方式，那就既不知道新的自己会遇到什么问题，也不知道应该如何应对眼前的事情。未来难以预测，生活就会充满不安，也可能有更加痛苦、更加不幸的生活在等着自己。也就是说，即使人们有各种不满，但还是认为保持现状更加轻松、更能安心。</p>
</blockquote>
<p>人习惯于既定的生活方式。即使境况不好，人也会恐惧于做出改变之后无法预料的未来，然后不敢前进，进而不停地摆烂。</p>
<h2 id="恐惧与逃避"><a class="header-anchor" href="#恐惧与逃避">¶</a>恐惧与逃避</h2>
<blockquote>
<p>实际上，他是想通过不去比赛这一方式来保留一种“如果做的话我也可以”的可能性，即不愿出去被人评价，更不愿去面对因作品拙劣而落选的现实。他只想活在“只要有时间我也可以、只要环境具备我也能写、自己有这种才能”之类的可能性中。或许再过5年或者10年，他又会开始使用“已经不再年轻”或者“也已经有了家庭”之类的借口。</p>
</blockquote>
<p>许多人不愿意承认自己内心对未来的恐惧，他们会找各种各样的理由来搪塞逃避。为了达成“不用作出改变”这一目的，人不断地编织谎言。然而，一个谎言需要一百个谎言来自圆其说，陷入恐惧与逃避之后，人眼中的世界将在无数谎言的作用下变得逐渐扭曲。</p>
<blockquote>
<p>哲人：就像有脸红恐惧症的她害怕被男性拒绝一样，你也很害怕被他人否定。害怕被别人轻视或拒绝、害怕心灵受伤。你认为与其陷入那种窘境倒还不如一开始就不与任何人有关联。也就是说，你的“目的”是“避免在与他人的关系中受伤”。</p>
<p>青年：……</p>
<p>哲人：那么，如何实现这种目的呢？答案很简单。只要变成一个只看自己的缺点、极其厌恶自我、尽量不涉入人际关系的人就可以了。如此一来，只要躲在自己的壳里就可以不与任何人发生关联，而且万一遭到别人的拒绝，还可以以此为理由来安慰自己。心里就会想：因为我有这样的缺点才会遭人拒绝，只要我没有这个缺点也会很讨人喜欢。</p>
</blockquote>
<p>对未来的恐惧实际上是“害怕被他人否定”。但越是害怕被他人否定，越是容易陷入自圆其说的封闭圈子，更加无法面对他人，逻辑闭环了属于是。</p>
<h2 id="自卑与优越"><a class="header-anchor" href="#自卑与优越">¶</a>自卑与优越</h2>
<blockquote>
<p>哲人：我再重复一遍：“人的烦恼皆源于人际关系。”这是阿德勒心理学的一个基本概念。如果这个世界没有人际关系，如果这个宇宙中没有他人只有自己，那么一切烦恼也都将消失。</p>
</blockquote>
<p>当人处于完全没有他人的环境中时，他不会有任何烦恼。因为没有人可以评判他行为的“好”、“坏”，也就没有法律、道德以及一切约束，是完全自由的。但是，人不可能生活在空无一人的宇宙中。一旦有了人际关系，就不得不面临来自他人的评价，自己也会把自己与他人比较。</p>
<p>人的普遍欲求就是“追求优越性”，也就是希望进步，达到理想状态。然而，对理想的追求肯定不是一帆风顺，在这之中就产生了自卑感。人际关系的存在更是将这种自卑放大，毕竟谁不认识一群看起来比自己强得多的人呢？</p>
<blockquote>
<p>而另一方面，自卑情结是指把自己的自卑感当作某种借口使用的状态。具体就像“我因为学历低所以无法成功”或者“我因为长得不漂亮所以结不了婚”之类的想法。像这样在日常生活中大肆宣扬“因为有A所以才做不到B”这样的理论，这已经超出了自卑感的范畴，它是一种自卑情结。</p>
</blockquote>
<p>自卑感本来是一种正常的情绪，如果以良好的心态去对待反而可以促进成长。但另一方面，如果已经习惯了逃避与摆烂，自卑感就会成为自我封闭的工具，进化成自卑情结。</p>
<blockquote>
<p>哲人：正是如此。自卑情结有时会发展成另外一种特殊的心理状态。</p>
<p>青年：那是什么呢？</p>
<p>哲人：这也许是你没听说过的词语，是“优越情结”。</p>
<p>青年：优越情结？</p>
<p>哲人：虽然苦于强烈的自卑感，但却没有勇气通过努力或成长之类的健全手段去进行改变。即便如此，又没法忍受“因为有A所以才做不到B”之类的自卑情结，无法接受“无能的自己”。如此一来，人就会想要用更加简便的方法来进行补偿。</p>
<p>青年：怎么做呢？</p>
<p>哲人：表现得好像自己很优秀，继而沉浸在一种虚假的优越感之中。</p>
</blockquote>
<p>越是自卑的人，就越想在表面上用自负来掩饰自己的自卑，因此越是自负的人就越自卑。真正有资格自负的人反而在追求优越的过程中意识到了“高山仰止，景行行止”，并不会表现得自负。</p>
<blockquote>
<p>哲人：是的。以自己的不幸为武器来支配对方。通过诉说自己如何不幸、如何痛苦来让周围的人——比如家人或朋友——担心或束缚支配其言行。刚开始提到的那些闭门不出者就常常沉浸在以不幸为武器的优越感中。阿德勒甚至指出：“在我们的文化中，弱势其实非常强大而且具有特权。”</p>
</blockquote>
<p>不能以正常方式追求到优越境界的人，甚至会将自卑情结作为优越感，“我烂我有理”。</p>
<blockquote>
<p>青年：哎呀，这不可能吧。我们无论如何都避免不了把自己与别人相比较。自卑感不就是这样产生的吗？</p>
<p>哲人：健全的自卑感不是来自与别人的比较，而是来自与“理想的自己”的比较。</p>
</blockquote>
<p>要摆脱自卑，首先就不要和别人比，要和昨天的自己比。每天都比昨天更接近理想中的自己，那就是最好的！</p>
<blockquote>
<p>哲人：如果意识到竞争或胜负，那么势必就会产生自卑感。因为常常拿自己和别人相比就会产生“优于这个、输于那个”之类的想法，而自卑情结或优越情结就会随之而生。那么，对此时的你来说，他人又会是什么样的存在呢？</p>
<p>青年：呀，是竞争对手吗？</p>
<p>哲人：不，不是单纯的的竞争对手。不知不觉就会把他人乃至整个世界都看成“敌人”。</p>
</blockquote>
<p>第二点就是要认识到人生不是一场竞争，追求优越不是要把别人踩在脚下，而是要达到自己心目中的理想状态。不会有人的理想就是要把别人踩在脚下吧，不会吧不会吧？</p>
<h2 id="人生课题"><a class="header-anchor" href="#人生课题">¶</a>人生课题</h2>
<blockquote>
<p>阿德勒把这些过程中产生的人际关系分为“工作课题”“交友课题”和“爱的课题”这三类，又统称为“人生课题”。</p>
</blockquote>
<p>阿德勒认为人的一切苦恼都来源于人际关系。相对的，人的一切幸福也都来自于人际关系。因此，达到人生的目标，进而获得幸福，就是要发展人际关系。工作、交友、恋爱这三种人生中不得不面对的人际关系，阿德勒把它们称为“人生课题”。</p>
<blockquote>
<p>如果在一起感到苦闷或者紧张，那即使是恋爱关系也不能称之为爱。当人能够感觉到“与这个人在一起可以无拘无束”的时候，才能够体会到爱。既没有自卑感也不必炫耀优越性，能够保持一种平静而自然的状态。真正的爱应该是这样的。</p>
<p>另一方面，束缚是想要支配对方的表现，也是一种基于不信任感的想法。与一个不信任自己的人处在同一个空间里，那就根本不可能保持一种自然状态。阿德勒说：“如果想要和谐地生活在一起，那就必须把对方当成平等的人。”</p>
</blockquote>
<p>谁也不是谁的附庸，我们都是平等的人。</p>
<h2 id="认可欲求"><a class="header-anchor" href="#认可欲求">¶</a>认可欲求</h2>
<p>那么，怎样才能拿出勇气，直面人生的课题呢？</p>
<blockquote>
<p>哲人：明白了。关于现在这个话题，我要先说一下阿德勒心理学的一个大前提。阿德勒心理学否定寻求他人的认可。</p>
<p>青年：否定认可欲求？</p>
<p>哲人：根本没必要被别人认可，也不要去寻求认可。这一点必须事先强调一下。</p>
</blockquote>
<p>要获得勇气，首先就是否定认可欲求。<strong>不需要得到他人的认可。</strong></p>
<p>这里是亚伯拉罕·马斯洛需求层次理论的五个基本层级：</p>
<ul>
<li>生理的需求：食物、水、空气、睡眠、性</li>
<li>安全的需求：人身安全，生活稳定，免遭痛苦、威胁或疾病</li>
<li>爱与归属的需求：对友谊、爱情以及隶属关系的需求</li>
<li>尊严的需求：对成就或自我价值的个人感觉、他人对自己的认可与尊重</li>
<li>自我实现的需求：至高人生境界</li>
<li>超自我实现：高峰体验、心流</li>
</ul>
<p>阿德勒的理论是否定“尊严需求”中他人对自己的认可的。每个人都不是为了满足别人的期待而活。</p>
<blockquote>
<p>哲人：认可欲求的危险就在这里。人究竟为什么要寻求别人的认可呢？其实，很多情况下都是因为受赏罚教育的影响。</p>
<p>青年：赏罚教育？</p>
<p>哲人：如果做了恰当的事情就能够得到表扬，而如果做了不恰当的事情就会受到惩罚。阿德勒严厉批判这种赏罚式的教育。在赏罚式教育之下会产生这样一种错误的生活方式，那就是“如果没人表扬，我就不去做好事”或者是“如果没人惩罚，我也做坏事”。</p>
</blockquote>
<p>这种思想有一点像子贡赎人的故事：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">鲁国之法，鲁人为人臣妾于诸侯，有能赎之者，取其金于府。子贡赎鲁人于诸侯，来而让，不取其金。</span><br><span class="line">孔子曰：“赐失之矣。自今以往，鲁人不赎人矣。取其金则无损于行，不取其金则不复赎人矣。”</span><br></pre></td></tr></table></figure>
<h2 id="课题分离"><a class="header-anchor" href="#课题分离">¶</a>课题分离</h2>
<p>既然人不是为了满足别人的期待而活，也不去追求他人的认可，难道说就可以肆意妄为吗？当然不是。因为他人与自己是平等的，自己的随性而为必须建立在不影响他人的基础上。</p>
<p>为此，阿德勒提出了“课题分离”这一用于界定的方法论。</p>
<blockquote>
<p>我们必须从“这是谁的课题”这一观点出发，把自己的课题与别人的课题分离开来。</p>
<p>青年：分离之后再怎么做呢？</p>
<p>哲人：不干涉他人的课题。仅此而已。</p>
<p>青年：……仅此而已吗？</p>
<p>哲人：基本上，一切人际关系矛盾都起因于对别人的课题妄加干涉或者自己的课题被别人妄加干涉。只要能够进行课题分离，人际关系就会发生巨大改变。</p>
<p>青年：我还是不太明白，究竟如何辨别“这是谁的课题”呢？实际上，在我看来让孩子学习是父母的责任和义务。因为，几乎没有真心喜欢学习的孩子，而父母则是孩子的保护人。</p>
<p>哲人：辨别究竟是谁的课题的方法非常简单，只需要考虑一下“某种选择所带来的结果最终要由谁来承担？”</p>
</blockquote>
<p><strong>一切人际关系矛盾都起因于对别人的课题妄加干涉或者自己的课题被别人妄加干涉</strong>。可以说是至理真言了。</p>
<p>“某种选择所带来的结果最终要由谁来承担？”这种判别方法虽然说起来简单，但是恐怕也需要长期的实践才能摸得透彻。总之我认为就是尽力做好自己该做的，不去擅自评判他人，对他人的批评或意见表示感谢但不盲从。</p>
<blockquote>
<p>某个国家有这么一句谚语：可以把马带到水边，但不能强迫其喝水。阿德勒心理学中的心理咨询辅导以及对别人的一切援助都遵循这个要求。倘若无视本人的意愿而强迫其“改变”，那结果只会是日后产生更加强烈的反作用。</p>
</blockquote>
<p>授人以鱼不如授人以渔。</p>
<blockquote>
<p>哲人：关于自己的人生你能够做的就只有“选择自己认为最好的道路”。另一方面，别人如何评价你的选择，那是别人的课题，你根本无法左右。</p>
<p>青年：别人如何看自己，无论是喜欢还是讨厌，那都是对方的课题而不是自己的课题。先生您是这个意思吗？</p>
<p>哲人：分离就是这么回事。你太在意别人的视线和评价，所以才会不断寻求别人的认可。那么，人为什么会如此在意别人的视线呢？阿德勒心理学给出的答案非常简单，那就是因为你还不会进行课题分离。把原本应该是别人的课题也看成是自己的课题。</p>
</blockquote>
<p>“我”所能做到的就是做好自己。最不可取的就是为了避免得不到认可、被人讨厌，而选择“什么都不做”了。</p>
<blockquote>
<p>哲人：选择了不自由生活方式的大人看着自由活在当下的年轻人就会批判其“享乐主义”。当然，这其实是为了让自己接受不自由生活而捏造出的一种人生谎言。选择了真正自由的大人就不会说这样的话，相反还会鼓励年轻人要勇于争取自由。</p>
<p>毫不在意别人的评价、不害怕被别人讨厌、不追求被他人认可，如果不付出以上这些代价，那就无法贯彻自己的生活方式，也就是不能获得自由。</p>
</blockquote>
<p>自由就是不再寻求认可。不去干涉别人的课题，那么无论怎样的行为都不构成“恶”，别人的评价自然也就宛如耳旁风，自己的未来忽然就有了无限种可能。</p>
<h2 id="横向关系"><a class="header-anchor" href="#横向关系">¶</a>横向关系</h2>
<p>怎样发展人际关系？</p>
<blockquote>
<p>哲人：也就是说，用“你真了不起”“做得很好”或者“真能干”之类的话表扬孩子的母亲无意之中就营造了一种上下级关系——把孩子看得比自己低。你刚才提到的训练的事情正好象征了一种“表扬”背后的上下级关系和纵向关系。人表扬他人的目的就在于“操纵比自己能力低的对方”，其中既没有感谢也没有尊敬。</p>
</blockquote>
<p>阿德勒认为人际关系分为纵向关系和横向关系。传统的上下级关系就是典型的纵向关系，是一方支配另一方的情况。</p>
<blockquote>
<p>哲人：希望被别人表扬或者反过来想要去表扬别人，这是一种把一切人际关系都理解为“纵向关系”的证明。你也是因为生活在纵向关系中，所以才希望得到表扬。阿德勒心理学反对一切“纵向关系”，提倡把所有的人际关系都看作“横向关系”。在某种意义上，这可以说是阿德勒心理学的基本原理。</p>
</blockquote>
<p>纵向关系就是以赏罚教育为基础产生的。“表扬”这一行为本身就意味着单方面的评价权力，也就是上位者的支配。</p>
<blockquote>
<p>人为什么会去干涉别人呢？其背后实际上也是一种纵向关系。正因为把人际关系看成纵向关系、把对方看得比自己低，所以才会去干涉。希望通过干涉行为把对方导向自己希望的方向。这是坚信自己正确而对方错误。</p>
</blockquote>
<p>纵向关系形成之后，就难以进行课题分离，人际关系会在干涉的过程中逐渐扭曲，必将导致矛盾的产生。</p>
<p>就算是上下级关系，也不能把自己的位置看得比领导低。可以表现得尊敬，但是绝不是唯唯诺诺，绝不是压制自己的想法，全盘听领导指挥。如果他人干涉到自己的课题，一定要提出来，一定要去沟通。</p>
<p>当然，这种沟通能否有效，这是我们所不能决定的（这也算是课题分离的一环），但不去做的话，就等于是放弃自己的主观能动性。只要牢记“不需要他人认可”这一点，就没有什么好瞻前顾后的！</p>
<blockquote>
<p>哲人：是的，不是强制的，而是在课题分离的前提下帮助他用自己的力量去解决，也就是“可以把马带到水边，但不能强迫其喝水”。直面课题的是其本人，下定决心的也是其本人。</p>
<p>青年：既不表扬也不批评？</p>
<p>哲人：是的，既不表扬也不批评。阿德勒心理学把这种基于横向关系的援助称为“鼓励”。</p>
</blockquote>
<p>为了不产生纵向关系，阿德勒提倡不去“表扬”也不去“批评”，而是要去“鼓励”。</p>
<p>看到这里就想起安倍晋三的名言：“我自己的家庭也没有孩子。生不生孩子是他们自己的选择，我们要做的就是为想生孩子的人创造良好的社会环境。”</p>
<h2 id="人际关系的终点"><a class="header-anchor" href="#人际关系的终点">¶</a>人际关系的终点</h2>
<p>阿德勒认为，人际关系的理想境界就是“共同体感觉”。我认为可以理解为“归属感”。</p>
<blockquote>
<p>哲人：上上次说到过“是把别人看成‘敌人’还是看成‘伙伴’”这个话题吧？</p>
<p>在这里我们再深入考虑一下。如果他人是伙伴，我们生活在伙伴中间，那就能够从中找到自己的“位置”，而且还可以认为自己在为伙伴们——也就是共同体——做着贡献。像这样把他人看作伙伴并能够从中感到“自己有位置”的状态，就叫共同体感觉。</p>
</blockquote>
<p>能够为集体做贡献，就能够获得归属感。而且，这种共同体感觉就是一切幸福感的源泉。</p>
<blockquote>
<p>哲人：这种时候，如果认为学校就是一切，那你就会没有任何归属感。然后就会逃避到更小的共同体，例如家庭之中，并且还会躲在里面不愿出去，有时候甚至会陷入家庭暴力等不良状况，想要通过这样做来获得某种归属感。</p>
<p>但是，在这里希望你能关注的是“还有更多别的共同体”，特别是“还有更大的共同体”。</p>
<p>青年：什么意思呢？</p>
<p>哲人：在学校之外，还有更加广阔的世界。而且，我们都是那个世界的一员。如果学校中没有自己位置的话，还可以从学校“外面”找到别的位置，可以转学，甚至可以退学。一张退学申请就可以切断联系的共同体终归也就只是那种程度的联系。</p>
<p>如果了解了世界之大，就会明白自己在学校中所受的苦只不过是“杯中风暴”而已。只要跳出杯子，猛烈的风暴也会变成微风。</p>
</blockquote>
<p>就算暂时在某个共同体中找不到归属感，也不要紧。这一段我看了非常感同身受。一直以来我都有一个习惯：在遇到难解的困境时，我会打开Google Earth，看看世界上各种奇怪地方的卫星照片。塔克拉玛干沙漠腹地孤零零的达里雅布依，全球最北端的永久居住地阿勒特，白令海峡中央拉特曼诺夫岛上的一架飞机残骸，大西洋上的火山小岛特里斯坦-达库尼……也许这就是在暗示自己，世界并非只有摆在眼前的难题，不管有没有诗，远方都矗立在那里。世界广大得很哩！</p>
<p>我也曾和复数的人讲过那个从罗永浩口中听到的纽约公交司机的故事，虽然不知道是否有人get到。</p>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99610:/HqXMmkjgdzyPKnW.png?authkey=AIbyrqnS5z58phc" alt="纽约公交司机威廉·西米洛出走"></p>
<h2 id="价值"><a class="header-anchor" href="#价值">¶</a>价值</h2>
<blockquote>
<p>哲人：例如，人怎样才能够获得“勇气”？阿德勒的见解是：人只有在能够感觉自己有价值的时候才可以获得勇气。</p>
<p>青年：在能够感觉自己有价值的时候？</p>
<p>哲人：我们在讨论自卑感的时候，不是说过这是主观价值问题吗？是认为“自己有价值”？还是认为“自己是没有价值的存在”？如果能够认为“自己有价值”的话，那个人就能够接纳自我并建立起直面人生课题的勇气。这里的问题是“究竟怎样才能够感觉自己有价值”这一点。</p>
<p>青年：是的，正是如此！这一点必须明确一下！</p>
<p>哲人：非常简单！人只有在可以体会到“我对共同体有用”的时候才能够感觉到自己的价值。这就是阿德勒心理学的答案。</p>
<p>青年：我对共同体有用？</p>
<p>哲人：就是通过为共同体也就是他人服务能够体会到“我对别人有用”，不是被别人评价说“很好”，而是主观上就能够认为“我能够对他人做出贡献”，只有这样我们才能够真正体会到自己的价值。之前讨论到的“共同体感觉”或“鼓励”的话题也与此紧密相关。</p>
</blockquote>
<p>我到底有没有价值？“价值就是凝结在商品中无差别的人类劳动”，我们一直以来受到的教育就是如此。女权主义兴起之后，“家庭”这一“市场”之外的再生产领域让“价值”的定义更加宽泛了。一个人很难是“无价值”的。阿德勒甚至认为，仅仅是“存在”本身就已经体现出了价值，就值得为之而感谢：</p>
<blockquote>
<p>我们在看待他人的时候，往往会先任意虚构一个“对自己来说理想的形象”，然后再像做减法一样地去评价。</p>
<p>例如，父母全都希望自己的孩子学习、运动样样满分，然后上好大学、进大公司。如果跟这种——根本不存在的——理想的孩子形象相比，就会对自己的孩子产生种种不满。从理想形象的100分中一点一点地扣分。这正是“评价”的想法。</p>
<p>不要这样，而应不将自己的孩子跟任何人相比，就把他看作他自己，对他的存在心怀喜悦与感激，不要按照理想形象去扣分，而是从零起点出发。如果是这样的话，那就能够对“存在”本身表示感谢了。</p>
</blockquote>
<h2 id="共同体感觉的建立"><a class="header-anchor" href="#共同体感觉的建立">¶</a>共同体感觉的建立</h2>
<p>建立起共同体感觉需要从以下三点做起：“自我接纳”，“他者信赖”和“他者贡献”。</p>
<blockquote>
<p>自我肯定是明明做不到但还是暗示自己说“我能行”或者“我很强”，也可以说是一种容易导致优越情结的想法，是对自己撒谎的生活方式。</p>
<p>而另一方面，自我接纳是指假如做不到就诚实地接受这个“做不到的自己”，然后尽量朝着能够做到的方向去努力，不对自己撒谎。</p>
<p>对得了60分的自己说“这次只是运气不好，真正的自己能得100分”，这就是自我肯定；与此相对，在诚实地接受60分的自己的基础上努力思考“如何才能接近100分”，这就是自我接纳。<br>
……<br>
青年：哦，这么一说……以前有位作家曾引用过这样的话，“上帝，请赐予我平静，去接受我无法改变的；给予我勇气，去改变我能改变的；赐我智慧，分辨这两者的区别。”来自一部小说。哲人：是的，我知道，这是广为流传的“尼布尔的祈祷文”，是一段非常有名的话。</p>
</blockquote>
<p>尼布尔的宁静祷文，“尽人事以听天命”。</p>
<blockquote>
<p>青年：您是说是否背叛是他人的课题，不是自己所能左右的事情？要做到肯定性的达观？先生的主张总是忽视感情！遭到背叛时的怒气和悲伤又该怎么办呢？</p>
<p>哲人：悲伤的时候尽管悲伤就可以。因为，正是想要逃避痛苦或悲伤才不敢付诸行动，以至于与任何人都无法建立起深厚的关系。</p>
<p>请你这样想。我们可以相信也可以怀疑；并且，我们的目标是把别人当作朋友。如此一来，是该选择信任还是怀疑，答案就非常明显了。</p>
</blockquote>
<p>他者信赖，就是要以信赖的预设立场去发展人际关系。不必害怕被背叛。如果遭到背叛，那也是他人课题的结果，我们无从干涉，能做的就是保持自己的真诚。</p>
<blockquote>
<p>哲人：他者贡献的意思并不是自我牺牲。相反，阿德勒把为他人牺牲自己人生的人称作“过度适应社会的人”，并对此给予警示。</p>
<p>并且，请你想一想。我们只有在感觉到自己的存在或行为对共同体有益的时候，也就是体会到“我对他人有用”的时候，才能切实感受到自己的价值。是这样吧？</p>
<p>也就是说，他者贡献并不是舍弃“我”而为他人效劳，它反而是为了能够体会到“我”的价值而采取的一种手段。</p>
<p>青年：贡献他人是为了自己？</p>
<p>哲人：是的，不需要自我牺牲。</p>
</blockquote>
<p>这里所贬斥的“自我牺牲”，应当与我们所说的“烈士的牺牲”是有本质区别的。烈士之牺牲，是在危急关头将自己的价值发挥到极致，牺牲小我以成就大我；这里的“自我牺牲”，更像是一种“自我感动”式的刻奇，然而其并不能体现出真正的价值。</p>
<p>也许可以试着用前面的优越情结来解释：当人陷入自卑情结时，会认为差劲的自己非得作出巨大牺牲才能够“有所贡献”，因此特意选择那种自我牺牲的方式去做事。然而，不论这样做是否真的有效，由于自己有巨大的牺牲，一下子就占据了“劳苦功高”的道德高地，优越情结由此产生了。</p>
<blockquote>
<p>劳动并不是赚取金钱的手段，我们通过劳动来实现他者贡献、参与共同体、体会“我对他人有用”，进而获得自己的存在价值。</p>
</blockquote>
<p>马克思的政治经济学理论也强调类似的观点，共产主义“是以每一个个人的全面而自由的发展为基本原则的社会形式”，“在那里，每个人的自由发展是一切人的自由发展的条件”。但这种自由绝不是抽象的、想象的、脱离于人的具体实践活动之外的概念式的“绝对自由”。“自由而全面的发展”存在于人的具体实践活动中，存在于人与自然、社会、他者以及自身的不断交换、沟通的现实中。共产主义对于现实存在的人来说，不是“应当”如何，而是实践，是现实的人为了实现自身全面而自由的发展，破除束缚人、剥削人、压迫人的一切思想上和现实中的障碍，从而不断改变世界，创造适合人类生存的具体实践。</p>
<blockquote>
<p>哲人：为了方便起见，前面我一直按照自我接纳、他者信赖、他者贡献这种顺序来进行说明。但是，这三者是缺一不可的整体。</p>
<p>正因为接受了真实的自我——也就是“自我接纳”——才能够不惧背叛地做到“他者信赖”；而且，正因为对他人给予无条件的信赖并能够视他人为自己的伙伴，才能够做到“他者贡献”；同时，正因为对他人有所贡献，才能够体会到“我对他人有用”进而接受真实的自己，做到“自我接纳”。</p>
</blockquote>
<p>自我接纳、他者信赖、他者贡献，这三点是相辅相成的。能够做到的话，一定会形成良性的循环吧。</p>
<h2 id="幸福"><a class="header-anchor" href="#幸福">¶</a>幸福</h2>
<blockquote>
<p>总结一下哲人的主张，就是这样：人只有在能够感觉到“我对别人有用”的时候才能体会到自己的价值。但是，这种贡献也可以通过看不见的形式实现。只要有“对别人有用”的主观感觉，即“贡献感”就可以。并且，哲人还得出了这样的结论：幸福就是“贡献感”。</p>
</blockquote>
<p>这一点就比较玄学了，贡献感就是“我寻思我有贡献”，而且这样就能导向幸福。那么自我牺牲、自我感动是否也能让人幸福呢？</p>
<p>不过，这么做的人自己恐怕确实是幸福的。至于其他人怎么想，“课题分离”嘛，不碍事。</p>
<h2 id="活在当下"><a class="header-anchor" href="#活在当下">¶</a>活在当下</h2>
<blockquote>
<p>但是，希望特别优秀的愿望无法实现的时候——例如学习或运动进展不顺利的时候——就会转而“希望特别差劲”。</p>
<p>青年：为什么？哲人：无论是希望特别优秀还是希望特别差劲，其目的都一样——引起他人的关注、脱离“普通”状态、成为“特别的存在”。这就是他们的目的。</p>
<p>青年：嗯。好吧，请您继续说！</p>
<p>哲人：本来，无论是学习还是运动，为了取得某些成果就需要付出一定的努力。但是，“希望特别差劲”的孩子，也就是陷入问题行为的孩子却可以在不付出这种健全努力的情况下也获得他人的关注。阿德勒心理学称之为“廉价的优越性追求”。</p>
</blockquote>
<p>最后，是甘于平凡。宁愿平凡，也不陷入“廉价的优越性追求”。</p>
<blockquote>
<p>哲人：请你这样想。人生就像是在每一个瞬间不停旋转起舞的连续的刹那。并且，暮然四顾时常常会惊觉：“已经来到这里了吗？”</p>
</blockquote>
<p>似乎这样的境界经常用来描述武林高手。像埼玉老师那样，每天100个仰卧起坐、100个俯卧撑，再加上100个深蹲和10公里长跑，之后恍然间就已无敌于天下。不过现实中恐怕也确实没有多少人有这样的专注与恒心就是了。</p>
<blockquote>
<p>哲人：是的。我们应该更加认真地过好“此时此刻”。如果感觉能够看得到过去也能预测到未来，那就证明你没有认真地活在“此时此刻”，而是生活在模糊而微弱的光中。</p>
<p>人生是连续的刹那，根本不存在过去和未来。你是想要通过关注过去或未来为自己寻找免罪符。过去发生了什么与你的“此时此刻”没有任何关系，未来会如何也不是“此时此刻”要考虑的问题。假如认真地活在“此时此刻”，那就根本不会说出那样的话。</p>
</blockquote>
<p>这里再次强调了“过去”的无意义。我们所能把握的只有当下。</p>
<blockquote>
<p>青年：当人生是连续刹那的时候，当人生只存在于“此时此刻”的时候，人生的意义究竟是什么呢？我是为了什么出生、经受满是苦难的生命、最后迎来死亡的呢？我不明白这其中的原因。</p>
<p>哲人：人生的意义是什么？人为了什么而活？当有人提出这个问题的时候，阿德勒的回答是：“并不存在普遍性的人生意义。”</p>
<p>青年：人生没有意义？</p>
<p>哲人：例如战祸或天灾，我们所居住的世界充满了各种不合理的事情。我们也不可能在被卷入战祸而丧命的孩子们面前谈什么“人生意义”。也就是说，人生并不存在可以作为常识来讲的意义。</p>
<p>但是，如果面对这种不合理的悲剧而不采取任何行动的话，那就等于是在肯定已经发生的悲剧。无论发生何种状况，我们都必须采取一些行动，必须对抗康德所说的倾向性。</p>
</blockquote>
<p>“朝闻道，夕死可矣”，其实可以不用追求那么崇高的东西。</p>
<p>很喜欢蓬莱山辉夜说的一段话：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">何を言っているの。</span><br><span class="line">私は永遠に住む者なのよ。過去は無限にやってくるわ。</span><br><span class="line">だから、今を楽しまなければ意味が無いじゃない。</span><br><span class="line">千年でも万年でも、今の一瞬に敵う物は無いの。</span><br><span class="line"></span><br><span class="line">一秒でも過去のことはどうでもいいのよ。</span><br><span class="line"></span><br><span class="line"><span class="comment">-------------------</span></span><br><span class="line"></span><br><span class="line">你在说什么呢。</span><br><span class="line">我是永远的居住者。过去是无限的。</span><br><span class="line">所以呢，现在不高兴的话不就没有意义了吗。</span><br><span class="line">千年也好万年也好，没有什么比得上现在这一瞬间。</span><br><span class="line"></span><br><span class="line">即使是一秒过去的事怎么样都好。</span><br></pre></td></tr></table></figure>
<p><img src="http://storage.live.com/items/3550ADEE9AFF19FD!99611:/ies6Bon2Tt41m7h.jpg?authkey=AIbyrqnS5z58phc" alt="Happy Ending"></p>
]]></content>
      <tags>
        <tag>读书</tag>
        <tag>心理学</tag>
      </tags>
  </entry>
</search>
