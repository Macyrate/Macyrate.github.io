---
title: 'C#杂记之陆：真·杂记'
tags:
- CSharp
- 笔记
---

这一篇是真正的“杂”记。这两天阅览了一些Java中常见的问题，鉴于Java与C#的殊途同归，也有了不少收获。

为查漏补缺，将之前理解还不够明了的部分记在这里。

# 关于多态

面向对象设计有四大特征：

- 抽象：通过类和接口的属性与方法实现
- 继承：通过类和接口的继承实现
- 封装：通过访问控制符实现
- 多态：？？？

多态这个概念比较神秘。以前看到一个解释是这么说的：

> 继承是子类引用父类方法；多态是父类引用子类方法。

当时看了觉得有点奇怪，父类怎么能引用子类方法呢？现在我的理解是如下：

子类对象**继承**了父类方法，但是可能又对继承过来的父类方法进行了**重写**覆盖。而一切出现父类的地方都可以用其子类**向上转型**进行替换(里氏替换原则)，调用方法时调用的会是在子类里被重写的子类方法。继承、重写和向上转型，这时实现多态的三要素。

这样，如果一个父类有多个子类，它们又分别用不同方式重写了继承下来的同一个方法，那么在把这些子类都当父类使用时，就会展现出多态性：明明是对同一个类的对象调用了同一个方法，但行为却完全不同。

举个例子，假如有个`扬声器`类，包含一个`大叫()`方法，调用时会“嘤嘤嘤”；而继承自它的有大叫“洒↓比↑”的`喇叭`类和大叫“哼，哼，啊啊啊啊啊啊啊”的`野兽先辈`类：

```CSharp
//这段代码甚至真的可以跑，C#支持用汉字做标识符，大概是因为用了Unicode
using System;
using System.Collections.Generic;

namespace PlayGround
{
    class Program
    {
        class 扬声器
        {
            public virtual void 大叫()
            {
                Console.WriteLine("嘤嘤嘤");
            }
        }

        class 喇叭 : 扬声器
        {
            public override void 大叫()
            {
                Console.WriteLine("洒↓比↑");
            }
        }

        class 野兽先辈 : 扬声器
        {
            public override void 大叫()
            {
                Console.WriteLine("哼，哼，啊啊啊啊啊啊啊");
            }
        }

        class 屑狐狸 : 扬声器
        {
            public override void 大叫()
            {
                Console.WriteLine("我系猫咪");
            }
        }

        static void Main(string[] args)
        {
            List<扬声器> 一堆扬声器 = new List<扬声器>() { new 扬声器(), new 喇叭(), new 野兽先辈(), new 屑狐狸() };

            foreach (扬声器 某个扬声器 in 一堆扬声器)
            {
                某个扬声器.大叫();
                // 输出：
                // 嘤嘤嘤
                // 洒↓比↑
                // 哼，哼，啊啊啊啊啊啊啊
                // 我系猫咪
            }
        }
    }
}
```

# 关于接口和抽象类的区别

