---
title: 'C#杂记之壹：委托入门'
date: 2020-02-27 12:25:36
tags:
- C Sharp
- 笔记
---
此前虽然接触过C#中的一些较为高级的操作，但基本是只知其有，不知在哪些场景下可以应用。这几天写着代码就顿觉冗杂不堪，虽然能跑但看起来十分难受，希望寻求一些函数式编程之类的魔法来简化流程。

那首先要理解的还是委托和事件。虽然学完了也不一定会用，但看懂一点总是好的。

# 委托

如之前所说，委托类似于函数指针。或者说，委托是一种存储函数引用的**类型**。由于函数的参数须是变量/常量/表达式，只要把函数变成一种引用类型的变量，就可以让一个函数作为其它函数的参数了。同样，也可以通过直接调用委托变量来调用委托变量所引用的函数。

为什么要把**类型**加粗？因为声明一个委托类型并不是声明一个委托变量，而是一类委托的**模板**，说明了这类委托应具有的的返回值类型与参数列表。委托类型与具体的委托变量之关系，类似于“类”和“对象”的关系。

委托类型声明和函数类似，拥有返回值类型和参数列表，但没有函数体，并且在前面用`delegate`关键字声明这是一个委托类型，再声明这个委托类型的变量：

```CSharp
//声明委托类型和委托变量
delegate double ProcessDelegate(double param1, double param2);
ProcessDelegate process;

//...

//将函数Multiply注册到ProcessDelegate类型的委托变量process
process = new ProcessDelegate(Multiply);

//也可以简写
process = Multiply;

//多播委托(虽然这里没什么用)
process += Divide;
process += Add;

//调用委托
System.Console.WriteLine($"Result:{process(12.1, 22.4)}");
```

实际上，委托确实是一种“类”。上面所展示的委托变量声明，其形式就和类的实例化完全一致。在委托变量后面打个点，你甚至能看到一堆委托类型包含的方法和属性：

![委托也是类](https://i.loli.net/2020/02/27/xVONQiE1hJIrWf2.jpg)

<!--more-->

## 何时用委托？

**委托的一个有趣且有用的属性是，它不知道也不关心所引用的方法的类；只关心引用的方法是否具有与委托相同的参数和返回类型。** 

这就像是当你饿了的时候，并不是非得去哪家特定的饭店吃饭，而是只要你给钱（参数）能得到食物（返回类型）就行了。这样，就无需先通过继承`建筑`类来构建一个`店铺`类，再实现一个`厨房`接口之类的东西，让其成为`饭店`——而是就算是大街上一个路人你能从TA那买到吃的，也算是能满足你的需求。

因此，委托的大用处在于解耦。一个典型的例子是用在`LINQ`中：

```CSharp
var smallNumbers = numbers.Where(n => n < 10);
```

LINQ的详细介绍留至以后，这可以说是C#中最为变态的武器之一，这里只说说Where方法。

首先，Where方法是接口`IEnumerable`和`IEnumerable<T>`中的方法，也只有实现了这两个接口之一或它们的派生接口（如`IQueryable<T>`）的类可以使用LINQ，这种类被称为**可查询类型**。Where方法的原型：

```CSharp
public static IEnumerable<TSource> Where<TSource> (this IEnumerable<TSource> source, Func<TSource, bool> predicate);
```

分析一下。

首先，这个方法是一个`static`方法，并且参数列表第一个被`this`修饰，这是**扩展方法**的特征。这是因为Where方法之类的LINQ内容并不是直接定义在`IEnumerable<T>`接口里，而是在`System.Linq`中定义的扩展方法。扩展方法的第一个，被`this`所修饰的参数指明了这个扩展方法扩展的是什么类型。

![Where是扩展方法.jpg](https://i.loli.net/2020/02/27/yb6g3GTIoA1rB4R.jpg)

可以看到，如果注释掉`using System.Linq`，

因此，方法原型中的`this IEnumerable<TSource> source`，指的就是Where方法所扩展的是`IEnumerable<TSource>`接口。

而后面的`Func<TSource, bool> predicate`就是一个委托，并且是泛型委托，关系到“协变和逆变”之类的高深操作，详细的下次再说。

这个委托用于对每个元素进行测试，看它们是否满足条件。自然，如果满足条件，这个委托将返回bool型的`true`。泛型委托的泛型参数中，最后一个即为委托的返回类型，故而是bool型。而前面的`TSource`指示了所封装的方法的参数类型。

因此，这个`Func<TSource, bool> predicate`可以看作是：

```CSharp
delegate bool FooDelegate(TSource foo);     //这里的TSource是某个类型

bool FooFunc(TSource foo){
    //...
    return true;
}

FooDelegate predicate = new FooDelegate(FooFunc);
```